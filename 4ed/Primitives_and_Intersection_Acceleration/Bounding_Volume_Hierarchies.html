
<!doctype html>
<html lang="en">
<head>

<!-- all praise to https://realfavicongenerator.net -->
<link rel="icon" href="/favicon.ico?v=2" /> <!-- force refresh -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="/fonts.css">
  <link rel="stylesheet" href="../pbrstyle.css">
  <link rel="stylesheet" href="/fontawesome-free-5.15.3-web/css/all.css">

<script async src="https://cse.google.com/cse.js?cx=22a43cef261a245ea"></script>  <script src="/react.min.js"></script>
  <script src="/react-dom.min.js"></script>
  <script src="/jeri.min.js"></script>
  <link rel="preload" href="/exr.worker.js" as="script" crossorigin="anonymous">
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/bootstrap.min.css">

  <title>Bounding Volume Hierarchies</title>
</head>
        
<body>

<nav class="fixed-top-lg-navbar navbar navbar-expand bg-light navbar-light">
  <ul class="nav navbar-nav">
    <a class="navbar-brand" href="../contents.html"><img src="../pbr.jpg" width=25 height=25></a>
    <li class="nav-item"><a class="nav-link" href="../Primitives_and_Intersection_Acceleration.html">Primitives and Intersection Acceleration</a></li>
    <span class="navbar-text">/</span>
    <li class="nav-item"><a class="nav-link" href="#">Bounding Volume Hierarchies</a></li>
    <span class="navbar-text">&nbsp;&nbsp;</span>
    <li class="nav-item"><a class="nav-link" href="../Primitives_and_Intersection_Acceleration/Aggregates.html">(Previous: Aggregates)</a></li>
  </ul>

  <ul class="nav navbar-nav ml-auto d-none d-md-block">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
  <ul class="nav navbar-nav d-block d-md-none">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
</nav>

<div class="maincontainer">
<div class="container-fluid">

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#"><i class="fas fa-link "></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:bvh"></span><h2>7.3 Bounding Volume Hierarchies</h2><p>



</p>
<p>Bounding volume hierarchies (BVHs) are an approach for ray intersection
acceleration based on primitive subdivision, where the primitives are
partitioned into a hierarchy of disjoint sets.  (In contrast, spatial
subdivision generally partitions space into a hierarchy of disjoint sets.)
Figure&nbsp;<a href="#fig:bvh-concept">7.3</a> shows a bounding volume hierarchy for a simple
scene.  Primitives are stored in the leaves, and each node stores a
bounding box of the primitives in the nodes beneath it.  Thus, as a ray
traverses through the tree, any time it does not intersect a node&rsquo;s bounds,
the subtree beneath that node can be skipped.

</p>
<p> </p>
<span class="anchor" id="fig:bvh-concept"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="pha07f03.svg" title=""><img src="pha07f03.svg" width=680 height=234 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 7.3: Bounding Volume Hierarchy for a Simple Scene. <span class="legend"> 
(a)&nbsp;A small collection of primitives, with bounding boxes shown by dashed
  lines.  The primitives are aggregated based on proximity; here, the sphere
  and the equilateral triangle are bounded by another bounding box before
  being bounded by a bounding box that encompasses the entire scene (both
  shown in solid lines).
(b)&nbsp;The corresponding bounding volume hierarchy.  The root node holds the
bounds of the entire scene.  Here, it has two children, one storing a bounding box
that encompasses the sphere and equilateral triangle (that in turn has
those primitives as its children)  and the other storing the bounding
box that holds the skinny triangle.
</span>
</figcaption>
</div></div><p>


</p>
<p>One property of primitive subdivision is that each primitive appears in the
hierarchy only once.  In contrast, a primitive may overlap multiple spatial
regions with spatial subdivision and thus may be tested for intersection
multiple times as the ray passes through them.<button style="button" data-toggle="tooltip" data-placement="right" data-html="true" class="btn footnote-button" title="The
<em>mailboxing</em> technique can be used to avoid these multiple
intersections for accelerators that use spatial subdivision, though its
implementation can be tricky in the presence of multi-threading.  More
information on mailboxing is available in the &ldquo;Further Reading&rdquo; section.">
      <sup>&dagger;</sup>
    </button>
		
Another implication of this property is that the amount of memory needed to
represent the primitive subdivision hierarchy is bounded.  For a binary BVH
that stores a single primitive in each leaf, the total number of nodes is
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.56ex" height="2.343ex" style="vertical-align: -0.505ex;" viewBox="0 -791.3 2824.4 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">2 n minus 1</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2212" d="M722 250c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="500" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2212" x="1323" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="2323" y="0"></use>
</g>
</svg>, where <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 600.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
</g>
</svg> is the number of primitives.  (There are <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 600.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
</g>
</svg> leaf
nodes and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.398ex" height="2.343ex" style="vertical-align: -0.505ex;" viewBox="0 -791.3 2323.9 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n minus 1</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2212" d="M722 250c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2212" x="822" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="1823" y="0"></use>
</g>
</svg> interior nodes.)  If leaves store multiple primitives,
fewer nodes are needed.

</p>
<p>BVHs are more efficient to build than kd-trees, and are generally more
numerically robust and less prone to missed intersections due to round-off
errors than kd-trees are.  The BVH aggregate, <tt>BVHAggregate</tt>, is
therefore the default acceleration structure in <tt>pbrt</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-BVHAggregateDefinition-0"></span><div class="fragmentname">&lt;&lt;BVHAggregate Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="BVHAggregate"></span>BVHAggregate {
  public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-BVHAggregatePublicTypes-0">BVHAggregate Public Types</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-984" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-984"><i></i></a><div id="fragbit-984" class="collapse show"><div class="fragmentcode">       enum class SplitMethod { SAH, HLBVH, Middle, EqualCounts };</div></div>
    &lt;&lt;<span class="fragmentname">BVHAggregate Public Methods</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-985" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-985"><i></i></a><div id="fragbit-985" class="collapse show"><div class="fragmentcode">       BVHAggregate(std::vector&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; p, int maxPrimsInNode = 1,
                SplitMethod splitMethod = SplitMethod::SAH);
       
       static BVHAggregate *Create(std::vector&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; prims,
                               const ParameterDictionary &amp;parameters);
       
       <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> Bounds() const;
       pstd::optional&lt;ShapeIntersection&gt; Intersect(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray, Float tMax) const;
       bool IntersectP(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray, Float tMax) const;</div></div>
  private:
    &lt;&lt;<span class="fragmentname">BVHAggregate Private Methods</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-986" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-986"><i></i></a><div id="fragbit-986" class="collapse show"><div class="fragmentcode">       BVHBuildNode *buildRecursive(<a href="../Utilities/Parallelism.html#ThreadLocal" class="code">ThreadLocal</a>&lt;Allocator&gt; &amp;threadAllocators,
                                    pstd::span&lt;BVHPrimitive&gt; bvhPrimitives,
                                    std::atomic&lt;int&gt; *totalNodes,
                                    std::atomic&lt;int&gt; *orderedPrimsOffset,
                                    std::vector&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; &amp;orderedPrims);
       BVHBuildNode *buildHLBVH(Allocator alloc,
                                const std::vector&lt;BVHPrimitive&gt; &amp;primitiveInfo,
                                std::atomic&lt;int&gt; *totalNodes,
                                std::vector&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; &amp;orderedPrims);
       BVHBuildNode *emitLBVH(BVHBuildNode *&amp;buildNodes,
                              const std::vector&lt;BVHPrimitive&gt; &amp;primitiveInfo,
                              MortonPrimitive *mortonPrims, int nPrimitives, int *totalNodes,
                              std::vector&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; &amp;orderedPrims,
                              std::atomic&lt;int&gt; *orderedPrimsOffset, int bitIndex);
       BVHBuildNode *buildUpperSAH(Allocator alloc,
                                   std::vector&lt;BVHBuildNode *&gt; &amp;treeletRoots, int start,
                                   int end, std::atomic&lt;int&gt; *totalNodes) const;
       int flattenBVH(BVHBuildNode *node, int *offset);</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-BVHAggregatePrivateMembers-0">BVHAggregate Private Members</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-987" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-987"><i></i></a><div id="fragbit-987" class="collapse show"><div class="fragmentcode">       int maxPrimsInNode;
       std::vector&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; primitives;
       SplitMethod splitMethod;
       LinearBVHNode *nodes = nullptr;</div></div>
};</div><p>


</p>
<p>

</p>
<p>Its constructor takes an enumerator value that describes which of four
algorithms to use when partitioning primitives to build the tree.  The
default, <tt>SAH</tt>, indicates that an algorithm based on the &ldquo;surface
area heuristic,&rdquo; discussed in Section&nbsp;<a href="#sec:sah">7.3.2</a>, should be used.  An
alternative, <tt>HLBVH</tt>, which is discussed in Section&nbsp;<a href="#sec:hlbvh">7.3.3</a>,
can be constructed more efficiently (and more easily parallelized), but it
does not build trees that are as effective as <tt>SAH</tt>.  The remaining
two approaches use even less computation but create
fairly low-quality trees.  They are mostly useful for illuminating the
superiority of the first two approaches.

</p>
<p></p>
<span class="anchor" id="fragment-BVHAggregatePublicTypes-0"></span><div class="fragmentname">&lt;&lt;BVHAggregate Public Types&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">enum class <span class="anchor" id="SplitMethod"></span>SplitMethod { <span class="anchor" id="SplitMethod::SAH"></span>SAH, <span class="anchor" id="SplitMethod::HLBVH"></span>HLBVH, <span class="anchor" id="SplitMethod::Middle"></span>Middle, <span class="anchor" id="SplitMethod::EqualCounts"></span>EqualCounts };</div><p>


</p>
<p>In addition to the enumerator, the constructor takes the primitives
themselves and the maximum number of primitives that can be in any leaf
node.

</p>
<p></p>
<span class="anchor" id="fragment-BVHAggregateMethodDefinitions-0"></span><div class="fragmentname">&lt;&lt;BVHAggregate Method Definitions&gt;&gt;=&nbsp;<a href="#fragment-BVHAggregateMethodDefinitions-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">BVHAggregate::BVHAggregate(std::vector&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; prims,
        int <a href="#BVHAggregate::maxPrimsInNode" class="code">maxPrimsInNode</a>, SplitMethod <a href="#BVHAggregate::splitMethod" class="code">splitMethod</a>)
    : <a href="#BVHAggregate::maxPrimsInNode" class="code">maxPrimsInNode</a>(std::min(255, <a href="#BVHAggregate::maxPrimsInNode" class="code">maxPrimsInNode</a>)),
      <a href="#BVHAggregate::primitives" class="code">primitives</a>(std::move(prims)), <a href="#BVHAggregate::splitMethod" class="code">splitMethod</a>(<a href="#BVHAggregate::splitMethod" class="code">splitMethod</a>) { 
    &lt;&lt;<span class="fragmentname"><a href="#fragment-BuildBVHfrommonoprimitives-0">Build BVH from <tt>primitives</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-988" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-988"><i></i></a><div id="fragbit-988" class="collapse show"><div class="fragmentcode">       &lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonobvhPrimitivesarrayforprimitives-0">Initialize <tt>bvhPrimitives</tt> array for primitives</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-989" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-989"><i></i></a><div id="fragbit-989" class="collapse show"><div class="fragmentcode">          std::vector&lt;BVHPrimitive&gt; bvhPrimitives(<a href="#BVHAggregate::primitives" class="code">primitives</a>.size());
          for (size_t i = 0; i &lt; <a href="#BVHAggregate::primitives" class="code">primitives</a>.size(); ++i)
              bvhPrimitives[i] = BVHPrimitive(i, <a href="#BVHAggregate::primitives" class="code">primitives</a>[i].<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Bounds" class="code">Bounds</a>());</div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-BuildBVHforprimitivesusingmonobvhPrimitives-0">Build BVH for primitives using <tt>bvhPrimitives</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-990" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-990"><i></i></a><div id="fragbit-990" class="collapse show"><div class="fragmentcode">          &lt;&lt;<span class="fragmentname"><a href="#fragment-DeclaremonoAllocatorsusedforBVHconstruction-0">Declare <tt>Allocator</tt>s used for BVH construction</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-991" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-991"><i></i></a><div id="fragbit-991" class="collapse show"><div class="fragmentcode">             pstd::pmr::monotonic_buffer_resource resource;
             <a href="../Introduction/Using_and_Understanding_the_Code.html#Allocator" class="code">Allocator</a> alloc(&amp;resource);
             using Resource = pstd::pmr::monotonic_buffer_resource;
             std::vector&lt;std::unique_ptr&lt;Resource&gt;&gt; threadBufferResources;
             <a href="../Utilities/Parallelism.html#ThreadLocal" class="code">ThreadLocal</a>&lt;<a href="../Introduction/Using_and_Understanding_the_Code.html#Allocator" class="code">Allocator</a>&gt; threadAllocators([&amp;threadBufferResources]() {
                 threadBufferResources.push_back(std::make_unique&lt;Resource&gt;());
                 auto ptr = threadBufferResources.back().get();
                 return <a href="../Introduction/Using_and_Understanding_the_Code.html#Allocator" class="code">Allocator</a>(ptr);
             });</div></div>
          std::vector&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; orderedPrims(<a href="#BVHAggregate::primitives" class="code">primitives</a>.size());
          BVHBuildNode *root;
          &lt;&lt;<span class="fragmentname"><a href="#fragment-BuildBVHaccordingtoselectedmonosplitMethod-0">Build BVH according to selected <tt>splitMethod</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-992" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-992"><i></i></a><div id="fragbit-992" class="collapse show"><div class="fragmentcode">             std::atomic&lt;int&gt; totalNodes{0};
             if (<a href="#BVHAggregate::splitMethod" class="code">splitMethod</a> == <a href="#SplitMethod::HLBVH" class="code">SplitMethod</a>::HLBVH) {
                 root = <a href="#BVHAggregate::buildHLBVH" class="code">buildHLBVH</a>(alloc, bvhPrimitives, &amp;totalNodes, orderedPrims);
             } else {
                 std::atomic&lt;int&gt; orderedPrimsOffset{0};
                 root = <a href="#BVHAggregate::buildRecursive" class="code">buildRecursive</a>(threadAllocators,
                                       pstd::span&lt;BVHPrimitive&gt;(bvhPrimitives),
                                       &amp;totalNodes, &amp;orderedPrimsOffset, orderedPrims);
             }
             <a href="#BVHAggregate::primitives" class="code">primitives</a>.swap(orderedPrims);</div></div></div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-ConvertBVHintocompactrepresentationinmononodesarray-0">Convert BVH into compact representation in <tt>nodes</tt> array</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-993" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-993"><i></i></a><div id="fragbit-993" class="collapse show"><div class="fragmentcode">          bvhPrimitives.resize(0);
          bvhPrimitives.shrink_to_fit();
          nodes = new LinearBVHNode[totalNodes];
          int offset = 0;
          <a href="#BVHAggregate::flattenBVH" class="code">flattenBVH</a>(root, &amp;offset);
          </div></div></div></div>
}</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-BVHAggregatePrivateMembers-0"></span><div class="fragmentname">&lt;&lt;BVHAggregate Private Members&gt;&gt;=&nbsp;<a href="#fragment-BVHAggregatePrivateMembers-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">int <span class="anchor" id="BVHAggregate::maxPrimsInNode"></span>maxPrimsInNode;
std::vector&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; <span class="anchor" id="BVHAggregate::primitives"></span>primitives;
SplitMethod <span class="anchor" id="BVHAggregate::splitMethod"></span>splitMethod;</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#BVHConstruction"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="BVHConstruction"></span><h3>7.3.1  BVH Construction</h3><p>


</p>
<p>There are three stages to BVH construction in the implementation here.
First, bounding information about each primitive is computed and stored in
an array that will be used during tree construction.  Next, the tree is
built using the algorithm choice encoded in <tt>splitMethod</tt>.  The result
is a binary tree where each interior node holds pointers to its children
and each leaf node holds references to one or more primitives.  Finally,
this tree is converted to a more compact (and thus more efficient)
pointerless representation for use during rendering.  (The implementation
is easier with this approach, versus computing the
pointerless representation directly during tree construction, which is also
possible.)

</p>
<p></p>
<span class="anchor" id="fragment-BuildBVHfrommonoprimitives-0"></span><div class="fragmentname">&lt;&lt;Build BVH from <tt>primitives</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">&lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonobvhPrimitivesarrayforprimitives-0">Initialize <tt>bvhPrimitives</tt> array for primitives</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-994" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-994"><i></i></a><div id="fragbit-994" class="collapse show"><div class="fragmentcode">   std::vector&lt;BVHPrimitive&gt; bvhPrimitives(<a href="#BVHAggregate::primitives" class="code">primitives</a>.size());
   for (size_t i = 0; i &lt; <a href="#BVHAggregate::primitives" class="code">primitives</a>.size(); ++i)
       bvhPrimitives[i] = BVHPrimitive(i, <a href="#BVHAggregate::primitives" class="code">primitives</a>[i].<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Bounds" class="code">Bounds</a>());</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-BuildBVHforprimitivesusingmonobvhPrimitives-0">Build BVH for primitives using <tt>bvhPrimitives</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-995" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-995"><i></i></a><div id="fragbit-995" class="collapse show"><div class="fragmentcode">   &lt;&lt;<span class="fragmentname"><a href="#fragment-DeclaremonoAllocatorsusedforBVHconstruction-0">Declare <tt>Allocator</tt>s used for BVH construction</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-996" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-996"><i></i></a><div id="fragbit-996" class="collapse show"><div class="fragmentcode">      pstd::pmr::monotonic_buffer_resource resource;
      <a href="../Introduction/Using_and_Understanding_the_Code.html#Allocator" class="code">Allocator</a> alloc(&amp;resource);
      using Resource = pstd::pmr::monotonic_buffer_resource;
      std::vector&lt;std::unique_ptr&lt;Resource&gt;&gt; threadBufferResources;
      <a href="../Utilities/Parallelism.html#ThreadLocal" class="code">ThreadLocal</a>&lt;<a href="../Introduction/Using_and_Understanding_the_Code.html#Allocator" class="code">Allocator</a>&gt; threadAllocators([&amp;threadBufferResources]() {
          threadBufferResources.push_back(std::make_unique&lt;Resource&gt;());
          auto ptr = threadBufferResources.back().get();
          return <a href="../Introduction/Using_and_Understanding_the_Code.html#Allocator" class="code">Allocator</a>(ptr);
      });</div></div>
   std::vector&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; orderedPrims(<a href="#BVHAggregate::primitives" class="code">primitives</a>.size());
   BVHBuildNode *root;
   &lt;&lt;<span class="fragmentname"><a href="#fragment-BuildBVHaccordingtoselectedmonosplitMethod-0">Build BVH according to selected <tt>splitMethod</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-997" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-997"><i></i></a><div id="fragbit-997" class="collapse show"><div class="fragmentcode">      std::atomic&lt;int&gt; totalNodes{0};
      if (<a href="#BVHAggregate::splitMethod" class="code">splitMethod</a> == <a href="#SplitMethod::HLBVH" class="code">SplitMethod</a>::HLBVH) {
          root = <a href="#BVHAggregate::buildHLBVH" class="code">buildHLBVH</a>(alloc, bvhPrimitives, &amp;totalNodes, orderedPrims);
      } else {
          std::atomic&lt;int&gt; orderedPrimsOffset{0};
          root = <a href="#BVHAggregate::buildRecursive" class="code">buildRecursive</a>(threadAllocators,
                                pstd::span&lt;BVHPrimitive&gt;(bvhPrimitives),
                                &amp;totalNodes, &amp;orderedPrimsOffset, orderedPrims);
      }
      <a href="#BVHAggregate::primitives" class="code">primitives</a>.swap(orderedPrims);</div></div></div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-ConvertBVHintocompactrepresentationinmononodesarray-0">Convert BVH into compact representation in <tt>nodes</tt> array</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-998" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-998"><i></i></a><div id="fragbit-998" class="collapse show"><div class="fragmentcode">   bvhPrimitives.resize(0);
   bvhPrimitives.shrink_to_fit();
   nodes = new LinearBVHNode[totalNodes];
   int offset = 0;
   <a href="#BVHAggregate::flattenBVH" class="code">flattenBVH</a>(root, &amp;offset);
   </div></div></div><p>


</p>
<p>For each primitive to be stored in the BVH, an instance of the
<tt>BVHPrimitive</tt> structure stores its
complete bounding box and its index in the <tt>primitives</tt> array.

</p>
<p></p>
<span class="anchor" id="fragment-InitializemonobvhPrimitivesarrayforprimitives-0"></span><div class="fragmentname">&lt;&lt;Initialize <tt>bvhPrimitives</tt> array for primitives&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::vector&lt;BVHPrimitive&gt; bvhPrimitives(<a href="#BVHAggregate::primitives" class="code">primitives</a>.size());
for (size_t i = 0; i &lt; <a href="#BVHAggregate::primitives" class="code">primitives</a>.size(); ++i)
    bvhPrimitives[i] = BVHPrimitive(i, <a href="#BVHAggregate::primitives" class="code">primitives</a>[i].<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Bounds" class="code">Bounds</a>());</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-BVHPrimitiveDefinition-0"></span><div class="fragmentname">&lt;&lt;BVHPrimitive Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">struct <span class="anchor" id="BVHPrimitive"></span>BVHPrimitive {
    BVHPrimitive(size_t primitiveIndex, const <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> &amp;bounds)
        : primitiveIndex(primitiveIndex), bounds(bounds) {}
    size_t <span class="anchor" id="BVHPrimitive::primitiveIndex"></span>primitiveIndex;
    <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> <span class="anchor" id="BVHPrimitive::bounds"></span>bounds;
    &lt;&lt;<span class="fragmentname"><a href="#fragment-BVHPrimitivePublicMethods-0">BVHPrimitive Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-999" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-999"><i></i></a><div id="fragbit-999" class="collapse show"><div class="fragmentcode">       <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> Centroid() const { return .5f * bounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a> + .5f * bounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>; }</div></div>
};</div><p>


</p>
<p>A simple method makes the centroid of the bounding box available.

</p>
<p></p>
<span class="anchor" id="fragment-BVHPrimitivePublicMethods-0"></span><div class="fragmentname">&lt;&lt;BVHPrimitive Public Methods&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> <span class="anchor" id="BVHPrimitive::Centroid"></span>Centroid() const { return .5f * bounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a> + .5f * bounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>; }</div><p>


</p>
<p>

</p>
<p>Hierarchy construction can now begin.  In addition to initializing the
pointer to the root node of the BVH, <tt>root</tt>, an important side effect
of the tree construction process is that a new array of
<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive"><tt>Primitive</tt></a>s is stored in <tt>orderedPrims</tt>; this array stores
the primitives ordered so that the primitives in each leaf node occupy
a contiguous range in the array.  It is swapped with the original
<tt>primitives</tt> array after tree construction.

</p>
<p></p>
<span class="anchor" id="fragment-BuildBVHforprimitivesusingmonobvhPrimitives-0"></span><div class="fragmentname">&lt;&lt;Build BVH for primitives using <tt>bvhPrimitives</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">&lt;&lt;<span class="fragmentname"><a href="#fragment-DeclaremonoAllocatorsusedforBVHconstruction-0">Declare <tt>Allocator</tt>s used for BVH construction</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1000" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1000"><i></i></a><div id="fragbit-1000" class="collapse show"><div class="fragmentcode">   pstd::pmr::monotonic_buffer_resource resource;
   <a href="../Introduction/Using_and_Understanding_the_Code.html#Allocator" class="code">Allocator</a> alloc(&amp;resource);
   using Resource = pstd::pmr::monotonic_buffer_resource;
   std::vector&lt;std::unique_ptr&lt;Resource&gt;&gt; threadBufferResources;
   <a href="../Utilities/Parallelism.html#ThreadLocal" class="code">ThreadLocal</a>&lt;<a href="../Introduction/Using_and_Understanding_the_Code.html#Allocator" class="code">Allocator</a>&gt; threadAllocators([&amp;threadBufferResources]() {
       threadBufferResources.push_back(std::make_unique&lt;Resource&gt;());
       auto ptr = threadBufferResources.back().get();
       return <a href="../Introduction/Using_and_Understanding_the_Code.html#Allocator" class="code">Allocator</a>(ptr);
   });</div></div>
std::vector&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; orderedPrims(<a href="#BVHAggregate::primitives" class="code">primitives</a>.size());
BVHBuildNode *root;
&lt;&lt;<span class="fragmentname"><a href="#fragment-BuildBVHaccordingtoselectedmonosplitMethod-0">Build BVH according to selected <tt>splitMethod</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1001" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1001"><i></i></a><div id="fragbit-1001" class="collapse show"><div class="fragmentcode">   std::atomic&lt;int&gt; totalNodes{0};
   if (<a href="#BVHAggregate::splitMethod" class="code">splitMethod</a> == <a href="#SplitMethod::HLBVH" class="code">SplitMethod</a>::HLBVH) {
       root = <a href="#BVHAggregate::buildHLBVH" class="code">buildHLBVH</a>(alloc, bvhPrimitives, &amp;totalNodes, orderedPrims);
   } else {
       std::atomic&lt;int&gt; orderedPrimsOffset{0};
       root = <a href="#BVHAggregate::buildRecursive" class="code">buildRecursive</a>(threadAllocators,
                             pstd::span&lt;BVHPrimitive&gt;(bvhPrimitives),
                             &amp;totalNodes, &amp;orderedPrimsOffset, orderedPrims);
   }
   <a href="#BVHAggregate::primitives" class="code">primitives</a>.swap(orderedPrims);</div></div></div><p>


</p>
<p>Memory for the initial BVH is allocated using the following
<a href="../Introduction/Using_and_Understanding_the_Code.html#Allocator"><tt>Allocator</tt></a>s.  Note that all are based on the C++ standard library&rsquo;s
<tt>pmr::monotonic_buffer_resource</tt>, which efficiently allocates memory
from larger buffers.  This approach is not only more computationally
efficient than using a general-purpose allocator, but also uses less memory
in total
due to keeping less bookkeeping information with each allocation.  We have
found that using the default memory allocation algorithms in the place of
these uses approximately 10% more memory and takes approximately 10% longer for complex scenes.

</p>
<p>Because the <tt>pmr::monotonic_buffer_resource</tt> class cannot be used
concurrently by multiple threads without mutual exclusion, in the parts of
BVH construction that execute in parallel each thread uses
per-thread allocation of them with help from the <a href="../Utilities/Parallelism.html#ThreadLocal"><tt>ThreadLocal</tt></a> class.
Non-parallel code can use <tt>alloc</tt> directly.

</p>
<p></p>
<span class="anchor" id="fragment-DeclaremonoAllocatorsusedforBVHconstruction-0"></span><div class="fragmentname">&lt;&lt;Declare <tt>Allocator</tt>s used for BVH construction&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">pstd::pmr::monotonic_buffer_resource resource;
<a href="../Introduction/Using_and_Understanding_the_Code.html#Allocator" class="code">Allocator</a> alloc(&amp;resource);
using Resource = pstd::pmr::monotonic_buffer_resource;
std::vector&lt;std::unique_ptr&lt;Resource&gt;&gt; threadBufferResources;
<a href="../Utilities/Parallelism.html#ThreadLocal" class="code">ThreadLocal</a>&lt;<a href="../Introduction/Using_and_Understanding_the_Code.html#Allocator" class="code">Allocator</a>&gt; threadAllocators([&amp;threadBufferResources]() {
    threadBufferResources.push_back(std::make_unique&lt;Resource&gt;());
    auto ptr = threadBufferResources.back().get();
    return <a href="../Introduction/Using_and_Understanding_the_Code.html#Allocator" class="code">Allocator</a>(ptr);
});</div><p>


</p>
<p>If the HLBVH construction algorithm has been selected, <tt>buildHLBVH()</tt>
is called to build the tree. The other three construction algorithms are
all handled by <tt>buildRecursive()</tt>.  The initial calls to these
functions are passed all the primitives to be stored.  Each returns a
pointer to the root of a BVH for the primitives they are given, which is
represented with the <a href="#BVHBuildNode"><tt>BVHBuildNode</tt></a> structure and the total number of nodes
created, which is stored in <tt>totalNodes</tt>.  This value is represented
by a <tt>std::atomic</tt> variable so that it can be modified correctly by
multiple threads executing in parallel.

</p>
<p></p>
<span class="anchor" id="fragment-BuildBVHaccordingtoselectedmonosplitMethod-0"></span><div class="fragmentname">&lt;&lt;Build BVH according to selected <tt>splitMethod</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::atomic&lt;int&gt; totalNodes{0};
if (<a href="#BVHAggregate::splitMethod" class="code">splitMethod</a> == <a href="#SplitMethod::HLBVH" class="code">SplitMethod</a>::HLBVH) {
    root = <a href="#BVHAggregate::buildHLBVH" class="code">buildHLBVH</a>(alloc, bvhPrimitives, &amp;totalNodes, orderedPrims);
} else {
    std::atomic&lt;int&gt; orderedPrimsOffset{0};
    root = <a href="#BVHAggregate::buildRecursive" class="code">buildRecursive</a>(threadAllocators,
                          pstd::span&lt;BVHPrimitive&gt;(bvhPrimitives),
                          &amp;totalNodes, &amp;orderedPrimsOffset, orderedPrims);
}
<a href="#BVHAggregate::primitives" class="code">primitives</a>.swap(orderedPrims);</div><p>


</p>
<p>Each <a href="#BVHBuildNode"><tt>BVHBuildNode</tt></a> represents a node of the BVH.  All nodes store a
<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f"><tt>Bounds3f</tt></a> that represents the bounds of all the children beneath the
node.  Each interior node stores pointers to its two children in
<tt>children</tt>.  Interior nodes also record the coordinate axis along
which primitives were partitioned for distribution to their two children; this
information is used to improve the performance of the traversal
algorithm.  Leaf nodes record which primitive or primitives are
stored in them; the elements of the <a href="#BVHAggregate::primitives"><tt>BVHAggregate::primitives</tt></a> array
from the offset <tt>firstPrimOffset</tt> up to but not including
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="34.574ex" height="2.176ex" style="vertical-align: -0.505ex;" viewBox="0 -719.6 14885.9 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">monospace f monospace i monospace r monospace s monospace t monospace upper P monospace r monospace i monospace m monospace upper O monospace f monospace f monospace s monospace e monospace t plus monospace n monospace upper P monospace r monospace i monospace m monospace i monospace t monospace i monospace v monospace e monospace s</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMONOSPACE-1D68F" d="M437 557c0 -28 -23 -44 -43 -44c-35 0 -44 39 -44 43c-30 0 -97 0 -97 -78v-47h122c16 0 40 0 40 -31c0 -30 -25 -30 -40 -30h-122v-309h101c15 0 41 0 41 -31c0 -30 -26 -30 -41 -30h-271c-15 0 -41 0 -41 31c0 30 26 30 41 30h101v309h-101c-15 0 -40 0 -40 30 c0 31 25 31 41 31h100v53c0 87 77 133 157 133c16 0 96 0 96 -60Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMONOSPACE-1D692" d="M455 30c0 -30 -26 -30 -41 -30h-295c-15 0 -41 0 -41 30c0 31 25 31 41 31h121v309h-113c-15 0 -41 0 -41 31c0 30 26 30 41 30h142c34 0 40 -10 40 -41v-329h105c15 0 41 0 41 -31zM313 555c0 -28 -22 -50 -50 -50s-50 22 -50 50s22 50 50 50s50 -22 50 -50Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMONOSPACE-1D69B" d="M487 375c0 -27 -20 -43 -42 -43c-25 0 -42 20 -43 44c-121 0 -180 -96 -180 -190v-125h111c15 0 41 0 41 -31c0 -30 -26 -30 -41 -30h-261c-16 0 -40 0 -40 31c0 30 25 30 40 30h81v309h-81c-16 0 -40 0 -40 31c0 30 25 30 40 30h110c34 0 40 -10 40 -41v-34 c55 63 119 81 170 81c83 0 95 -42 95 -62Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMONOSPACE-1D69C" d="M459 125c0 -48 -32 -131 -190 -131c-28 0 -81 2 -130 38c-12 -37 -28 -38 -37 -38c-30 0 -30 25 -30 41v97c0 20 0 41 35 41c26 0 30 -11 35 -29c25 -78 81 -89 128 -89c91 0 128 33 128 70c0 53 -80 66 -129 74c-92 14 -197 31 -197 123c0 36 23 118 190 118 c19 0 63 0 107 -21c2 7 6 21 30 21c30 0 30 -25 30 -41v-69c0 -20 0 -41 -35 -41c-31 0 -33 17 -34 34c-3 26 -17 56 -100 56c-95 0 -127 -31 -127 -57c0 -39 68 -51 97 -55l68 -12c32 -5 161 -26 161 -130Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMONOSPACE-1D69D" d="M449 126c0 -89 -81 -132 -155 -132c-73 0 -141 36 -141 132v244h-88c-15 0 -40 0 -40 30c0 31 25 31 41 31h87v82c0 20 0 41 35 41c34 0 34 -22 34 -41v-82h164c16 0 40 0 40 -31c0 -30 -25 -30 -40 -30h-164v-238c0 -25 0 -77 77 -77c23 0 80 10 81 72c0 17 1 38 34 38 c35 0 35 -21 35 -39Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMONOSPACE-1D67F" d="M480 428c0 -93 -73 -183 -189 -183h-125v-184h30c15 0 41 0 41 -31c0 -30 -26 -30 -41 -30h-129c-15 0 -41 0 -41 30c0 31 25 31 41 31h30v489h-30c-15 0 -41 0 -41 31c0 30 26 30 41 30h224c115 0 189 -90 189 -183zM411 428c0 53 -43 122 -139 122h-106v-244h106 c96 0 139 69 139 122Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMONOSPACE-1D696" d="M516 30c0 -30 -26 -30 -41 -30h-75c-14 0 -41 0 -41 30c0 31 25 31 44 31v233c0 65 -14 82 -37 82c-41 0 -82 -47 -82 -136v-179c36 0 57 0 57 -31c0 -30 -26 -30 -41 -30h-75c-14 0 -41 0 -41 30c0 31 25 31 44 31v233c0 65 -14 82 -37 82c-41 0 -82 -47 -82 -136v-179 c36 0 57 0 57 -31c0 -30 -26 -30 -41 -30h-88c-14 0 -41 0 -41 30c0 31 21 31 57 31v309c-36 0 -57 0 -57 31c0 30 26 30 41 30h32c18 0 38 0 40 -30c24 22 54 36 86 36c33 0 61 -18 76 -52c28 39 69 52 99 52c89 0 89 -114 89 -134v-242c36 0 57 0 57 -31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMONOSPACE-1D67E" d="M468 305c0 -289 -22 -316 -206 -316c-185 0 -206 27 -206 316c0 290 21 317 206 317s206 -28 206 -317zM399 314c0 61 0 136 -12 183c-15 55 -50 64 -125 64c-82 0 -113 -12 -126 -71c-11 -46 -11 -114 -11 -176c0 -55 0 -142 12 -193c12 -50 37 -71 125 -71 c89 0 115 21 126 77c11 54 11 125 11 187Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMONOSPACE-1D68E" d="M464 109c0 -25 -47 -115 -179 -115c-129 0 -230 101 -230 223c0 123 96 223 215 223c130 0 194 -98 194 -212c0 -37 -19 -37 -40 -37h-298c16 -86 91 -136 166 -136c28 0 82 9 104 60c7 19 15 22 33 22c6 0 35 0 35 -28zM393 251c-9 103 -71 128 -123 128 c-70 0 -129 -55 -143 -128h266Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2B" d="M722 250c0 -11 -9 -20 -20 -20h-293v-293c0 -11 -9 -20 -20 -20s-20 9 -20 20v293h-293c-11 0 -20 9 -20 20s9 20 20 20h293v293c0 11 9 20 20 20s20 -9 20 -20v-293h293c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMONOSPACE-1D697" d="M512 30c0 -30 -26 -30 -40 -30h-153c-14 0 -41 0 -41 30c0 31 25 31 41 31h39v227c0 60 -14 88 -67 88c-51 0 -125 -38 -125 -138v-177h44c16 0 41 0 41 -31c0 -30 -26 -30 -40 -30h-159c-14 0 -40 0 -40 30c0 31 25 31 41 31h44v309h-45c-14 0 -40 0 -40 30 c0 31 25 31 41 31h73c40 0 40 -15 40 -47c19 19 64 53 131 53c79 0 130 -43 130 -144v-232h44c16 0 41 0 41 -31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMONOSPACE-1D69F" d="M500 400c0 -30 -25 -30 -40 -30h-30l-115 -341c-11 -33 -34 -33 -53 -33c-21 0 -41 0 -53 34l-115 340h-30c-15 0 -40 0 -40 30c0 31 24 31 40 31h117c16 0 40 0 40 -31c0 -30 -25 -30 -40 -30h-28l109 -322l109 322h-28c-16 0 -40 0 -40 31c0 30 25 30 40 30h117 c16 0 40 0 40 -31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D68F" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D692" x="525" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D69B" x="1051" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D69C" x="1576" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D69D" x="2102" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D67F" x="2627" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D69B" x="3153" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D692" x="3678" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D696" x="4204" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D67E" x="4729" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D68F" x="5255" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D68F" x="5780" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D69C" x="6306" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D68E" x="6831" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D69D" x="7357" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2B" x="8104" y="0"></use>
<g transform="translate(9105,0)">
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D697" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D67F" x="525" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D69B" x="1051" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D692" x="1576" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D696" x="2102" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D692" x="2627" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D69D" x="3153" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D692" x="3678" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D69F" x="4204" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D68E" x="4729" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D69C" x="5255" y="0"></use>
</g>
</g>
</svg> are the primitives in the
leaf.  (This is why the primitives array needs to
be reordered&mdash;so that this representation can be
used, rather than, for example, storing a variable-sized array of primitive
indices at each leaf node.)

</p>
<p></p>
<span class="anchor" id="fragment-BVHBuildNodeDefinition-0"></span><div class="fragmentname">&lt;&lt;BVHBuildNode Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">struct <span class="anchor" id="BVHBuildNode"></span>BVHBuildNode {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-BVHBuildNodePublicMethods-0">BVHBuildNode Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1002" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1002"><i></i></a><div id="fragbit-1002" class="collapse show"><div class="fragmentcode">       void InitLeaf(int first, int n, const <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> &amp;b) {
           <a href="#BVHBuildNode::firstPrimOffset" class="code">firstPrimOffset</a> = first;
           <a href="#BVHBuildNode::nPrimitives" class="code">nPrimitives</a> = n;
           <a href="#BVHBuildNode::bounds" class="code">bounds</a> = b;
           <a href="#BVHBuildNode::children" class="code">children</a>[0] = <a href="#BVHBuildNode::children" class="code">children</a>[1] = nullptr;
       }
       void InitInterior(int axis, BVHBuildNode *c0, BVHBuildNode *c1) {
           <a href="#BVHBuildNode::children" class="code">children</a>[0] = c0;
           <a href="#BVHBuildNode::children" class="code">children</a>[1] = c1;
           <a href="#BVHBuildNode::bounds" class="code">bounds</a> = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(c0-&gt;<a href="#BVHBuildNode::bounds" class="code">bounds</a>, c1-&gt;<a href="#BVHBuildNode::bounds" class="code">bounds</a>);
           <a href="#BVHBuildNode::splitAxis" class="code">splitAxis</a> = axis;
           <a href="#BVHBuildNode::nPrimitives" class="code">nPrimitives</a> = 0;
       }</div></div>
    <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> <span class="anchor" id="BVHBuildNode::bounds"></span>bounds;
    BVHBuildNode *<span class="anchor" id="BVHBuildNode::children"></span>children[2];
    int <span class="anchor" id="BVHBuildNode::splitAxis"></span>splitAxis, <span class="anchor" id="BVHBuildNode::firstPrimOffset"></span>firstPrimOffset, <span class="anchor" id="BVHBuildNode::nPrimitives"></span>nPrimitives;
};</div><p>


</p>
<p>We will distinguish between leaf and interior nodes by whether their
child pointers have the value <tt>nullptr</tt> or not, respectively.

</p>
<p></p>
<span class="anchor" id="fragment-BVHBuildNodePublicMethods-0"></span><div class="fragmentname">&lt;&lt;BVHBuildNode Public Methods&gt;&gt;=&nbsp;<a href="#fragment-BVHBuildNodePublicMethods-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">void <span class="anchor" id="BVHBuildNode::InitLeaf"></span>InitLeaf(int first, int n, const <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> &amp;b) {
    <a href="#BVHBuildNode::firstPrimOffset" class="code">firstPrimOffset</a> = first;
    <a href="#BVHBuildNode::nPrimitives" class="code">nPrimitives</a> = n;
    <a href="#BVHBuildNode::bounds" class="code">bounds</a> = b;
    <a href="#BVHBuildNode::children" class="code">children</a>[0] = <a href="#BVHBuildNode::children" class="code">children</a>[1] = nullptr;
}</div><p>


</p>
<p>The <tt>InitInterior()</tt> method requires that the two child nodes
already have been created, so that their pointers can be passed in.  This
requirement makes it easy to compute the bounds of the interior node, since
the children bounds are immediately available.
 
</p>
<span class="anchor" id="fragment-BVHBuildNodePublicMethods-1"></span><div class="fragmentname">&lt;&lt;BVHBuildNode Public Methods&gt;&gt;+=&nbsp;<a href="#fragment-BVHBuildNodePublicMethods-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">void <span class="anchor" id="BVHBuildNode::InitInterior"></span>InitInterior(int axis, BVHBuildNode *c0, BVHBuildNode *c1) {
    <a href="#BVHBuildNode::children" class="code">children</a>[0] = c0;
    <a href="#BVHBuildNode::children" class="code">children</a>[1] = c1;
    <a href="#BVHBuildNode::bounds" class="code">bounds</a> = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(c0-&gt;<a href="#BVHBuildNode::bounds" class="code">bounds</a>, c1-&gt;<a href="#BVHBuildNode::bounds" class="code">bounds</a>);
    <a href="#BVHBuildNode::splitAxis" class="code">splitAxis</a> = axis;
    <a href="#BVHBuildNode::nPrimitives" class="code">nPrimitives</a> = 0;
}</div><p>


</p>
<p>In addition to the allocators used for BVH nodes and the array
of <a href="#BVHPrimitive"><tt>BVHPrimitive</tt></a> structures, <tt>buildRecursive()</tt> takes a pointer
<tt>totalNodes</tt> that is used to track the total number of BVH nodes that have been
created; this value makes it possible to allocate exactly the right number of the more
compact <a href="#LinearBVHNode"><tt>LinearBVHNode</tt></a>s later.

</p>
<p>The <tt>orderedPrims</tt> array is used to store primitive references as
primitives are stored in leaf nodes of the tree.  It is initially
allocated with enough entries to store all the primitives, though all
entries are <tt>nullptr</tt>.  When a leaf node is created,
<tt>buildRecursive()</tt> claims enough entries in the array for its
primitives; <tt>orderedPrimsOffset</tt> starts at&nbsp;0 and keeps track of where
the next free entry is.  It, too, is an atomic variable so that multiple
threads can allocate space from the array concurrently.  Recall that when
tree construction is finished, <a href="#BVHAggregate::primitives"><tt>BVHAggregate::primitives</tt></a> is replaced
with the ordered primitives array created here.

</p>
<p></p>
<span class="anchor" id="fragment-BVHAggregateMethodDefinitions-1"></span><div class="fragmentname">&lt;&lt;BVHAggregate Method Definitions&gt;&gt;+=&nbsp;<a href="#fragment-BVHAggregateMethodDefinitions-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-BVHAggregateMethodDefinitions-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">BVHBuildNode *<span class="anchor" id="BVHAggregate::buildRecursive"></span>BVHAggregate::buildRecursive(
        <a href="../Utilities/Parallelism.html#ThreadLocal" class="code">ThreadLocal</a>&lt;<a href="../Introduction/Using_and_Understanding_the_Code.html#Allocator" class="code">Allocator</a>&gt; &amp;threadAllocators,
        pstd::span&lt;BVHPrimitive&gt; bvhPrimitives,
        std::atomic&lt;int&gt; *totalNodes, std::atomic&lt;int&gt; *orderedPrimsOffset,
        std::vector&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; &amp;orderedPrims) {
    <a href="../Introduction/Using_and_Understanding_the_Code.html#Allocator" class="code">Allocator</a> alloc = threadAllocators.<a href="../Utilities/Parallelism.html#ThreadLocal::Get" class="code">Get</a>();
    BVHBuildNode *node = alloc.<a href="../Introduction/Using_and_Understanding_the_Code.html#std::pmr::polymorphic_allocator::new_object" class="code">new_object</a>&lt;BVHBuildNode&gt;();
    &lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonoBVHBuildNodeforprimitiverange-0">Initialize <tt>BVHBuildNode</tt> for primitive range</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1003" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1003"><i></i></a><div id="fragbit-1003" class="collapse show"><div class="fragmentcode">       ++*totalNodes;
       &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputeboundsofallprimitivesinBVHnode-0">Compute bounds of all primitives in BVH node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1004" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1004"><i></i></a><div id="fragbit-1004" class="collapse show"><div class="fragmentcode">          <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> <a href="#BVHPrimitive::bounds" class="code">bounds</a>;
          for (const auto &amp;prim : bvhPrimitives)
              <a href="#BVHPrimitive::bounds" class="code">bounds</a> = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(<a href="#BVHPrimitive::bounds" class="code">bounds</a>, prim.<a href="#BVHPrimitive::bounds" class="code">bounds</a>);</div></div>
       if (bounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>() == 0 || bvhPrimitives.size() == 1) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-CreateleafmonoBVHBuildNode-0">Create leaf <tt>BVHBuildNode</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1005" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1005"><i></i></a><div id="fragbit-1005" class="collapse show"><div class="fragmentcode">              int firstPrimOffset = orderedPrimsOffset-&gt;fetch_add(bvhPrimitives.size());
              for (size_t i = 0; i &lt; bvhPrimitives.size(); ++i) {
                  int index = bvhPrimitives[i].<a href="#BVHPrimitive::primitiveIndex" class="code">primitiveIndex</a>;
                  orderedPrims[firstPrimOffset + i] = primitives[index];
              }
              node-&gt;<a href="#BVHBuildNode::InitLeaf" class="code">InitLeaf</a>(firstPrimOffset, bvhPrimitives.size(), bounds);
              return node;</div></div>
       } else {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Computeboundofprimitivecentroidsandchoosesplitdimensionmonodim-0">Compute bound of primitive centroids and choose split dimension <tt>dim</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1006" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1006"><i></i></a><div id="fragbit-1006" class="collapse show"><div class="fragmentcode">              <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> centroidBounds;
              for (const auto &amp;prim : bvhPrimitives)
                  centroidBounds = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(centroidBounds, prim.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>());
              int dim = centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::MaxDimension" class="code">MaxDimension</a>();</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Partitionprimitivesintotwosetsandbuildchildren-0">Partition primitives into two sets and build children</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1007" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1007"><i></i></a><div id="fragbit-1007" class="collapse show"><div class="fragmentcode">              if (centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[dim] == centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[dim]) {
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-CreateleafmonoBVHBuildNode-0">Create leaf <tt>BVHBuildNode</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1008" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1008"><i></i></a><div id="fragbit-1008" class="collapse show"><div class="fragmentcode">                     int firstPrimOffset = orderedPrimsOffset-&gt;fetch_add(bvhPrimitives.size());
                     for (size_t i = 0; i &lt; bvhPrimitives.size(); ++i) {
                         int index = bvhPrimitives[i].<a href="#BVHPrimitive::primitiveIndex" class="code">primitiveIndex</a>;
                         orderedPrims[firstPrimOffset + i] = primitives[index];
                     }
                     node-&gt;<a href="#BVHBuildNode::InitLeaf" class="code">InitLeaf</a>(firstPrimOffset, bvhPrimitives.size(), bounds);
                     return node;</div></div>
              } else {
                  int mid = bvhPrimitives.size() / 2;
                  &lt;&lt;<span class="fragmentname">Partition primitives based on <tt>splitMethod</tt></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1009" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1009"><i></i></a><div id="fragbit-1009" class="collapse show"><div class="fragmentcode">                     switch (splitMethod) {
                     case SplitMethod::Middle: {
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-Partitionprimitivesthroughnodesmidpoint-0">Partition primitives through node&rsquo;s midpoint</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1010" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1010"><i></i></a><div id="fragbit-1010" class="collapse show"><div class="fragmentcode">                            Float pmid = (centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[dim] + centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[dim]) / 2;
                            auto midIter =
                                std::partition(bvhPrimitives.begin(), bvhPrimitives.end(),
                                    [dim, pmid](const BVHPrimitive &amp;pi) {
                                        return pi.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim] &lt; pmid;
                                    });
                            mid = midIter - bvhPrimitives.begin();
                            if (midIter != bvhPrimitives.begin() &amp;&amp; midIter != bvhPrimitives.end())
                                break;</div></div>
                     }
                     case SplitMethod::EqualCounts: {
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-Partitionprimitivesintoequallysizedsubsets-0">Partition primitives into equally sized subsets</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1011" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1011"><i></i></a><div id="fragbit-1011" class="collapse show"><div class="fragmentcode">                            mid = bvhPrimitives.size() / 2;
                            std::nth_element(bvhPrimitives.begin(), bvhPrimitives.begin() + mid, 
                                             bvhPrimitives.end(),
                                [dim](const BVHPrimitive &amp;a, const BVHPrimitive &amp;b) { 
                                    return a.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim] &lt; b.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim];
                                });</div></div>
                         break;
                     }
                     case SplitMethod::SAH:
                     default: {
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-PartitionprimitivesusingapproximateSAH-0">Partition primitives using approximate SAH</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1012" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1012"><i></i></a><div id="fragbit-1012" class="collapse show"><div class="fragmentcode">                            if (bvhPrimitives.size() &lt;= 2) {
                                &lt;&lt;<span class="fragmentname"><a href="#fragment-Partitionprimitivesintoequallysizedsubsets-0">Partition primitives into equally sized subsets</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1013" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1013"><i></i></a><div id="fragbit-1013" class="collapse show"><div class="fragmentcode">                                   mid = bvhPrimitives.size() / 2;
                                   std::nth_element(bvhPrimitives.begin(), bvhPrimitives.begin() + mid, 
                                                    bvhPrimitives.end(),
                                       [dim](const BVHPrimitive &amp;a, const BVHPrimitive &amp;b) { 
                                           return a.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim] &lt; b.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim];
                                       });</div></div>
                            } else {
                                &lt;&lt;<span class="fragmentname"><a href="#fragment-AllocatemonoBVHSplitBucketforSAHpartitionbuckets-0">Allocate <tt>BVHSplitBucket</tt> for SAH partition buckets</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1014" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1014"><i></i></a><div id="fragbit-1014" class="collapse show"><div class="fragmentcode">                                   constexpr int nBuckets = 12;
                                   BVHSplitBucket buckets[nBuckets];</div></div>
                                &lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonoBVHSplitBucketforSAHpartitionbuckets-0">Initialize <tt>BVHSplitBucket</tt> for SAH partition buckets</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1015" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1015"><i></i></a><div id="fragbit-1015" class="collapse show"><div class="fragmentcode">                                   for (const auto &amp;prim : bvhPrimitives) {
                                       int b = nBuckets * centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Offset" class="code">Offset</a>(prim.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>())[dim];
                                       if (b == nBuckets) b = nBuckets - 1;
                                       buckets[b].<a href="#BVHSplitBucket::count" class="code">count</a>++;
                                       buckets[b].<a href="#BVHPrimitive::bounds" class="code">bounds</a> = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(buckets[b].<a href="#BVHPrimitive::bounds" class="code">bounds</a>, prim.<a href="#BVHPrimitive::bounds" class="code">bounds</a>);
                                   }</div></div>
                                &lt;&lt;<span class="fragmentname"><a href="#fragment-Computecostsforsplittingaftereachbucket-0">Compute costs for splitting after each bucket</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1016" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1016"><i></i></a><div id="fragbit-1016" class="collapse show"><div class="fragmentcode">                                   constexpr int nSplits = nBuckets - 1;
                                   Float costs[nSplits] = {};
                                   &lt;&lt;<span class="fragmentname"><a href="#fragment-Partiallyinitializemonocostsusingaforwardscanoversplits-0">Partially initialize <tt>costs</tt> using a forward scan over splits</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1017" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1017"><i></i></a><div id="fragbit-1017" class="collapse show"><div class="fragmentcode">                                      int countBelow = 0;
                                      <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> boundBelow;
                                      for (int i = 0; i &lt; nSplits; ++i) {
                                          boundBelow = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(boundBelow, buckets[i].bounds);
                                          countBelow += buckets[i].count;
                                          costs[i] += countBelow * boundBelow.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();
                                      }</div></div>
                                   &lt;&lt;<span class="fragmentname"><a href="#fragment-Finishinitializingmonocostsusingabackwardscanoversplits-0">Finish initializing <tt>costs</tt> using a backward scan over splits</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1018" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1018"><i></i></a><div id="fragbit-1018" class="collapse show"><div class="fragmentcode">                                      int countAbove = 0;
                                      <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> boundAbove;
                                      for (int i = nSplits; i &gt;= 1; --i) {
                                          boundAbove = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(boundAbove, buckets[i].bounds);
                                          countAbove += buckets[i].count;
                                          costs[i - 1] += countAbove * boundAbove.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();
                                      }</div></div></div></div>
                                &lt;&lt;<span class="fragmentname"><a href="#fragment-FindbuckettosplitatthatminimizesSAHmetric-0">Find bucket to split at that minimizes SAH metric</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1019" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1019"><i></i></a><div id="fragbit-1019" class="collapse show"><div class="fragmentcode">                                   int minCostSplitBucket = -1;
                                   Float minCost = Infinity;
                                   for (int i = 0; i &lt; nSplits; ++i) {
                                       &lt;&lt;<span class="fragmentname"><a href="#fragment-Computecostforcandidatesplitandupdateminimumifnecessary-0">Compute cost for candidate split and update minimum if necessary</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1020" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1020"><i></i></a><div id="fragbit-1020" class="collapse show"><div class="fragmentcode">                                          if (costs[i] &lt; minCost) {
                                              minCost = costs[i];
                                              minCostSplitBucket = i;
                                          }</div></div>
                                   }
                                   &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputeleafcostandSAHsplitcostforchosensplit-0">Compute leaf cost and SAH split cost for chosen split</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1021" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1021"><i></i></a><div id="fragbit-1021" class="collapse show"><div class="fragmentcode">                                      Float leafCost = bvhPrimitives.size();
                                      minCost = 1.f / 2.f + minCost / bounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();</div></div></div></div>
                                &lt;&lt;<span class="fragmentname"><a href="#fragment-EithercreateleaforsplitprimitivesatselectedSAHbucket-0">Either create leaf or split primitives at selected SAH bucket</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1022" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1022"><i></i></a><div id="fragbit-1022" class="collapse show"><div class="fragmentcode">                                   if (bvhPrimitives.size() &gt; <a href="#BVHAggregate::maxPrimsInNode" class="code">maxPrimsInNode</a> || minCost &lt; leafCost) {
                                       auto midIter = std::partition(bvhPrimitives.begin(),
                                           bvhPrimitives.end(),
                                           [=](const BVHPrimitive &amp;bp) {
                                               int b = nBuckets * centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Offset" class="code">Offset</a>(bp.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>())[dim];
                                               if (b == nBuckets) b = nBuckets - 1;
                                               return b &lt;= minCostSplitBucket;
                                           });
                                       mid = midIter - bvhPrimitives.begin();
                                   } else {
                                       &lt;&lt;<span class="fragmentname"><a href="#fragment-CreateleafmonoBVHBuildNode-0">Create leaf <tt>BVHBuildNode</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1023" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1023"><i></i></a><div id="fragbit-1023" class="collapse show"><div class="fragmentcode">                                          int firstPrimOffset = orderedPrimsOffset-&gt;fetch_add(bvhPrimitives.size());
                                          for (size_t i = 0; i &lt; bvhPrimitives.size(); ++i) {
                                              int index = bvhPrimitives[i].<a href="#BVHPrimitive::primitiveIndex" class="code">primitiveIndex</a>;
                                              orderedPrims[firstPrimOffset + i] = primitives[index];
                                          }
                                          node-&gt;<a href="#BVHBuildNode::InitLeaf" class="code">InitLeaf</a>(firstPrimOffset, bvhPrimitives.size(), bounds);
                                          return node;</div></div>
                                   }</div></div>
                            }</div></div>
                         break;
                     }
                     }</div></div>
                  BVHBuildNode *children[2];
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-RecursivelybuildBVHsformonochildren-0">Recursively build BVHs for <tt>children</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1024" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1024"><i></i></a><div id="fragbit-1024" class="collapse show"><div class="fragmentcode">                     if (bvhPrimitives.size() &gt; 128 * 1024) {
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-RecursivelybuildchildBVHsinparallel-0">Recursively build child BVHs in parallel</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1025" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1025"><i></i></a><div id="fragbit-1025" class="collapse show"><div class="fragmentcode">                            <a href="../Utilities/Parallelism.html#ParallelFor" class="code">ParallelFor</a>(0, 2, [&amp;](int i) {
                                if (i == 0)
                                    children[0] =
                                        <a href="#BVHAggregate::buildRecursive" class="code">buildRecursive</a>(threadAllocators, bvhPrimitives.subspan(0, mid),
                                                       totalNodes, orderedPrimsOffset, orderedPrims);
                                else
                                    children[1] =
                                        <a href="#BVHAggregate::buildRecursive" class="code">buildRecursive</a>(threadAllocators, bvhPrimitives.subspan(mid),
                                                       totalNodes, orderedPrimsOffset, orderedPrims);
                            });</div></div>
                     } else {
                         &lt;&lt;<span class="fragmentname">Recursively build child BVHs sequentially</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1026" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1026"><i></i></a><div id="fragbit-1026" class="collapse show"><div class="fragmentcode">                            children[0] =
                                buildRecursive(threadAllocators, bvhPrimitives.subspan(0, mid),
                                               totalNodes, orderedPrimsOffset, orderedPrims);
                            children[1] =
                                buildRecursive(threadAllocators, bvhPrimitives.subspan(mid),
                                               totalNodes, orderedPrimsOffset, orderedPrims);</div></div>
                     }</div></div>
                  node-&gt;<a href="#BVHBuildNode::InitInterior" class="code">InitInterior</a>(dim, children[0], children[1]);
              }</div></div>
       }</div></div>
    return node;
}</div><p>


</p>
<p>If <tt>bvhPrimitives</tt> has only a single primitive,
then the recursion has bottomed out and a leaf node is created.  Otherwise,
this method partitions its elements using one of
the partitioning algorithms and reorders the array elements so that they
represent the partitioned subsets.  If the
partitioning is successful, these two primitive sets are in turn passed to
recursive calls that will themselves return pointers to nodes for the two
children of the current node.

</p>
<p></p>
<span class="anchor" id="fragment-InitializemonoBVHBuildNodeforprimitiverange-0"></span><div class="fragmentname">&lt;&lt;Initialize <tt>BVHBuildNode</tt> for primitive range&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">++*totalNodes;
&lt;&lt;<span class="fragmentname"><a href="#fragment-ComputeboundsofallprimitivesinBVHnode-0">Compute bounds of all primitives in BVH node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1027" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1027"><i></i></a><div id="fragbit-1027" class="collapse show"><div class="fragmentcode">   <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> <a href="#BVHPrimitive::bounds" class="code">bounds</a>;
   for (const auto &amp;prim : bvhPrimitives)
       <a href="#BVHPrimitive::bounds" class="code">bounds</a> = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(<a href="#BVHPrimitive::bounds" class="code">bounds</a>, prim.<a href="#BVHPrimitive::bounds" class="code">bounds</a>);</div></div>
if (bounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>() == 0 || bvhPrimitives.size() == 1) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-CreateleafmonoBVHBuildNode-0">Create leaf <tt>BVHBuildNode</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1028" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1028"><i></i></a><div id="fragbit-1028" class="collapse show"><div class="fragmentcode">       int firstPrimOffset = orderedPrimsOffset-&gt;fetch_add(bvhPrimitives.size());
       for (size_t i = 0; i &lt; bvhPrimitives.size(); ++i) {
           int index = bvhPrimitives[i].<a href="#BVHPrimitive::primitiveIndex" class="code">primitiveIndex</a>;
           orderedPrims[firstPrimOffset + i] = primitives[index];
       }
       node-&gt;<a href="#BVHBuildNode::InitLeaf" class="code">InitLeaf</a>(firstPrimOffset, bvhPrimitives.size(), bounds);
       return node;</div></div>
} else {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Computeboundofprimitivecentroidsandchoosesplitdimensionmonodim-0">Compute bound of primitive centroids and choose split dimension <tt>dim</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1029" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1029"><i></i></a><div id="fragbit-1029" class="collapse show"><div class="fragmentcode">       <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> centroidBounds;
       for (const auto &amp;prim : bvhPrimitives)
           centroidBounds = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(centroidBounds, prim.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>());
       int dim = centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::MaxDimension" class="code">MaxDimension</a>();</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Partitionprimitivesintotwosetsandbuildchildren-0">Partition primitives into two sets and build children</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1030" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1030"><i></i></a><div id="fragbit-1030" class="collapse show"><div class="fragmentcode">       if (centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[dim] == centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[dim]) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-CreateleafmonoBVHBuildNode-0">Create leaf <tt>BVHBuildNode</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1031" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1031"><i></i></a><div id="fragbit-1031" class="collapse show"><div class="fragmentcode">              int firstPrimOffset = orderedPrimsOffset-&gt;fetch_add(bvhPrimitives.size());
              for (size_t i = 0; i &lt; bvhPrimitives.size(); ++i) {
                  int index = bvhPrimitives[i].<a href="#BVHPrimitive::primitiveIndex" class="code">primitiveIndex</a>;
                  orderedPrims[firstPrimOffset + i] = primitives[index];
              }
              node-&gt;<a href="#BVHBuildNode::InitLeaf" class="code">InitLeaf</a>(firstPrimOffset, bvhPrimitives.size(), bounds);
              return node;</div></div>
       } else {
           int mid = bvhPrimitives.size() / 2;
           &lt;&lt;<span class="fragmentname">Partition primitives based on <tt>splitMethod</tt></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1032" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1032"><i></i></a><div id="fragbit-1032" class="collapse show"><div class="fragmentcode">              switch (splitMethod) {
              case SplitMethod::Middle: {
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Partitionprimitivesthroughnodesmidpoint-0">Partition primitives through node&rsquo;s midpoint</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1033" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1033"><i></i></a><div id="fragbit-1033" class="collapse show"><div class="fragmentcode">                     Float pmid = (centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[dim] + centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[dim]) / 2;
                     auto midIter =
                         std::partition(bvhPrimitives.begin(), bvhPrimitives.end(),
                             [dim, pmid](const BVHPrimitive &amp;pi) {
                                 return pi.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim] &lt; pmid;
                             });
                     mid = midIter - bvhPrimitives.begin();
                     if (midIter != bvhPrimitives.begin() &amp;&amp; midIter != bvhPrimitives.end())
                         break;</div></div>
              }
              case SplitMethod::EqualCounts: {
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Partitionprimitivesintoequallysizedsubsets-0">Partition primitives into equally sized subsets</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1034" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1034"><i></i></a><div id="fragbit-1034" class="collapse show"><div class="fragmentcode">                     mid = bvhPrimitives.size() / 2;
                     std::nth_element(bvhPrimitives.begin(), bvhPrimitives.begin() + mid, 
                                      bvhPrimitives.end(),
                         [dim](const BVHPrimitive &amp;a, const BVHPrimitive &amp;b) { 
                             return a.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim] &lt; b.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim];
                         });</div></div>
                  break;
              }
              case SplitMethod::SAH:
              default: {
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-PartitionprimitivesusingapproximateSAH-0">Partition primitives using approximate SAH</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1035" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1035"><i></i></a><div id="fragbit-1035" class="collapse show"><div class="fragmentcode">                     if (bvhPrimitives.size() &lt;= 2) {
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-Partitionprimitivesintoequallysizedsubsets-0">Partition primitives into equally sized subsets</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1036" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1036"><i></i></a><div id="fragbit-1036" class="collapse show"><div class="fragmentcode">                            mid = bvhPrimitives.size() / 2;
                            std::nth_element(bvhPrimitives.begin(), bvhPrimitives.begin() + mid, 
                                             bvhPrimitives.end(),
                                [dim](const BVHPrimitive &amp;a, const BVHPrimitive &amp;b) { 
                                    return a.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim] &lt; b.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim];
                                });</div></div>
                     } else {
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-AllocatemonoBVHSplitBucketforSAHpartitionbuckets-0">Allocate <tt>BVHSplitBucket</tt> for SAH partition buckets</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1037" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1037"><i></i></a><div id="fragbit-1037" class="collapse show"><div class="fragmentcode">                            constexpr int nBuckets = 12;
                            BVHSplitBucket buckets[nBuckets];</div></div>
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonoBVHSplitBucketforSAHpartitionbuckets-0">Initialize <tt>BVHSplitBucket</tt> for SAH partition buckets</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1038" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1038"><i></i></a><div id="fragbit-1038" class="collapse show"><div class="fragmentcode">                            for (const auto &amp;prim : bvhPrimitives) {
                                int b = nBuckets * centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Offset" class="code">Offset</a>(prim.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>())[dim];
                                if (b == nBuckets) b = nBuckets - 1;
                                buckets[b].<a href="#BVHSplitBucket::count" class="code">count</a>++;
                                buckets[b].<a href="#BVHPrimitive::bounds" class="code">bounds</a> = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(buckets[b].<a href="#BVHPrimitive::bounds" class="code">bounds</a>, prim.<a href="#BVHPrimitive::bounds" class="code">bounds</a>);
                            }</div></div>
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-Computecostsforsplittingaftereachbucket-0">Compute costs for splitting after each bucket</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1039" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1039"><i></i></a><div id="fragbit-1039" class="collapse show"><div class="fragmentcode">                            constexpr int nSplits = nBuckets - 1;
                            Float costs[nSplits] = {};
                            &lt;&lt;<span class="fragmentname"><a href="#fragment-Partiallyinitializemonocostsusingaforwardscanoversplits-0">Partially initialize <tt>costs</tt> using a forward scan over splits</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1040" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1040"><i></i></a><div id="fragbit-1040" class="collapse show"><div class="fragmentcode">                               int countBelow = 0;
                               <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> boundBelow;
                               for (int i = 0; i &lt; nSplits; ++i) {
                                   boundBelow = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(boundBelow, buckets[i].bounds);
                                   countBelow += buckets[i].count;
                                   costs[i] += countBelow * boundBelow.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();
                               }</div></div>
                            &lt;&lt;<span class="fragmentname"><a href="#fragment-Finishinitializingmonocostsusingabackwardscanoversplits-0">Finish initializing <tt>costs</tt> using a backward scan over splits</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1041" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1041"><i></i></a><div id="fragbit-1041" class="collapse show"><div class="fragmentcode">                               int countAbove = 0;
                               <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> boundAbove;
                               for (int i = nSplits; i &gt;= 1; --i) {
                                   boundAbove = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(boundAbove, buckets[i].bounds);
                                   countAbove += buckets[i].count;
                                   costs[i - 1] += countAbove * boundAbove.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();
                               }</div></div></div></div>
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-FindbuckettosplitatthatminimizesSAHmetric-0">Find bucket to split at that minimizes SAH metric</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1042" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1042"><i></i></a><div id="fragbit-1042" class="collapse show"><div class="fragmentcode">                            int minCostSplitBucket = -1;
                            Float minCost = Infinity;
                            for (int i = 0; i &lt; nSplits; ++i) {
                                &lt;&lt;<span class="fragmentname"><a href="#fragment-Computecostforcandidatesplitandupdateminimumifnecessary-0">Compute cost for candidate split and update minimum if necessary</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1043" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1043"><i></i></a><div id="fragbit-1043" class="collapse show"><div class="fragmentcode">                                   if (costs[i] &lt; minCost) {
                                       minCost = costs[i];
                                       minCostSplitBucket = i;
                                   }</div></div>
                            }
                            &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputeleafcostandSAHsplitcostforchosensplit-0">Compute leaf cost and SAH split cost for chosen split</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1044" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1044"><i></i></a><div id="fragbit-1044" class="collapse show"><div class="fragmentcode">                               Float leafCost = bvhPrimitives.size();
                               minCost = 1.f / 2.f + minCost / bounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();</div></div></div></div>
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-EithercreateleaforsplitprimitivesatselectedSAHbucket-0">Either create leaf or split primitives at selected SAH bucket</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1045" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1045"><i></i></a><div id="fragbit-1045" class="collapse show"><div class="fragmentcode">                            if (bvhPrimitives.size() &gt; <a href="#BVHAggregate::maxPrimsInNode" class="code">maxPrimsInNode</a> || minCost &lt; leafCost) {
                                auto midIter = std::partition(bvhPrimitives.begin(),
                                    bvhPrimitives.end(),
                                    [=](const BVHPrimitive &amp;bp) {
                                        int b = nBuckets * centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Offset" class="code">Offset</a>(bp.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>())[dim];
                                        if (b == nBuckets) b = nBuckets - 1;
                                        return b &lt;= minCostSplitBucket;
                                    });
                                mid = midIter - bvhPrimitives.begin();
                            } else {
                                &lt;&lt;<span class="fragmentname"><a href="#fragment-CreateleafmonoBVHBuildNode-0">Create leaf <tt>BVHBuildNode</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1046" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1046"><i></i></a><div id="fragbit-1046" class="collapse show"><div class="fragmentcode">                                   int firstPrimOffset = orderedPrimsOffset-&gt;fetch_add(bvhPrimitives.size());
                                   for (size_t i = 0; i &lt; bvhPrimitives.size(); ++i) {
                                       int index = bvhPrimitives[i].<a href="#BVHPrimitive::primitiveIndex" class="code">primitiveIndex</a>;
                                       orderedPrims[firstPrimOffset + i] = primitives[index];
                                   }
                                   node-&gt;<a href="#BVHBuildNode::InitLeaf" class="code">InitLeaf</a>(firstPrimOffset, bvhPrimitives.size(), bounds);
                                   return node;</div></div>
                            }</div></div>
                     }</div></div>
                  break;
              }
              }</div></div>
           BVHBuildNode *children[2];
           &lt;&lt;<span class="fragmentname"><a href="#fragment-RecursivelybuildBVHsformonochildren-0">Recursively build BVHs for <tt>children</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1047" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1047"><i></i></a><div id="fragbit-1047" class="collapse show"><div class="fragmentcode">              if (bvhPrimitives.size() &gt; 128 * 1024) {
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-RecursivelybuildchildBVHsinparallel-0">Recursively build child BVHs in parallel</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1048" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1048"><i></i></a><div id="fragbit-1048" class="collapse show"><div class="fragmentcode">                     <a href="../Utilities/Parallelism.html#ParallelFor" class="code">ParallelFor</a>(0, 2, [&amp;](int i) {
                         if (i == 0)
                             children[0] =
                                 <a href="#BVHAggregate::buildRecursive" class="code">buildRecursive</a>(threadAllocators, bvhPrimitives.subspan(0, mid),
                                                totalNodes, orderedPrimsOffset, orderedPrims);
                         else
                             children[1] =
                                 <a href="#BVHAggregate::buildRecursive" class="code">buildRecursive</a>(threadAllocators, bvhPrimitives.subspan(mid),
                                                totalNodes, orderedPrimsOffset, orderedPrims);
                     });</div></div>
              } else {
                  &lt;&lt;<span class="fragmentname">Recursively build child BVHs sequentially</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1049" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1049"><i></i></a><div id="fragbit-1049" class="collapse show"><div class="fragmentcode">                     children[0] =
                         buildRecursive(threadAllocators, bvhPrimitives.subspan(0, mid),
                                        totalNodes, orderedPrimsOffset, orderedPrims);
                     children[1] =
                         buildRecursive(threadAllocators, bvhPrimitives.subspan(mid),
                                        totalNodes, orderedPrimsOffset, orderedPrims);</div></div>
              }</div></div>
           node-&gt;<a href="#BVHBuildNode::InitInterior" class="code">InitInterior</a>(dim, children[0], children[1]);
       }</div></div>
}</div><p>


</p>
<p>The primitive bounds will be needed regardless of whether an interior or
leaf node is created, so they are computed before that determination is made.

</p>
<p></p>
<span class="anchor" id="fragment-ComputeboundsofallprimitivesinBVHnode-0"></span><div class="fragmentname">&lt;&lt;Compute bounds of all primitives in BVH node&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> <a href="#BVHPrimitive::bounds" class="code">bounds</a>;
for (const auto &amp;prim : bvhPrimitives)
    <a href="#BVHPrimitive::bounds" class="code">bounds</a> = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(<a href="#BVHPrimitive::bounds" class="code">bounds</a>, prim.<a href="#BVHPrimitive::bounds" class="code">bounds</a>);</div><p>


</p>
<p>At leaf nodes, the primitives overlapping the leaf are appended to the
<tt>orderedPrims</tt> array and a leaf node object is initialized.  Because
<tt>orderedPrimsOffset</tt> is a <tt>std::atomic</tt> variable and
<tt>fetch_add()</tt> is an atomic operation, multiple threads can safely
perform this operation concurrently without further synchronization: each
one is able to allocate its own span of the <tt>orderedPrimitives</tt>
array that it can then safely write to.

</p>
<p></p>
<span class="anchor" id="fragment-CreateleafmonoBVHBuildNode-0"></span><div class="fragmentname">&lt;&lt;Create leaf <tt>BVHBuildNode</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int firstPrimOffset = orderedPrimsOffset-&gt;fetch_add(bvhPrimitives.size());
for (size_t i = 0; i &lt; bvhPrimitives.size(); ++i) {
    int index = bvhPrimitives[i].<a href="#BVHPrimitive::primitiveIndex" class="code">primitiveIndex</a>;
    orderedPrims[firstPrimOffset + i] = primitives[index];
}
node-&gt;<a href="#BVHBuildNode::InitLeaf" class="code">InitLeaf</a>(firstPrimOffset, bvhPrimitives.size(), bounds);
return node;</div><p>


</p>
<p>For interior nodes, the collection of primitives must be partitioned
between the two children&rsquo;s subtrees.  Given <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 600.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
</g>
</svg> primitives, there are in
general <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.484ex" height="2.843ex" style="vertical-align: -0.505ex;" viewBox="0 -1006.6 3653 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">2 Superscript n minus 1 Baseline minus 2</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2212" d="M722 250c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="0" y="0"></use>
<g transform="translate(500,393)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-2212" x="600" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="1379" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2212" x="2151" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="3152" y="0"></use>
</g>
</svg> possible ways to partition them into two non-empty
groups.  In practice when building BVHs, one generally considers partitions
along a coordinate axis, meaning that there are about <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.557ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 1101 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">3 n</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-33" d="M457 171c0 -102 -91 -193 -213 -193c-109 0 -202 66 -202 157c0 44 32 58 56 58c29 0 56 -20 56 -56c0 -38 -31 -60 -66 -55c35 -59 110 -76 153 -76c44 0 113 29 113 165c0 98 -37 166 -119 166h-44c-17 0 -24 0 -24 11c0 10 7 11 15 12c7 0 31 2 39 3c25 1 59 4 89 52 c26 44 28 102 28 114c0 90 -55 112 -96 112c-36 0 -102 -13 -133 -62c15 0 62 0 62 -50c0 -29 -20 -51 -51 -51c-29 0 -51 19 -51 52c0 76 76 136 177 136c96 0 184 -56 184 -138c0 -79 -58 -149 -140 -176c104 -21 167 -99 167 -181Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-33" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="500" y="0"></use>
</g>
</svg> candidate
partitions.  (Along each axis, each primitive may be put into the first
partition or the second partition.)

</p>
<p>Here, we choose just one of the three coordinate axes to use in
partitioning the primitives.  We select the axis with the
largest extent of bounding box centroids for the primitives in
<tt>bvhPrimitives</tt>.
(An alternative would be to try
partitioning the primitives along all three axes and
select the one that gave the best result, but in practice this approach
works well.)  This approach gives good partitions in many scenes;
Figure&nbsp;<a href="#fig:bvh-centroid-axis">7.4</a> illustrates the strategy.

</p>
<p></p>
<span class="anchor" id="fig:bvh-centroid-axis"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="pha07f04.svg" title=""><img src="pha07f04.svg" width=362 height=371 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 7.4: Choosing the Axis along which to Partition Primitives. <span class="legend"> 
The <tt>BVHAggregate</tt> chooses an axis along which to partition the primitives
based on which axis has the largest range of the centroids of the
primitives&rsquo; bounding boxes.  Here, in two
dimensions, their extent is largest along the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg> axis (filled points on the
axes), so the primitives will be partitioned in <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg>.
</span>
</figcaption>
</div></div><p>


</p>
<p>The general goal is to select a partition of primitives that does not have
too much overlap of the bounding boxes of the two resulting primitive
sets&mdash;if there is substantial overlap, then it will more frequently be
necessary to traverse both children&rsquo;s subtrees when traversing the tree,
requiring more computation than if it had been possible to more effectively
prune away collections of primitives.  This idea of finding effective
primitive partitions will be made more rigorous shortly, in the discussion
of the surface area heuristic.

</p>
<p></p>
<span class="anchor" id="fragment-Computeboundofprimitivecentroidsandchoosesplitdimensionmonodim-0"></span><div class="fragmentname">&lt;&lt;Compute bound of primitive centroids and choose split dimension <tt>dim</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> centroidBounds;
for (const auto &amp;prim : bvhPrimitives)
    centroidBounds = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(centroidBounds, prim.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>());
int dim = centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::MaxDimension" class="code">MaxDimension</a>();</div><p>


</p>
<p>

</p>
<p>If all the centroid points are at the same position (i.e., the centroid
bounds have zero volume), then recursion stops and a leaf node is created
with the primitives; none of the splitting methods here is effective in
that (unusual) case.  The primitives are otherwise partitioned using the
chosen method and passed to two recursive calls to <tt>buildRecursive()</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-Partitionprimitivesintotwosetsandbuildchildren-0"></span><div class="fragmentname">&lt;&lt;Partition primitives into two sets and build children&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[dim] == centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[dim]) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-CreateleafmonoBVHBuildNode-0">Create leaf <tt>BVHBuildNode</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1050" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1050"><i></i></a><div id="fragbit-1050" class="collapse show"><div class="fragmentcode">       int firstPrimOffset = orderedPrimsOffset-&gt;fetch_add(bvhPrimitives.size());
       for (size_t i = 0; i &lt; bvhPrimitives.size(); ++i) {
           int index = bvhPrimitives[i].<a href="#BVHPrimitive::primitiveIndex" class="code">primitiveIndex</a>;
           orderedPrims[firstPrimOffset + i] = primitives[index];
       }
       node-&gt;<a href="#BVHBuildNode::InitLeaf" class="code">InitLeaf</a>(firstPrimOffset, bvhPrimitives.size(), bounds);
       return node;</div></div>
} else {
    int mid = bvhPrimitives.size() / 2;
    &lt;&lt;<span class="fragmentname">Partition primitives based on <tt>splitMethod</tt></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1051" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1051"><i></i></a><div id="fragbit-1051" class="collapse show"><div class="fragmentcode">       switch (splitMethod) {
       case SplitMethod::Middle: {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Partitionprimitivesthroughnodesmidpoint-0">Partition primitives through node&rsquo;s midpoint</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1052" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1052"><i></i></a><div id="fragbit-1052" class="collapse show"><div class="fragmentcode">              Float pmid = (centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[dim] + centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[dim]) / 2;
              auto midIter =
                  std::partition(bvhPrimitives.begin(), bvhPrimitives.end(),
                      [dim, pmid](const BVHPrimitive &amp;pi) {
                          return pi.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim] &lt; pmid;
                      });
              mid = midIter - bvhPrimitives.begin();
              if (midIter != bvhPrimitives.begin() &amp;&amp; midIter != bvhPrimitives.end())
                  break;</div></div>
       }
       case SplitMethod::EqualCounts: {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Partitionprimitivesintoequallysizedsubsets-0">Partition primitives into equally sized subsets</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1053" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1053"><i></i></a><div id="fragbit-1053" class="collapse show"><div class="fragmentcode">              mid = bvhPrimitives.size() / 2;
              std::nth_element(bvhPrimitives.begin(), bvhPrimitives.begin() + mid, 
                               bvhPrimitives.end(),
                  [dim](const BVHPrimitive &amp;a, const BVHPrimitive &amp;b) { 
                      return a.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim] &lt; b.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim];
                  });</div></div>
           break;
       }
       case SplitMethod::SAH:
       default: {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-PartitionprimitivesusingapproximateSAH-0">Partition primitives using approximate SAH</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1054" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1054"><i></i></a><div id="fragbit-1054" class="collapse show"><div class="fragmentcode">              if (bvhPrimitives.size() &lt;= 2) {
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Partitionprimitivesintoequallysizedsubsets-0">Partition primitives into equally sized subsets</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1055" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1055"><i></i></a><div id="fragbit-1055" class="collapse show"><div class="fragmentcode">                     mid = bvhPrimitives.size() / 2;
                     std::nth_element(bvhPrimitives.begin(), bvhPrimitives.begin() + mid, 
                                      bvhPrimitives.end(),
                         [dim](const BVHPrimitive &amp;a, const BVHPrimitive &amp;b) { 
                             return a.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim] &lt; b.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim];
                         });</div></div>
              } else {
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-AllocatemonoBVHSplitBucketforSAHpartitionbuckets-0">Allocate <tt>BVHSplitBucket</tt> for SAH partition buckets</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1056" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1056"><i></i></a><div id="fragbit-1056" class="collapse show"><div class="fragmentcode">                     constexpr int nBuckets = 12;
                     BVHSplitBucket buckets[nBuckets];</div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonoBVHSplitBucketforSAHpartitionbuckets-0">Initialize <tt>BVHSplitBucket</tt> for SAH partition buckets</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1057" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1057"><i></i></a><div id="fragbit-1057" class="collapse show"><div class="fragmentcode">                     for (const auto &amp;prim : bvhPrimitives) {
                         int b = nBuckets * centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Offset" class="code">Offset</a>(prim.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>())[dim];
                         if (b == nBuckets) b = nBuckets - 1;
                         buckets[b].<a href="#BVHSplitBucket::count" class="code">count</a>++;
                         buckets[b].<a href="#BVHPrimitive::bounds" class="code">bounds</a> = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(buckets[b].<a href="#BVHPrimitive::bounds" class="code">bounds</a>, prim.<a href="#BVHPrimitive::bounds" class="code">bounds</a>);
                     }</div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Computecostsforsplittingaftereachbucket-0">Compute costs for splitting after each bucket</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1058" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1058"><i></i></a><div id="fragbit-1058" class="collapse show"><div class="fragmentcode">                     constexpr int nSplits = nBuckets - 1;
                     Float costs[nSplits] = {};
                     &lt;&lt;<span class="fragmentname"><a href="#fragment-Partiallyinitializemonocostsusingaforwardscanoversplits-0">Partially initialize <tt>costs</tt> using a forward scan over splits</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1059" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1059"><i></i></a><div id="fragbit-1059" class="collapse show"><div class="fragmentcode">                        int countBelow = 0;
                        <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> boundBelow;
                        for (int i = 0; i &lt; nSplits; ++i) {
                            boundBelow = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(boundBelow, buckets[i].bounds);
                            countBelow += buckets[i].count;
                            costs[i] += countBelow * boundBelow.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();
                        }</div></div>
                     &lt;&lt;<span class="fragmentname"><a href="#fragment-Finishinitializingmonocostsusingabackwardscanoversplits-0">Finish initializing <tt>costs</tt> using a backward scan over splits</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1060" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1060"><i></i></a><div id="fragbit-1060" class="collapse show"><div class="fragmentcode">                        int countAbove = 0;
                        <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> boundAbove;
                        for (int i = nSplits; i &gt;= 1; --i) {
                            boundAbove = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(boundAbove, buckets[i].bounds);
                            countAbove += buckets[i].count;
                            costs[i - 1] += countAbove * boundAbove.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();
                        }</div></div></div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-FindbuckettosplitatthatminimizesSAHmetric-0">Find bucket to split at that minimizes SAH metric</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1061" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1061"><i></i></a><div id="fragbit-1061" class="collapse show"><div class="fragmentcode">                     int minCostSplitBucket = -1;
                     Float minCost = Infinity;
                     for (int i = 0; i &lt; nSplits; ++i) {
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-Computecostforcandidatesplitandupdateminimumifnecessary-0">Compute cost for candidate split and update minimum if necessary</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1062" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1062"><i></i></a><div id="fragbit-1062" class="collapse show"><div class="fragmentcode">                            if (costs[i] &lt; minCost) {
                                minCost = costs[i];
                                minCostSplitBucket = i;
                            }</div></div>
                     }
                     &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputeleafcostandSAHsplitcostforchosensplit-0">Compute leaf cost and SAH split cost for chosen split</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1063" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1063"><i></i></a><div id="fragbit-1063" class="collapse show"><div class="fragmentcode">                        Float leafCost = bvhPrimitives.size();
                        minCost = 1.f / 2.f + minCost / bounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();</div></div></div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-EithercreateleaforsplitprimitivesatselectedSAHbucket-0">Either create leaf or split primitives at selected SAH bucket</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1064" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1064"><i></i></a><div id="fragbit-1064" class="collapse show"><div class="fragmentcode">                     if (bvhPrimitives.size() &gt; <a href="#BVHAggregate::maxPrimsInNode" class="code">maxPrimsInNode</a> || minCost &lt; leafCost) {
                         auto midIter = std::partition(bvhPrimitives.begin(),
                             bvhPrimitives.end(),
                             [=](const BVHPrimitive &amp;bp) {
                                 int b = nBuckets * centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Offset" class="code">Offset</a>(bp.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>())[dim];
                                 if (b == nBuckets) b = nBuckets - 1;
                                 return b &lt;= minCostSplitBucket;
                             });
                         mid = midIter - bvhPrimitives.begin();
                     } else {
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-CreateleafmonoBVHBuildNode-0">Create leaf <tt>BVHBuildNode</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1065" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1065"><i></i></a><div id="fragbit-1065" class="collapse show"><div class="fragmentcode">                            int firstPrimOffset = orderedPrimsOffset-&gt;fetch_add(bvhPrimitives.size());
                            for (size_t i = 0; i &lt; bvhPrimitives.size(); ++i) {
                                int index = bvhPrimitives[i].<a href="#BVHPrimitive::primitiveIndex" class="code">primitiveIndex</a>;
                                orderedPrims[firstPrimOffset + i] = primitives[index];
                            }
                            node-&gt;<a href="#BVHBuildNode::InitLeaf" class="code">InitLeaf</a>(firstPrimOffset, bvhPrimitives.size(), bounds);
                            return node;</div></div>
                     }</div></div>
              }</div></div>
           break;
       }
       }</div></div>
    BVHBuildNode *children[2];
    &lt;&lt;<span class="fragmentname"><a href="#fragment-RecursivelybuildBVHsformonochildren-0">Recursively build BVHs for <tt>children</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1066" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1066"><i></i></a><div id="fragbit-1066" class="collapse show"><div class="fragmentcode">       if (bvhPrimitives.size() &gt; 128 * 1024) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-RecursivelybuildchildBVHsinparallel-0">Recursively build child BVHs in parallel</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1067" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1067"><i></i></a><div id="fragbit-1067" class="collapse show"><div class="fragmentcode">              <a href="../Utilities/Parallelism.html#ParallelFor" class="code">ParallelFor</a>(0, 2, [&amp;](int i) {
                  if (i == 0)
                      children[0] =
                          <a href="#BVHAggregate::buildRecursive" class="code">buildRecursive</a>(threadAllocators, bvhPrimitives.subspan(0, mid),
                                         totalNodes, orderedPrimsOffset, orderedPrims);
                  else
                      children[1] =
                          <a href="#BVHAggregate::buildRecursive" class="code">buildRecursive</a>(threadAllocators, bvhPrimitives.subspan(mid),
                                         totalNodes, orderedPrimsOffset, orderedPrims);
              });</div></div>
       } else {
           &lt;&lt;<span class="fragmentname">Recursively build child BVHs sequentially</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1068" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1068"><i></i></a><div id="fragbit-1068" class="collapse show"><div class="fragmentcode">              children[0] =
                  buildRecursive(threadAllocators, bvhPrimitives.subspan(0, mid),
                                 totalNodes, orderedPrimsOffset, orderedPrims);
              children[1] =
                  buildRecursive(threadAllocators, bvhPrimitives.subspan(mid),
                                 totalNodes, orderedPrimsOffset, orderedPrims);</div></div>
       }</div></div>
    node-&gt;<a href="#BVHBuildNode::InitInterior" class="code">InitInterior</a>(dim, children[0], children[1]);
}</div><p>


</p>
<p>The two recursive calls access independent data, other than when they
allocate space in the <tt>orderedPrims</tt> array by incrementing
<tt>orderedPrimsOffset</tt>, which we already have seen is thread safe.
Therefore, when there are a reasonably large number of active primitives,
those calls can be performed in parallel, which improves the performance of BVH
construction.

</p>
<p></p>
<span class="anchor" id="fragment-RecursivelybuildBVHsformonochildren-0"></span><div class="fragmentname">&lt;&lt;Recursively build BVHs for <tt>children</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (bvhPrimitives.size() &gt; 128 * 1024) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-RecursivelybuildchildBVHsinparallel-0">Recursively build child BVHs in parallel</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1069" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1069"><i></i></a><div id="fragbit-1069" class="collapse show"><div class="fragmentcode">       <a href="../Utilities/Parallelism.html#ParallelFor" class="code">ParallelFor</a>(0, 2, [&amp;](int i) {
           if (i == 0)
               children[0] =
                   <a href="#BVHAggregate::buildRecursive" class="code">buildRecursive</a>(threadAllocators, bvhPrimitives.subspan(0, mid),
                                  totalNodes, orderedPrimsOffset, orderedPrims);
           else
               children[1] =
                   <a href="#BVHAggregate::buildRecursive" class="code">buildRecursive</a>(threadAllocators, bvhPrimitives.subspan(mid),
                                  totalNodes, orderedPrimsOffset, orderedPrims);
       });</div></div>
} else {
    &lt;&lt;<span class="fragmentname">Recursively build child BVHs sequentially</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1070" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1070"><i></i></a><div id="fragbit-1070" class="collapse show"><div class="fragmentcode">       children[0] =
           buildRecursive(threadAllocators, bvhPrimitives.subspan(0, mid),
                          totalNodes, orderedPrimsOffset, orderedPrims);
       children[1] =
           buildRecursive(threadAllocators, bvhPrimitives.subspan(mid),
                          totalNodes, orderedPrimsOffset, orderedPrims);</div></div>
}</div><p>


</p>
<p>A parallel <tt>for</tt> loop over two items is sufficient to expose the
available parallelism.  With <tt>pbrt</tt>&rsquo;s implementation of
<tt>ParallelFor()</tt>, the current thread will end up handling the first
recursive call, while another thread, if available, can take the second.
<tt>ParallelFor()</tt> does not return until all the loop iterations have
completed, so we can safely proceed, knowing that both <tt>children</tt>
are fully initialized when it does.

</p>
<p></p>
<span class="anchor" id="fragment-RecursivelybuildchildBVHsinparallel-0"></span><div class="fragmentname">&lt;&lt;Recursively build child BVHs in parallel&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Utilities/Parallelism.html#ParallelFor" class="code">ParallelFor</a>(0, 2, [&amp;](int i) {
    if (i == 0)
        children[0] =
            <a href="#BVHAggregate::buildRecursive" class="code">buildRecursive</a>(threadAllocators, bvhPrimitives.subspan(0, mid),
                           totalNodes, orderedPrimsOffset, orderedPrims);
    else
        children[1] =
            <a href="#BVHAggregate::buildRecursive" class="code">buildRecursive</a>(threadAllocators, bvhPrimitives.subspan(mid),
                           totalNodes, orderedPrimsOffset, orderedPrims);
});</div><p>


</p>
<p>The code for the non-parallel case, &lt;&lt;<span class="fragmentname">Recursively build child BVHs
sequentially</span>&gt;&gt;, is equivalent, just without the parallel <tt>for</tt> loop.  We have
therefore not included it here.

</p>
<p>

</p>
<p>We also will not include the code fragment &lt;&lt;<span class="fragmentname">Partition primitives
based on <tt>splitMethod</tt></span>&gt;&gt; here; it just uses the value of
<a href="#BVHAggregate::splitMethod"><tt>BVHAggregate::splitMethod</tt></a> to determine which primitive partitioning
scheme to use.  These three schemes will be described in the following few
pages.

</p>
<p>

</p>
<p>A simple <tt>splitMethod</tt> is <tt>Middle</tt>, which first computes the
midpoint of the primitives&rsquo; centroids along the splitting axis.  This
method is implemented in the fragment &lt;&lt;<span class="fragmentname"><a href="#fragment-Partitionprimitivesthroughnodesmidpoint-0">Partition primitives
through node&rsquo;s midpoint</a></span>&gt;&gt;.  The primitives are classified into the two
sets,
depending on whether their centroids are above or below the midpoint.  This
partitioning is easily done with the <tt>std::partition()</tt> C++ standard
library function, which takes a range of elements in an array and a
comparison function and orders the elements in the array so that all the
elements that return <tt>true</tt> for the given
predicate function appear in
the range before those that return <tt>false</tt> for it.
<tt>std::partition()</tt> returns a pointer to the first element
that had a <tt>false</tt> value for the predicate.
Figure&nbsp;<a href="#fig:bvh-split-middle">7.5</a> illustrates this approach,
including cases where it does and does not work well.

</p>
<p>If the primitives all have large overlapping bounding boxes, this splitting
method may fail to separate the primitives into two groups.  In that case,
execution falls through to the <tt>SplitMethod::EqualCounts</tt> approach to try
again.

</p>
<p></p>
<span class="anchor" id="fragment-Partitionprimitivesthroughnodesmidpoint-0"></span><div class="fragmentname">&lt;&lt;Partition primitives through node&rsquo;s midpoint&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">Float pmid = (centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[dim] + centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[dim]) / 2;
auto midIter =
    std::partition(bvhPrimitives.begin(), bvhPrimitives.end(),
        [dim, pmid](const BVHPrimitive &amp;pi) {
            return pi.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim] &lt; pmid;
        });
mid = midIter - bvhPrimitives.begin();
if (midIter != bvhPrimitives.begin() &amp;&amp; midIter != bvhPrimitives.end())
    break;</div><p>


</p>
<p>When <tt>splitMethod</tt> is <tt>SplitMethod::EqualCounts</tt>, the
&lt;&lt;<span class="fragmentname"><a href="#fragment-Partitionprimitivesintoequallysizedsubsets-0">Partition primitives into equally sized subsets</a></span>&gt;&gt; fragment runs.
It partitions the primitives into two equal-sized subsets such that the
first half of the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 600.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
</g>
</svg> of them are the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.72ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 1601.5 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n slash 2</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2F" d="M445 730c0 -2 0 -5 -1 -7l-349 -960c-3 -8 -10 -13 -19 -13c-11 0 -20 9 -20 20c0 2 0 5 1 7l349 960c3 8 10 13 19 13c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2F" x="600" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="1101" y="0"></use>
</g>
</svg> with smallest centroid
coordinate values along the chosen axis, and the second half are the ones
with the largest centroid coordinate values.  While this approach can
sometimes work well, the case in Figure&nbsp;<a href="#fig:bvh-split-middle">7.5</a>(b) is
one where this method also fares poorly.

</p>
<p></p>
<span class="anchor" id="fig:bvh-split-middle"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="pha07f05.svg" title=""><img src="pha07f05.svg" width=519 height=824 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 7.5: Splitting Primitives Based on the Midpoint of Centroids on an Axis.
<span class="legend">
(a)&nbsp;For some distributions of primitives, such as the one shown here, splitting
  based on the midpoint of the centroids along the chosen axis (thick vertical line) works well.
  (The bounding boxes of the two resulting primitive groups are shown with
  dashed lines.)
(b)&nbsp;For distributions like this one, the midpoint is a suboptimal choice;
  the two resulting bounding boxes overlap substantially.
(c)&nbsp;If the same group of primitives from (b) is instead split along the
  line shown here, the resulting bounding boxes are smaller and do not
  overlap at all, leading to better performance when rendering.
</span>
</figcaption>
</div></div><p>


</p>
<p>This scheme is also easily implemented with a standard library call,
<tt>std::nth_element()</tt>.  It takes a start, middle, and ending iterator
as well as a comparison function.  It orders the array so that the element
at the middle iterator is the one that would be there if the array was fully
sorted, and such that all the elements before the middle one compare to
less than the middle element and all the elements after it compare to
greater than it.  This ordering can be done in <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.977ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2143 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper O left-parenthesis n right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D442" d="M740 436c0 -239 -223 -458 -435 -458c-144 0 -256 101 -256 267c0 233 220 460 436 460c149 0 255 -108 255 -269zM651 475c0 149 -90 205 -172 205c-79 0 -177 -52 -246 -156c-77 -117 -91 -263 -91 -307c0 -132 70 -213 169 -213c84 0 166 59 214 120 c99 123 126 279 126 351Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D442" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="763" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="1153" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="1753" y="0"></use>
</g>
</svg> time, with <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 600.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
</g>
</svg> the
number of elements, which is more efficient than the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.118ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 4356.3 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper O left-parenthesis n log n right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D442" d="M740 436c0 -239 -223 -458 -435 -458c-144 0 -256 101 -256 267c0 233 220 460 436 460c149 0 255 -108 255 -269zM651 475c0 149 -90 205 -172 205c-79 0 -177 -52 -246 -156c-77 -117 -91 -263 -91 -307c0 -132 70 -213 169 -213c84 0 166 59 214 120 c99 123 126 279 126 351Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6C" d="M255 0l-111 3l-111 -3v31c67 0 78 0 78 45v520c0 49 -8 56 -78 56v31l144 11v-618c0 -45 11 -45 78 -45v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6F" d="M471 214c0 -127 -101 -225 -222 -225c-117 0 -221 96 -221 225c0 125 97 234 222 234c121 0 221 -106 221 -234zM388 222c0 38 0 96 -26 139s-69 65 -113 65c-40 0 -87 -21 -114 -67c-24 -44 -24 -98 -24 -137c0 -36 0 -97 25 -141c27 -46 71 -67 114 -67 c50 0 94 29 116 74c22 44 22 98 22 134Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-67" d="M485 404c0 -23 -19 -30 -29 -30c-16 0 -29 12 -29 29c0 12 5 23 16 27c-3 1 -10 1 -10 1c-18 0 -54 -5 -90 -39c25 -23 41 -60 41 -97c0 -77 -69 -146 -162 -146c-19 0 -60 3 -99 31c-17 -20 -17 -43 -17 -47c0 -32 21 -63 53 -67c7 -1 50 -1 75 -1c61 0 119 0 172 -28 c51 -28 65 -79 65 -114c0 -78 -104 -129 -222 -129c-122 0 -221 55 -221 127c0 40 32 83 92 100c-31 20 -44 58 -44 89c0 35 18 68 31 83c-25 21 -47 59 -47 103c0 77 69 146 162 146c22 0 64 -3 106 -36c42 41 86 47 106 47c39 0 51 -32 51 -49zM309 296 c0 23 0 123 -87 123c-40 0 -63 -28 -71 -40c-15 -25 -16 -57 -16 -84c0 -23 0 -123 87 -123c40 0 63 28 71 40c15 25 16 57 16 84zM419 -79c0 86 -112 86 -198 86h-59c-44 -3 -82 -40 -82 -86c0 -53 69 -104 170 -104c98 0 169 50 169 104Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D442" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="763" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="1153" y="0"></use>
<g transform="translate(1920,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-6C"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-6F" x="278" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-67" x="779" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="3366" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="3966" y="0"></use>
</g>
</svg> cost of
completely sorting the array.

</p>
<p></p>
<span class="anchor" id="fragment-Partitionprimitivesintoequallysizedsubsets-0"></span><div class="fragmentname">&lt;&lt;Partition primitives into equally sized subsets&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">mid = bvhPrimitives.size() / 2;
std::nth_element(bvhPrimitives.begin(), bvhPrimitives.begin() + mid, 
                 bvhPrimitives.end(),
    [dim](const BVHPrimitive &amp;a, const BVHPrimitive &amp;b) { 
        return a.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim] &lt; b.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim];
    });</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#TheSurfaceAreaHeuristic"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:sah"></span><span id="TheSurfaceAreaHeuristic"></span><h3>7.3.2  The Surface Area Heuristic</h3><p>



</p>
<p>The two primitive partitioning approaches described so far can work well for some
distributions of primitives, but they often choose partitions that perform
poorly in practice, leading to more nodes of the tree being visited by rays
and hence unnecessarily inefficient ray&ndash;primitive intersection
computations at rendering time.  Most of the best current algorithms for
building acceleration structures for ray tracing are based on the &ldquo;surface
area heuristic&rdquo; (SAH), which provides a well-grounded cost model for
answering questions like &ldquo;which of a number of partitions of primitives
will lead to a better BVH for ray&ndash;primitive intersection tests?&rdquo; or
&ldquo;which of a number of possible positions to split space in a spatial
subdivision scheme will lead to a better acceleration structure?&rdquo;

</p>
<p>The SAH model estimates the computational expense of performing ray
intersection tests, including the time spent traversing nodes of the tree
and the time spent on ray&ndash;primitive intersection tests for a particular
partitioning of primitives.  Algorithms for
building acceleration structures can then follow the goal of minimizing
total cost.  Typically, a greedy algorithm is used that minimizes the cost
for each single node of the hierarchy being built individually.

</p>
<p>The ideas behind the SAH cost model are straightforward: at any point in
building an adaptive acceleration structure (primitive subdivision or
spatial subdivision), we could just create a leaf node for the current
region and geometry.  In that case, any ray that passes through this region
will be tested against all the overlapping primitives and will incur a
cost of
</p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">
<div class="displaymath"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.278ex" height="6.843ex" style="vertical-align: -3.005ex;" viewBox="0 -1652.5 4855.6 2946.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">sigma-summation Underscript i equals 1 Overscript n Endscripts t Subscript normal i normal s normal e normal c normal t Baseline left-parenthesis i right-parenthesis comma</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNSIZE1-2211" d="M1387 -130l-121 -320h-1182c-18 0 -27 0 -27 11c0 0 0 6 10 18l518 607l-529 724c0 11 0 30 1 33c3 6 4 7 27 7h1182l121 -281h-25c-34 81 -102 126 -127 142c-79 50 -166 67 -220 75c-9 2 -100 16 -234 16h-548l466 -637c7 -10 7 -15 7 -15c0 -5 -2 -8 -9 -16l-509 -597 h603c192 0 290 26 311 31c115 30 221 98 260 202h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D456" d="M284 625c0 -30 -30 -53 -53 -53c-24 0 -38 17 -38 36c0 27 27 53 54 53c23 0 37 -16 37 -36zM293 143c0 -9 -37 -154 -131 -154c-48 0 -82 35 -82 82c0 21 13 54 23 80c16 43 61 159 69 185c4 10 11 31 11 52c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124 c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -13 -53c-10 -27 -10 -29 -22 -58l-39 -105c-23 -61 -29 -75 -29 -100c0 -23 7 -33 24 -33c51 0 84 61 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-3D" d="M722 347c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20zM722 153c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D461" d="M330 420c0 -20 -10 -20 -30 -20h-94l-74 -295c-4 -17 -6 -24 -6 -48c0 -33 10 -46 31 -46c34 0 87 24 130 128c5 11 6 14 15 14c4 0 12 0 12 -10c0 -8 -57 -154 -159 -154c-54 0 -92 38 -92 92c0 18 4 35 76 319h-88c-20 0 -28 0 -28 12c0 19 10 19 30 19h94l39 159 c9 35 37 36 40 36c17 0 29 -10 29 -27c0 -6 -5 -26 -41 -168h88c18 0 28 0 28 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-73" d="M360 128c0 -72 -46 -139 -161 -139c-21 0 -66 1 -110 43c-18 -19 -18 -21 -20 -23c-19 -19 -20 -20 -25 -20c-11 0 -11 7 -11 24v132c0 18 0 25 13 25c10 0 11 -4 14 -17c19 -85 55 -142 139 -142c78 0 113 40 113 91c0 72 -82 88 -104 92c-72 14 -100 20 -132 46 c-27 22 -43 50 -43 85c0 56 38 123 160 123c15 0 56 0 94 -28c4 3 14 12 17 16c13 12 15 12 20 12c11 0 11 -7 11 -24v-101c0 -19 0 -24 -13 -24c0 0 -11 0 -12 9c-2 31 -7 121 -117 121c-86 0 -112 -41 -112 -76c0 -58 67 -71 123 -82c42 -8 81 -16 114 -48 c12 -12 42 -42 42 -95Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-65" d="M415 119c0 -19 -45 -130 -167 -130c-115 0 -220 97 -220 231c0 125 92 228 208 228c125 0 179 -97 179 -196c0 -21 -3 -21 -25 -21h-279c0 -36 0 -102 30 -150c23 -37 63 -67 113 -67c10 0 100 0 135 103c2 8 4 14 13 14c5 0 13 -2 13 -12zM349 252 c0 39 -10 174 -113 174c-34 0 -118 -25 -124 -174h237Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-63" d="M415 119c0 -10 -32 -130 -166 -130c-116 0 -215 99 -215 227c0 124 92 232 217 232c77 0 153 -39 153 -107c0 -30 -20 -47 -46 -47c-28 0 -46 20 -46 46c0 13 6 43 47 46c-35 36 -98 37 -107 37c-53 0 -135 -42 -135 -205c0 -161 88 -204 141 -204c37 0 102 12 131 105 c2 6 4 10 13 10c3 0 13 0 13 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-74" d="M332 124c0 -64 -28 -135 -99 -135c-36 0 -129 12 -129 135v276h-85v22c98 4 128 111 129 193h25v-184h143v-31h-143v-278c0 -17 0 -108 67 -108c37 0 67 38 67 112v55h25v-57Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNSIZE1-2211" x="0" y="0"></use>
<g transform="translate(147,-1090)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D456" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-3D" x="345" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="1124" y="0"></use>
</g>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="721" y="1627"></use>
<g transform="translate(1611,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-73" x="278" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-65" x="673" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-63" x="1117" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-74" x="1562" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="3452" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D456" x="3842" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="4187" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="4577" y="0"></use>
</g>
</svg>
</div>
<p>

where <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 600.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
</g>
</svg> is the number of primitives and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.889ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2965.9 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">t Subscript normal i normal s normal e normal c normal t Baseline left-parenthesis i right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D461" d="M330 420c0 -20 -10 -20 -30 -20h-94l-74 -295c-4 -17 -6 -24 -6 -48c0 -33 10 -46 31 -46c34 0 87 24 130 128c5 11 6 14 15 14c4 0 12 0 12 -10c0 -8 -57 -154 -159 -154c-54 0 -92 38 -92 92c0 18 4 35 76 319h-88c-20 0 -28 0 -28 12c0 19 10 19 30 19h94l39 159 c9 35 37 36 40 36c17 0 29 -10 29 -27c0 -6 -5 -26 -41 -168h88c18 0 28 0 28 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-73" d="M360 128c0 -72 -46 -139 -161 -139c-21 0 -66 1 -110 43c-18 -19 -18 -21 -20 -23c-19 -19 -20 -20 -25 -20c-11 0 -11 7 -11 24v132c0 18 0 25 13 25c10 0 11 -4 14 -17c19 -85 55 -142 139 -142c78 0 113 40 113 91c0 72 -82 88 -104 92c-72 14 -100 20 -132 46 c-27 22 -43 50 -43 85c0 56 38 123 160 123c15 0 56 0 94 -28c4 3 14 12 17 16c13 12 15 12 20 12c11 0 11 -7 11 -24v-101c0 -19 0 -24 -13 -24c0 0 -11 0 -12 9c-2 31 -7 121 -117 121c-86 0 -112 -41 -112 -76c0 -58 67 -71 123 -82c42 -8 81 -16 114 -48 c12 -12 42 -42 42 -95Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-65" d="M415 119c0 -19 -45 -130 -167 -130c-115 0 -220 97 -220 231c0 125 92 228 208 228c125 0 179 -97 179 -196c0 -21 -3 -21 -25 -21h-279c0 -36 0 -102 30 -150c23 -37 63 -67 113 -67c10 0 100 0 135 103c2 8 4 14 13 14c5 0 13 -2 13 -12zM349 252 c0 39 -10 174 -113 174c-34 0 -118 -25 -124 -174h237Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-63" d="M415 119c0 -10 -32 -130 -166 -130c-116 0 -215 99 -215 227c0 124 92 232 217 232c77 0 153 -39 153 -107c0 -30 -20 -47 -46 -47c-28 0 -46 20 -46 46c0 13 6 43 47 46c-35 36 -98 37 -107 37c-53 0 -135 -42 -135 -205c0 -161 88 -204 141 -204c37 0 102 12 131 105 c2 6 4 10 13 10c3 0 13 0 13 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-74" d="M332 124c0 -64 -28 -135 -99 -135c-36 0 -129 12 -129 135v276h-85v22c98 4 128 111 129 193h25v-184h143v-31h-143v-278c0 -17 0 -108 67 -108c37 0 67 38 67 112v55h25v-57Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D456" d="M284 625c0 -30 -30 -53 -53 -53c-24 0 -38 17 -38 36c0 27 27 53 54 53c23 0 37 -16 37 -36zM293 143c0 -9 -37 -154 -131 -154c-48 0 -82 35 -82 82c0 21 13 54 23 80c16 43 61 159 69 185c4 10 11 31 11 52c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124 c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -13 -53c-10 -27 -10 -29 -22 -58l-39 -105c-23 -61 -29 -75 -29 -100c0 -23 7 -33 24 -33c51 0 84 61 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-73" x="278" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-65" x="673" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-63" x="1117" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-74" x="1562" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="1841" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D456" x="2230" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="2576" y="0"></use>
</g>
</svg> is the
time to compute a ray&ndash;object intersection with the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.802ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 345.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">i</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D456" d="M284 625c0 -30 -30 -53 -53 -53c-24 0 -38 17 -38 36c0 27 27 53 54 53c23 0 37 -16 37 -36zM293 143c0 -9 -37 -154 -131 -154c-48 0 -82 35 -82 82c0 21 13 54 23 80c16 43 61 159 69 185c4 10 11 31 11 52c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124 c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -13 -53c-10 -27 -10 -29 -22 -58l-39 -105c-23 -61 -29 -75 -29 -100c0 -23 7 -33 24 -33c51 0 84 61 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D456" x="0" y="0"></use>
</g>
</svg>th primitive.

</p>
<p>
The other option is to split the region.  In that case, rays will incur the
cost
</p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="eq:sah"></span><div class="displaymath"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="49.596ex" height="7.009ex" style="vertical-align: -3.005ex;" viewBox="0 -1724.2 21353.7 3017.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">c left-parenthesis upper A comma upper B right-parenthesis equals t Subscript normal t normal r normal a normal v Baseline plus p Subscript upper A Baseline sigma-summation Underscript i equals 1 Overscript n Subscript upper A Baseline Endscripts t Subscript normal i normal s normal e normal c normal t Baseline left-parenthesis a Subscript i Baseline right-parenthesis plus p Subscript upper B Baseline sigma-summation Underscript i equals 1 Overscript n Subscript upper B Baseline Endscripts t Subscript normal i normal s normal e normal c normal t Baseline left-parenthesis b Subscript i Baseline right-parenthesis comma</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D450" d="M430 107c0 -12 -84 -118 -227 -118c-104 0 -162 79 -162 169c0 141 133 284 268 284c71 0 118 -37 118 -86c0 -40 -27 -64 -56 -64c-19 0 -37 11 -37 35c0 7 2 24 18 39c14 14 28 14 44 14c-14 27 -52 40 -86 40c-55 0 -110 -43 -141 -100c-34 -62 -54 -159 -54 -200 c0 -60 27 -109 90 -109c12 0 121 0 200 99c6 8 8 10 13 10c6 0 12 -7 12 -13Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D434" d="M721 20c0 -20 -12 -20 -18 -20c-25 0 -88 3 -113 3c-41 0 -84 -3 -125 -3c0 0 -14 0 -14 11c0 20 10 20 24 20c20 0 72 3 72 33c0 10 -14 146 -16 167h-251c-68 -116 -69 -116 -76 -128c-8 -14 -14 -25 -14 -37c0 -25 24 -33 47 -35c7 0 16 -1 16 -12 c0 -19 -13 -19 -19 -19c-32 0 -67 3 -100 3c-28 0 -59 -3 -86 -3c-8 0 -13 5 -13 11c0 19 9 19 21 20c44 3 83 17 123 84l348 584c6 10 10 17 26 17c17 0 17 -4 19 -24l61 -625c3 -29 3 -36 65 -36c13 0 23 0 23 -11zM528 262l-32 330l-197 -330h229Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D435" d="M756 545c0 -95 -105 -169 -209 -188c97 -11 155 -69 155 -141c0 -98 -118 -216 -276 -216h-357c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 10 20 29 20h336 c120 0 186 -64 186 -138zM665 549c0 44 -21 103 -109 103h-129c-43 0 -45 -3 -54 -38l-62 -248h146c122 0 208 95 208 183zM609 227c0 43 -19 117 -115 117h-189l-69 -279c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h136c118 0 207 97 207 196Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-3D" d="M722 347c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20zM722 153c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D461" d="M330 420c0 -20 -10 -20 -30 -20h-94l-74 -295c-4 -17 -6 -24 -6 -48c0 -33 10 -46 31 -46c34 0 87 24 130 128c5 11 6 14 15 14c4 0 12 0 12 -10c0 -8 -57 -154 -159 -154c-54 0 -92 38 -92 92c0 18 4 35 76 319h-88c-20 0 -28 0 -28 12c0 19 10 19 30 19h94l39 159 c9 35 37 36 40 36c17 0 29 -10 29 -27c0 -6 -5 -26 -41 -168h88c18 0 28 0 28 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-74" d="M332 124c0 -64 -28 -135 -99 -135c-36 0 -129 12 -129 135v276h-85v22c98 4 128 111 129 193h25v-184h143v-31h-143v-278c0 -17 0 -108 67 -108c37 0 67 38 67 112v55h25v-57Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-72" d="M364 381c0 -32 -25 -44 -43 -44c-22 0 -43 15 -43 43c0 26 20 38 23 39c-2 1 -4 1 -11 1c-76 0 -118 -89 -118 -188v-154c0 -36 2 -47 76 -47h21v-31c-40 3 -87 3 -127 3l-114 -3v31c67 0 78 0 78 45v268c0 49 -8 56 -78 56v31l139 11v-110c14 43 50 110 123 110 c43 0 74 -29 74 -61Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-61" d="M483 89c0 -81 -61 -95 -82 -95c-47 0 -74 42 -78 82c-19 -47 -65 -87 -131 -87c-63 0 -160 25 -160 106c0 44 25 96 100 130c63 30 133 33 184 36v37c0 89 -57 128 -106 128c-32 0 -81 -11 -108 -46c46 -1 51 -34 51 -46c0 -26 -18 -46 -46 -46c-26 0 -46 17 -46 47 c0 66 69 113 151 113c48 0 98 -16 137 -55c36 -37 36 -76 36 -118v-200c0 -5 4 -50 37 -50c11 0 36 6 36 64v56h25v-56zM316 140v100c-165 -6 -207 -89 -207 -144c0 -50 41 -85 90 -85c45 0 117 34 117 129Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-76" d="M508 400c-66 -1 -83 -44 -92 -67l-131 -325c-4 -10 -8 -19 -21 -19s-15 5 -21 19l-144 355c-13 31 -17 37 -80 37v31c30 -2 70 -3 97 -3l109 3v-31c-18 0 -57 0 -57 -26c0 0 0 -4 6 -17l112 -279l102 255c4 11 6 15 6 24c0 19 -11 42 -48 43v31l87 -3c23 0 52 1 75 3v-31 Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2B" d="M722 250c0 -11 -9 -20 -20 -20h-293v-293c0 -11 -9 -20 -20 -20s-20 9 -20 20v293h-293c-11 0 -20 9 -20 20s9 20 20 20h293v293c0 11 9 20 20 20s20 -9 20 -20v-293h293c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45D" d="M490 282c0 -147 -125 -293 -241 -293c-51 0 -79 35 -92 64c-7 -25 -49 -188 -49 -200c0 -9 0 -16 50 -16c14 0 24 0 24 -11c0 -20 -13 -20 -18 -20c-32 0 -66 3 -99 3c-28 0 -57 -3 -84 -3c-8 0 -13 4 -13 12c0 19 11 19 23 19c44 0 46 7 54 41l112 445c4 17 7 28 7 51 c0 38 -14 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 3 13 63 31 97c9 18 28 57 74 57c37 0 80 -21 90 -75c33 39 81 75 131 75c76 0 133 -66 133 -160zM418 326c0 59 -24 94 -64 94c-17 0 -46 -7 -81 -38c-18 -15 -45 -43 -52 -70 l-49 -196c-3 -12 -3 -16 -3 -16c0 -6 13 -89 79 -89c37 0 85 33 119 103c18 38 51 153 51 212Z"></path>
<path stroke-width="1" id="E1-LATINMODERNSIZE1-2211" d="M1387 -130l-121 -320h-1182c-18 0 -27 0 -27 11c0 0 0 6 10 18l518 607l-529 724c0 11 0 30 1 33c3 6 4 7 27 7h1182l121 -281h-25c-34 81 -102 126 -127 142c-79 50 -166 67 -220 75c-9 2 -100 16 -234 16h-548l466 -637c7 -10 7 -15 7 -15c0 -5 -2 -8 -9 -16l-509 -597 h603c192 0 290 26 311 31c115 30 221 98 260 202h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D456" d="M284 625c0 -30 -30 -53 -53 -53c-24 0 -38 17 -38 36c0 27 27 53 54 53c23 0 37 -16 37 -36zM293 143c0 -9 -37 -154 -131 -154c-48 0 -82 35 -82 82c0 21 13 54 23 80c16 43 61 159 69 185c4 10 11 31 11 52c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124 c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -13 -53c-10 -27 -10 -29 -22 -58l-39 -105c-23 -61 -29 -75 -29 -100c0 -23 7 -33 24 -33c51 0 84 61 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-73" d="M360 128c0 -72 -46 -139 -161 -139c-21 0 -66 1 -110 43c-18 -19 -18 -21 -20 -23c-19 -19 -20 -20 -25 -20c-11 0 -11 7 -11 24v132c0 18 0 25 13 25c10 0 11 -4 14 -17c19 -85 55 -142 139 -142c78 0 113 40 113 91c0 72 -82 88 -104 92c-72 14 -100 20 -132 46 c-27 22 -43 50 -43 85c0 56 38 123 160 123c15 0 56 0 94 -28c4 3 14 12 17 16c13 12 15 12 20 12c11 0 11 -7 11 -24v-101c0 -19 0 -24 -13 -24c0 0 -11 0 -12 9c-2 31 -7 121 -117 121c-86 0 -112 -41 -112 -76c0 -58 67 -71 123 -82c42 -8 81 -16 114 -48 c12 -12 42 -42 42 -95Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-65" d="M415 119c0 -19 -45 -130 -167 -130c-115 0 -220 97 -220 231c0 125 92 228 208 228c125 0 179 -97 179 -196c0 -21 -3 -21 -25 -21h-279c0 -36 0 -102 30 -150c23 -37 63 -67 113 -67c10 0 100 0 135 103c2 8 4 14 13 14c5 0 13 -2 13 -12zM349 252 c0 39 -10 174 -113 174c-34 0 -118 -25 -124 -174h237Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-63" d="M415 119c0 -10 -32 -130 -166 -130c-116 0 -215 99 -215 227c0 124 92 232 217 232c77 0 153 -39 153 -107c0 -30 -20 -47 -46 -47c-28 0 -46 20 -46 46c0 13 6 43 47 46c-35 36 -98 37 -107 37c-53 0 -135 -42 -135 -205c0 -161 88 -204 141 -204c37 0 102 12 131 105 c2 6 4 10 13 10c3 0 13 0 13 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D44E" d="M498 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-48 0 -83 33 -91 75c-60 -71 -110 -75 -130 -75c-78 0 -133 66 -133 160c0 146 124 293 241 293c45 0 74 -27 92 -64c3 22 18 44 42 44c17 0 29 -10 29 -27c0 -4 0 -6 -7 -34l-36 -140l-22 -90 c-11 -44 -13 -52 -13 -74c0 -20 3 -46 30 -46c41 0 59 59 76 124c3 14 4 18 14 18c3 0 12 0 12 -10zM361 332c0 6 -14 88 -79 88c-40 0 -85 -37 -116 -96c-23 -46 -55 -169 -55 -219c0 -39 14 -94 64 -94c28 0 69 16 113 71c15 17 15 19 20 37l50 196c1 5 3 11 3 17Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D44F" d="M415 282c0 -144 -123 -293 -241 -293c-74 0 -127 62 -127 157c0 35 4 51 16 101l82 326c5 21 14 55 14 62c0 10 -2 17 -50 17c-15 0 -24 0 -24 12c0 18 11 19 19 20c26 2 99 10 122 10c13 0 13 -11 13 -11l-74 -301c30 31 71 60 117 60c80 0 133 -69 133 -160zM343 326 c0 64 -27 94 -63 94c-26 0 -71 -15 -120 -80c-9 -11 -9 -13 -15 -35l-22 -92c-16 -63 -16 -82 -16 -101c0 -74 33 -101 67 -101c39 0 85 36 118 103c18 38 51 153 51 212Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D450" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="433" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D434" x="823" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="1573" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D435" x="2018" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="2778" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-3D" x="3445" y="0"></use>
<g transform="translate(4501,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-74" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-72" x="389" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-61" x="782" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-76" x="1282" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2B" x="6466" y="0"></use>
<g transform="translate(7466,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45D" x="0" y="0"></use>
<g transform="translate(503,-163)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D434" x="-236" y="0"></use>
</g>
</g>
<g transform="translate(8600,0)">
 <use xlink:href="#E1-LATINMODERNSIZE1-2211" x="0" y="0"></use>
<g transform="translate(147,-1090)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D456" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-3D" x="345" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="1124" y="0"></use>
</g>
<g transform="translate(342,1230)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
<g transform="translate(424,-169)">
 <use transform="scale(0.574)" xlink:href="#E1-LATINMODERNNORMAL-1D434" x="-291" y="0"></use>
</g>
</g>
</g>
<g transform="translate(10212,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-73" x="278" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-65" x="673" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-63" x="1117" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-74" x="1562" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="12053" y="0"></use>
<g transform="translate(12443,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D44E" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D456" x="748" y="-213"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="13316" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2B" x="13928" y="0"></use>
<g transform="translate(14929,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45D" x="0" y="0"></use>
<g transform="translate(503,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D435" x="-236" y="0"></use>
</g>
</g>
<g transform="translate(16069,0)">
 <use xlink:href="#E1-LATINMODERNSIZE1-2211" x="0" y="0"></use>
<g transform="translate(147,-1090)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D456" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-3D" x="345" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="1124" y="0"></use>
</g>
<g transform="translate(339,1211)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
<g transform="translate(424,-150)">
 <use transform="scale(0.574)" xlink:href="#E1-LATINMODERNNORMAL-1D435" x="-291" y="0"></use>
</g>
</g>
</g>
<g transform="translate(17680,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-73" x="278" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-65" x="673" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-63" x="1117" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-74" x="1562" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="19522" y="0"></use>
<g transform="translate(19911,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D44F" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D456" x="607" y="-213"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="20685" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="21075" y="0"></use>
</g>
</svg>
</div>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">
<div class="eqno">(<a href="#eq:sah">7.1</a>)</div>
</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">
<p>
 
where <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.046ex" height="2.343ex" style="vertical-align: -0.671ex;" viewBox="0 -719.6 1742.1 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">t Subscript normal t normal r normal a normal v</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D461" d="M330 420c0 -20 -10 -20 -30 -20h-94l-74 -295c-4 -17 -6 -24 -6 -48c0 -33 10 -46 31 -46c34 0 87 24 130 128c5 11 6 14 15 14c4 0 12 0 12 -10c0 -8 -57 -154 -159 -154c-54 0 -92 38 -92 92c0 18 4 35 76 319h-88c-20 0 -28 0 -28 12c0 19 10 19 30 19h94l39 159 c9 35 37 36 40 36c17 0 29 -10 29 -27c0 -6 -5 -26 -41 -168h88c18 0 28 0 28 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-74" d="M332 124c0 -64 -28 -135 -99 -135c-36 0 -129 12 -129 135v276h-85v22c98 4 128 111 129 193h25v-184h143v-31h-143v-278c0 -17 0 -108 67 -108c37 0 67 38 67 112v55h25v-57Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-72" d="M364 381c0 -32 -25 -44 -43 -44c-22 0 -43 15 -43 43c0 26 20 38 23 39c-2 1 -4 1 -11 1c-76 0 -118 -89 -118 -188v-154c0 -36 2 -47 76 -47h21v-31c-40 3 -87 3 -127 3l-114 -3v31c67 0 78 0 78 45v268c0 49 -8 56 -78 56v31l139 11v-110c14 43 50 110 123 110 c43 0 74 -29 74 -61Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-61" d="M483 89c0 -81 -61 -95 -82 -95c-47 0 -74 42 -78 82c-19 -47 -65 -87 -131 -87c-63 0 -160 25 -160 106c0 44 25 96 100 130c63 30 133 33 184 36v37c0 89 -57 128 -106 128c-32 0 -81 -11 -108 -46c46 -1 51 -34 51 -46c0 -26 -18 -46 -46 -46c-26 0 -46 17 -46 47 c0 66 69 113 151 113c48 0 98 -16 137 -55c36 -37 36 -76 36 -118v-200c0 -5 4 -50 37 -50c11 0 36 6 36 64v56h25v-56zM316 140v100c-165 -6 -207 -89 -207 -144c0 -50 41 -85 90 -85c45 0 117 34 117 129Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-76" d="M508 400c-66 -1 -83 -44 -92 -67l-131 -325c-4 -10 -8 -19 -21 -19s-15 5 -21 19l-144 355c-13 31 -17 37 -80 37v31c30 -2 70 -3 97 -3l109 3v-31c-18 0 -57 0 -57 -26c0 0 0 -4 6 -17l112 -279l102 255c4 11 6 15 6 24c0 19 -11 42 -48 43v31l87 -3c23 0 52 1 75 3v-31 Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-74" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-72" x="389" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-61" x="782" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-76" x="1282" y="0"></use>
</g>
</g>
</svg> is the time it takes to traverse the interior node
and determine which of the children the ray passes through, <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.32ex" height="2.009ex" style="vertical-align: -0.671ex; margin-left: -0.073ex;" viewBox="-31.5 -576.1 999 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">p Subscript upper A</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45D" d="M490 282c0 -147 -125 -293 -241 -293c-51 0 -79 35 -92 64c-7 -25 -49 -188 -49 -200c0 -9 0 -16 50 -16c14 0 24 0 24 -11c0 -20 -13 -20 -18 -20c-32 0 -66 3 -99 3c-28 0 -57 -3 -84 -3c-8 0 -13 4 -13 12c0 19 11 19 23 19c44 0 46 7 54 41l112 445c4 17 7 28 7 51 c0 38 -14 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 3 13 63 31 97c9 18 28 57 74 57c37 0 80 -21 90 -75c33 39 81 75 131 75c76 0 133 -66 133 -160zM418 326c0 59 -24 94 -64 94c-17 0 -46 -7 -81 -38c-18 -15 -45 -43 -52 -70 l-49 -196c-3 -12 -3 -16 -3 -16c0 -6 13 -89 79 -89c37 0 85 33 119 103c18 38 51 153 51 212Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D434" d="M721 20c0 -20 -12 -20 -18 -20c-25 0 -88 3 -113 3c-41 0 -84 -3 -125 -3c0 0 -14 0 -14 11c0 20 10 20 24 20c20 0 72 3 72 33c0 10 -14 146 -16 167h-251c-68 -116 -69 -116 -76 -128c-8 -14 -14 -25 -14 -37c0 -25 24 -33 47 -35c7 0 16 -1 16 -12 c0 -19 -13 -19 -19 -19c-32 0 -67 3 -100 3c-28 0 -59 -3 -86 -3c-8 0 -13 5 -13 11c0 19 9 19 21 20c44 3 83 17 123 84l348 584c6 10 10 17 26 17c17 0 17 -4 19 -24l61 -625c3 -29 3 -36 65 -36c13 0 23 0 23 -11zM528 262l-32 330l-197 -330h229Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45D" x="0" y="0"></use>
<g transform="translate(503,-163)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D434" x="-236" y="0"></use>
</g>
</g>
</svg>
and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.335ex" height="2.009ex" style="vertical-align: -0.671ex; margin-left: -0.073ex;" viewBox="-31.5 -576.1 1005.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">p Subscript upper B</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45D" d="M490 282c0 -147 -125 -293 -241 -293c-51 0 -79 35 -92 64c-7 -25 -49 -188 -49 -200c0 -9 0 -16 50 -16c14 0 24 0 24 -11c0 -20 -13 -20 -18 -20c-32 0 -66 3 -99 3c-28 0 -57 -3 -84 -3c-8 0 -13 4 -13 12c0 19 11 19 23 19c44 0 46 7 54 41l112 445c4 17 7 28 7 51 c0 38 -14 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 3 13 63 31 97c9 18 28 57 74 57c37 0 80 -21 90 -75c33 39 81 75 131 75c76 0 133 -66 133 -160zM418 326c0 59 -24 94 -64 94c-17 0 -46 -7 -81 -38c-18 -15 -45 -43 -52 -70 l-49 -196c-3 -12 -3 -16 -3 -16c0 -6 13 -89 79 -89c37 0 85 33 119 103c18 38 51 153 51 212Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D435" d="M756 545c0 -95 -105 -169 -209 -188c97 -11 155 -69 155 -141c0 -98 -118 -216 -276 -216h-357c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 10 20 29 20h336 c120 0 186 -64 186 -138zM665 549c0 44 -21 103 -109 103h-129c-43 0 -45 -3 -54 -38l-62 -248h146c122 0 208 95 208 183zM609 227c0 43 -19 117 -115 117h-189l-69 -279c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h136c118 0 207 97 207 196Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45D" x="0" y="0"></use>
<g transform="translate(503,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D435" x="-236" y="0"></use>
</g>
</g>
</svg>
are the probabilities that the ray passes through each of the child nodes
(assuming binary subdivision), <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.029ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 873.8 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">a Subscript i</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D44E" d="M498 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-48 0 -83 33 -91 75c-60 -71 -110 -75 -130 -75c-78 0 -133 66 -133 160c0 146 124 293 241 293c45 0 74 -27 92 -64c3 22 18 44 42 44c17 0 29 -10 29 -27c0 -4 0 -6 -7 -34l-36 -140l-22 -90 c-11 -44 -13 -52 -13 -74c0 -20 3 -46 30 -46c41 0 59 59 76 124c3 14 4 18 14 18c3 0 12 0 12 -10zM361 332c0 6 -14 88 -79 88c-40 0 -85 -37 -116 -96c-23 -46 -55 -169 -55 -219c0 -39 14 -94 64 -94c28 0 69 16 113 71c15 17 15 19 20 37l50 196c1 5 3 11 3 17Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D456" d="M284 625c0 -30 -30 -53 -53 -53c-24 0 -38 17 -38 36c0 27 27 53 54 53c23 0 37 -16 37 -36zM293 143c0 -9 -37 -154 -131 -154c-48 0 -82 35 -82 82c0 21 13 54 23 80c16 43 61 159 69 185c4 10 11 31 11 52c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124 c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -13 -53c-10 -27 -10 -29 -22 -58l-39 -105c-23 -61 -29 -75 -29 -100c0 -23 7 -33 24 -33c51 0 84 61 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D44E" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D456" x="748" y="-213"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.797ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 773.8 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">b Subscript i</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D44F" d="M415 282c0 -144 -123 -293 -241 -293c-74 0 -127 62 -127 157c0 35 4 51 16 101l82 326c5 21 14 55 14 62c0 10 -2 17 -50 17c-15 0 -24 0 -24 12c0 18 11 19 19 20c26 2 99 10 122 10c13 0 13 -11 13 -11l-74 -301c30 31 71 60 117 60c80 0 133 -69 133 -160zM343 326 c0 64 -27 94 -63 94c-26 0 -71 -15 -120 -80c-9 -11 -9 -13 -15 -35l-22 -92c-16 -63 -16 -82 -16 -101c0 -74 33 -101 67 -101c39 0 85 36 118 103c18 38 51 153 51 212Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D456" d="M284 625c0 -30 -30 -53 -53 -53c-24 0 -38 17 -38 36c0 27 27 53 54 53c23 0 37 -16 37 -36zM293 143c0 -9 -37 -154 -131 -154c-48 0 -82 35 -82 82c0 21 13 54 23 80c16 43 61 159 69 185c4 10 11 31 11 52c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124 c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -13 -53c-10 -27 -10 -29 -22 -58l-39 -105c-23 -61 -29 -75 -29 -100c0 -23 7 -33 24 -33c51 0 84 61 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D44F" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D456" x="607" y="-213"></use>
</g>
</svg> are the indices of
primitives in the two child nodes, and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.472ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 1064.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n Subscript upper A</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D434" d="M721 20c0 -20 -12 -20 -18 -20c-25 0 -88 3 -113 3c-41 0 -84 -3 -125 -3c0 0 -14 0 -14 11c0 20 10 20 24 20c20 0 72 3 72 33c0 10 -14 146 -16 167h-251c-68 -116 -69 -116 -76 -128c-8 -14 -14 -25 -14 -37c0 -25 24 -33 47 -35c7 0 16 -1 16 -12 c0 -19 -13 -19 -19 -19c-32 0 -67 3 -100 3c-28 0 -59 -3 -86 -3c-8 0 -13 5 -13 11c0 19 9 19 21 20c44 3 83 17 123 84l348 584c6 10 10 17 26 17c17 0 17 -4 19 -24l61 -625c3 -29 3 -36 65 -36c13 0 23 0 23 -11zM528 262l-32 330l-197 -330h229Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
<g transform="translate(600,-163)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D434" x="-236" y="0"></use>
</g>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.487ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 1070.9 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n Subscript upper B</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D435" d="M756 545c0 -95 -105 -169 -209 -188c97 -11 155 -69 155 -141c0 -98 -118 -216 -276 -216h-357c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 10 20 29 20h336 c120 0 186 -64 186 -138zM665 549c0 44 -21 103 -109 103h-129c-43 0 -45 -3 -54 -38l-62 -248h146c122 0 208 95 208 183zM609 227c0 43 -19 117 -115 117h-189l-69 -279c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h136c118 0 207 97 207 196Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
<g transform="translate(600,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D435" x="-236" y="0"></use>
</g>
</g>
</svg> are
the number of primitives that overlap the regions of the two child nodes,
respectively.  The choice of how primitives are partitioned affects
the values of the two probabilities as well as the set of primitives on
each side of the split.

</p>
<p>In <tt>pbrt</tt>, we will make the simplifying assumption that <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.889ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2965.9 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">t Subscript normal i normal s normal e normal c normal t Baseline left-parenthesis i right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D461" d="M330 420c0 -20 -10 -20 -30 -20h-94l-74 -295c-4 -17 -6 -24 -6 -48c0 -33 10 -46 31 -46c34 0 87 24 130 128c5 11 6 14 15 14c4 0 12 0 12 -10c0 -8 -57 -154 -159 -154c-54 0 -92 38 -92 92c0 18 4 35 76 319h-88c-20 0 -28 0 -28 12c0 19 10 19 30 19h94l39 159 c9 35 37 36 40 36c17 0 29 -10 29 -27c0 -6 -5 -26 -41 -168h88c18 0 28 0 28 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-73" d="M360 128c0 -72 -46 -139 -161 -139c-21 0 -66 1 -110 43c-18 -19 -18 -21 -20 -23c-19 -19 -20 -20 -25 -20c-11 0 -11 7 -11 24v132c0 18 0 25 13 25c10 0 11 -4 14 -17c19 -85 55 -142 139 -142c78 0 113 40 113 91c0 72 -82 88 -104 92c-72 14 -100 20 -132 46 c-27 22 -43 50 -43 85c0 56 38 123 160 123c15 0 56 0 94 -28c4 3 14 12 17 16c13 12 15 12 20 12c11 0 11 -7 11 -24v-101c0 -19 0 -24 -13 -24c0 0 -11 0 -12 9c-2 31 -7 121 -117 121c-86 0 -112 -41 -112 -76c0 -58 67 -71 123 -82c42 -8 81 -16 114 -48 c12 -12 42 -42 42 -95Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-65" d="M415 119c0 -19 -45 -130 -167 -130c-115 0 -220 97 -220 231c0 125 92 228 208 228c125 0 179 -97 179 -196c0 -21 -3 -21 -25 -21h-279c0 -36 0 -102 30 -150c23 -37 63 -67 113 -67c10 0 100 0 135 103c2 8 4 14 13 14c5 0 13 -2 13 -12zM349 252 c0 39 -10 174 -113 174c-34 0 -118 -25 -124 -174h237Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-63" d="M415 119c0 -10 -32 -130 -166 -130c-116 0 -215 99 -215 227c0 124 92 232 217 232c77 0 153 -39 153 -107c0 -30 -20 -47 -46 -47c-28 0 -46 20 -46 46c0 13 6 43 47 46c-35 36 -98 37 -107 37c-53 0 -135 -42 -135 -205c0 -161 88 -204 141 -204c37 0 102 12 131 105 c2 6 4 10 13 10c3 0 13 0 13 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-74" d="M332 124c0 -64 -28 -135 -99 -135c-36 0 -129 12 -129 135v276h-85v22c98 4 128 111 129 193h25v-184h143v-31h-143v-278c0 -17 0 -108 67 -108c37 0 67 38 67 112v55h25v-57Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D456" d="M284 625c0 -30 -30 -53 -53 -53c-24 0 -38 17 -38 36c0 27 27 53 54 53c23 0 37 -16 37 -36zM293 143c0 -9 -37 -154 -131 -154c-48 0 -82 35 -82 82c0 21 13 54 23 80c16 43 61 159 69 185c4 10 11 31 11 52c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124 c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -13 -53c-10 -27 -10 -29 -22 -58l-39 -105c-23 -61 -29 -75 -29 -100c0 -23 7 -33 24 -33c51 0 84 61 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-73" x="278" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-65" x="673" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-63" x="1117" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-74" x="1562" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="1841" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D456" x="2230" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="2576" y="0"></use>
</g>
</svg>
is the same for all the primitives; this assumption is probably not too
far from reality, and any error that it introduces does not seem to affect
the performance of accelerators very much.  Another possibility would be to
add a method to <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive"><tt>Primitive</tt></a> that returned an estimate of the number of
processing cycles that its intersection test requires.

</p>
<p>The probabilities <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.32ex" height="2.009ex" style="vertical-align: -0.671ex; margin-left: -0.073ex;" viewBox="-31.5 -576.1 999 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">p Subscript upper A</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45D" d="M490 282c0 -147 -125 -293 -241 -293c-51 0 -79 35 -92 64c-7 -25 -49 -188 -49 -200c0 -9 0 -16 50 -16c14 0 24 0 24 -11c0 -20 -13 -20 -18 -20c-32 0 -66 3 -99 3c-28 0 -57 -3 -84 -3c-8 0 -13 4 -13 12c0 19 11 19 23 19c44 0 46 7 54 41l112 445c4 17 7 28 7 51 c0 38 -14 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 3 13 63 31 97c9 18 28 57 74 57c37 0 80 -21 90 -75c33 39 81 75 131 75c76 0 133 -66 133 -160zM418 326c0 59 -24 94 -64 94c-17 0 -46 -7 -81 -38c-18 -15 -45 -43 -52 -70 l-49 -196c-3 -12 -3 -16 -3 -16c0 -6 13 -89 79 -89c37 0 85 33 119 103c18 38 51 153 51 212Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D434" d="M721 20c0 -20 -12 -20 -18 -20c-25 0 -88 3 -113 3c-41 0 -84 -3 -125 -3c0 0 -14 0 -14 11c0 20 10 20 24 20c20 0 72 3 72 33c0 10 -14 146 -16 167h-251c-68 -116 -69 -116 -76 -128c-8 -14 -14 -25 -14 -37c0 -25 24 -33 47 -35c7 0 16 -1 16 -12 c0 -19 -13 -19 -19 -19c-32 0 -67 3 -100 3c-28 0 -59 -3 -86 -3c-8 0 -13 5 -13 11c0 19 9 19 21 20c44 3 83 17 123 84l348 584c6 10 10 17 26 17c17 0 17 -4 19 -24l61 -625c3 -29 3 -36 65 -36c13 0 23 0 23 -11zM528 262l-32 330l-197 -330h229Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45D" x="0" y="0"></use>
<g transform="translate(503,-163)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D434" x="-236" y="0"></use>
</g>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.722ex" height="2.009ex" style="vertical-align: -0.671ex; margin-left: -0.073ex;" viewBox="-31.5 -576.1 1172 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">p Subscript upper B</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45D" d="M490 282c0 -147 -125 -293 -241 -293c-51 0 -79 35 -92 64c-7 -25 -49 -188 -49 -200c0 -9 0 -16 50 -16c14 0 24 0 24 -11c0 -20 -13 -20 -18 -20c-32 0 -66 3 -99 3c-28 0 -57 -3 -84 -3c-8 0 -13 4 -13 12c0 19 11 19 23 19c44 0 46 7 54 41l112 445c4 17 7 28 7 51 c0 38 -14 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 3 13 63 31 97c9 18 28 57 74 57c37 0 80 -21 90 -75c33 39 81 75 131 75c76 0 133 -66 133 -160zM418 326c0 59 -24 94 -64 94c-17 0 -46 -7 -81 -38c-18 -15 -45 -43 -52 -70 l-49 -196c-3 -12 -3 -16 -3 -16c0 -6 13 -89 79 -89c37 0 85 33 119 103c18 38 51 153 51 212Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D435" d="M756 545c0 -95 -105 -169 -209 -188c97 -11 155 -69 155 -141c0 -98 -118 -216 -276 -216h-357c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 10 20 29 20h336 c120 0 186 -64 186 -138zM665 549c0 44 -21 103 -109 103h-129c-43 0 -45 -3 -54 -38l-62 -248h146c122 0 208 95 208 183zM609 227c0 43 -19 117 -115 117h-189l-69 -279c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h136c118 0 207 97 207 196Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45D" x="0" y="0"></use>
<g transform="translate(503,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D435" x="0" y="0"></use>
</g>
</g>
</svg> can be computed using ideas
from geometric probability.  It can be shown that for a convex volume <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.743ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 750.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper A</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D434" d="M721 20c0 -20 -12 -20 -18 -20c-25 0 -88 3 -113 3c-41 0 -84 -3 -125 -3c0 0 -14 0 -14 11c0 20 10 20 24 20c20 0 72 3 72 33c0 10 -14 146 -16 167h-251c-68 -116 -69 -116 -76 -128c-8 -14 -14 -25 -14 -37c0 -25 24 -33 47 -35c7 0 16 -1 16 -12 c0 -19 -13 -19 -19 -19c-32 0 -67 3 -100 3c-28 0 -59 -3 -86 -3c-8 0 -13 5 -13 11c0 19 9 19 21 20c44 3 83 17 123 84l348 584c6 10 10 17 26 17c17 0 17 -4 19 -24l61 -625c3 -29 3 -36 65 -36c13 0 23 0 23 -11zM528 262l-32 330l-197 -330h229Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D434" x="0" y="0"></use>
</g>
</svg>
contained in another convex volume <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.764ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 759.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper B</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D435" d="M756 545c0 -95 -105 -169 -209 -188c97 -11 155 -69 155 -141c0 -98 -118 -216 -276 -216h-357c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 10 20 29 20h336 c120 0 186 -64 186 -138zM665 549c0 44 -21 103 -109 103h-129c-43 0 -45 -3 -54 -38l-62 -248h146c122 0 208 95 208 183zM609 227c0 43 -19 117 -115 117h-189l-69 -279c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h136c118 0 207 97 207 196Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D435" x="0" y="0"></use>
</g>
</svg>, the conditional probability that a
uniformly distributed random ray passing through <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.764ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 759.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper B</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D435" d="M756 545c0 -95 -105 -169 -209 -188c97 -11 155 -69 155 -141c0 -98 -118 -216 -276 -216h-357c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 10 20 29 20h336 c120 0 186 -64 186 -138zM665 549c0 44 -21 103 -109 103h-129c-43 0 -45 -3 -54 -38l-62 -248h146c122 0 208 95 208 183zM609 227c0 43 -19 117 -115 117h-189l-69 -279c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h136c118 0 207 97 207 196Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D435" x="0" y="0"></use>
</g>
</svg> will also pass through <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.743ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 750.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper A</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D434" d="M721 20c0 -20 -12 -20 -18 -20c-25 0 -88 3 -113 3c-41 0 -84 -3 -125 -3c0 0 -14 0 -14 11c0 20 10 20 24 20c20 0 72 3 72 33c0 10 -14 146 -16 167h-251c-68 -116 -69 -116 -76 -128c-8 -14 -14 -25 -14 -37c0 -25 24 -33 47 -35c7 0 16 -1 16 -12 c0 -19 -13 -19 -19 -19c-32 0 -67 3 -100 3c-28 0 -59 -3 -86 -3c-8 0 -13 5 -13 11c0 19 9 19 21 20c44 3 83 17 123 84l348 584c6 10 10 17 26 17c17 0 17 -4 19 -24l61 -625c3 -29 3 -36 65 -36c13 0 23 0 23 -11zM528 262l-32 330l-197 -330h229Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D434" x="0" y="0"></use>
</g>
</svg> is the ratio of
their surface areas, <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.168ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 933.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">s Subscript upper A</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D460" d="M420 356c0 -39 -24 -56 -46 -56s-31 15 -31 29c0 22 20 44 48 45c-15 39 -65 46 -90 46c-88 0 -112 -61 -112 -90c0 -45 40 -52 76 -60c44 -9 73 -14 100 -42c12 -12 31 -37 31 -73c0 -45 -39 -166 -201 -166c-86 0 -143 40 -143 97c0 45 30 66 56 66c21 0 37 -12 37 -35 c0 -28 -25 -58 -63 -53c23 -53 100 -53 114 -53c120 0 143 84 143 110c0 55 -52 66 -104 76c-29 6 -103 21 -103 99c0 44 37 146 169 146c76 0 119 -41 119 -86Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D434" d="M721 20c0 -20 -12 -20 -18 -20c-25 0 -88 3 -113 3c-41 0 -84 -3 -125 -3c0 0 -14 0 -14 11c0 20 10 20 24 20c20 0 72 3 72 33c0 10 -14 146 -16 167h-251c-68 -116 -69 -116 -76 -128c-8 -14 -14 -25 -14 -37c0 -25 24 -33 47 -35c7 0 16 -1 16 -12 c0 -19 -13 -19 -19 -19c-32 0 -67 3 -100 3c-28 0 -59 -3 -86 -3c-8 0 -13 5 -13 11c0 19 9 19 21 20c44 3 83 17 123 84l348 584c6 10 10 17 26 17c17 0 17 -4 19 -24l61 -625c3 -29 3 -36 65 -36c13 0 23 0 23 -11zM528 262l-32 330l-197 -330h229Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D460" x="0" y="0"></use>
<g transform="translate(469,-163)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D434" x="-236" y="0"></use>
</g>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.183ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 939.9 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">s Subscript upper B</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D460" d="M420 356c0 -39 -24 -56 -46 -56s-31 15 -31 29c0 22 20 44 48 45c-15 39 -65 46 -90 46c-88 0 -112 -61 -112 -90c0 -45 40 -52 76 -60c44 -9 73 -14 100 -42c12 -12 31 -37 31 -73c0 -45 -39 -166 -201 -166c-86 0 -143 40 -143 97c0 45 30 66 56 66c21 0 37 -12 37 -35 c0 -28 -25 -58 -63 -53c23 -53 100 -53 114 -53c120 0 143 84 143 110c0 55 -52 66 -104 76c-29 6 -103 21 -103 99c0 44 37 146 169 146c76 0 119 -41 119 -86Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D435" d="M756 545c0 -95 -105 -169 -209 -188c97 -11 155 -69 155 -141c0 -98 -118 -216 -276 -216h-357c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 10 20 29 20h336 c120 0 186 -64 186 -138zM665 549c0 44 -21 103 -109 103h-129c-43 0 -45 -3 -54 -38l-62 -248h146c122 0 208 95 208 183zM609 227c0 43 -19 117 -115 117h-189l-69 -279c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h136c118 0 207 97 207 196Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D460" x="0" y="0"></use>
<g transform="translate(469,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D435" x="-236" y="0"></use>
</g>
</g>
</svg>:
</p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">
<div class="displaymath"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.97ex" height="5.009ex" style="vertical-align: -2.171ex; margin-left: -0.073ex;" viewBox="-31.5 -1221.9 6014.9 2156.8" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">p left-parenthesis upper A vertical-bar upper B right-parenthesis equals StartFraction s Subscript upper A Baseline Over s Subscript upper B Baseline EndFraction period</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45D" d="M490 282c0 -147 -125 -293 -241 -293c-51 0 -79 35 -92 64c-7 -25 -49 -188 -49 -200c0 -9 0 -16 50 -16c14 0 24 0 24 -11c0 -20 -13 -20 -18 -20c-32 0 -66 3 -99 3c-28 0 -57 -3 -84 -3c-8 0 -13 4 -13 12c0 19 11 19 23 19c44 0 46 7 54 41l112 445c4 17 7 28 7 51 c0 38 -14 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 3 13 63 31 97c9 18 28 57 74 57c37 0 80 -21 90 -75c33 39 81 75 131 75c76 0 133 -66 133 -160zM418 326c0 59 -24 94 -64 94c-17 0 -46 -7 -81 -38c-18 -15 -45 -43 -52 -70 l-49 -196c-3 -12 -3 -16 -3 -16c0 -6 13 -89 79 -89c37 0 85 33 119 103c18 38 51 153 51 212Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D434" d="M721 20c0 -20 -12 -20 -18 -20c-25 0 -88 3 -113 3c-41 0 -84 -3 -125 -3c0 0 -14 0 -14 11c0 20 10 20 24 20c20 0 72 3 72 33c0 10 -14 146 -16 167h-251c-68 -116 -69 -116 -76 -128c-8 -14 -14 -25 -14 -37c0 -25 24 -33 47 -35c7 0 16 -1 16 -12 c0 -19 -13 -19 -19 -19c-32 0 -67 3 -100 3c-28 0 -59 -3 -86 -3c-8 0 -13 5 -13 11c0 19 9 19 21 20c44 3 83 17 123 84l348 584c6 10 10 17 26 17c17 0 17 -4 19 -24l61 -625c3 -29 3 -36 65 -36c13 0 23 0 23 -11zM528 262l-32 330l-197 -330h229Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-7C" d="M159 -230c0 -11 -9 -20 -20 -20s-20 9 -20 20v960c0 11 9 20 20 20s20 -9 20 -20v-960Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D435" d="M756 545c0 -95 -105 -169 -209 -188c97 -11 155 -69 155 -141c0 -98 -118 -216 -276 -216h-357c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 10 20 29 20h336 c120 0 186 -64 186 -138zM665 549c0 44 -21 103 -109 103h-129c-43 0 -45 -3 -54 -38l-62 -248h146c122 0 208 95 208 183zM609 227c0 43 -19 117 -115 117h-189l-69 -279c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h136c118 0 207 97 207 196Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-3D" d="M722 347c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20zM722 153c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D460" d="M420 356c0 -39 -24 -56 -46 -56s-31 15 -31 29c0 22 20 44 48 45c-15 39 -65 46 -90 46c-88 0 -112 -61 -112 -90c0 -45 40 -52 76 -60c44 -9 73 -14 100 -42c12 -12 31 -37 31 -73c0 -45 -39 -166 -201 -166c-86 0 -143 40 -143 97c0 45 30 66 56 66c21 0 37 -12 37 -35 c0 -28 -25 -58 -63 -53c23 -53 100 -53 114 -53c120 0 143 84 143 110c0 55 -52 66 -104 76c-29 6 -103 21 -103 99c0 44 37 146 169 146c76 0 119 -41 119 -86Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2E" d="M192 53c0 -29 -24 -53 -53 -53s-53 24 -53 53s24 53 53 53s53 -24 53 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45D" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="503" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D434" x="893" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-7C" x="1643" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D435" x="1922" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="2681" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-3D" x="3348" y="0"></use>
<g transform="translate(4127,0)">
<g transform="translate(397,0)">
<rect stroke="none" width="1059" height="60" x="0" y="220"></rect>
<g transform="translate(63,682)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D460" x="0" y="0"></use>
<g transform="translate(469,-163)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D434" x="-236" y="0"></use>
</g>
</g>
<g transform="translate(60,-686)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D460" x="0" y="0"></use>
<g transform="translate(469,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D435" x="-236" y="0"></use>
</g>
</g>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2E" x="5704" y="0"></use>
</g>
</svg>
</div>
<p>

Because we are interested in the cost for rays passing through the 
node, we can use this result directly.  Thus, if we are considering
refining a region of space <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.743ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 750.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper A</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D434" d="M721 20c0 -20 -12 -20 -18 -20c-25 0 -88 3 -113 3c-41 0 -84 -3 -125 -3c0 0 -14 0 -14 11c0 20 10 20 24 20c20 0 72 3 72 33c0 10 -14 146 -16 167h-251c-68 -116 -69 -116 -76 -128c-8 -14 -14 -25 -14 -37c0 -25 24 -33 47 -35c7 0 16 -1 16 -12 c0 -19 -13 -19 -19 -19c-32 0 -67 3 -100 3c-28 0 -59 -3 -86 -3c-8 0 -13 5 -13 11c0 19 9 19 21 20c44 3 83 17 123 84l348 584c6 10 10 17 26 17c17 0 17 -4 19 -24l61 -625c3 -29 3 -36 65 -36c13 0 23 0 23 -11zM528 262l-32 330l-197 -330h229Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D434" x="0" y="0"></use>
</g>
</svg> such that there are two new subregions
with bounds <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.764ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 759.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper B</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D435" d="M756 545c0 -95 -105 -169 -209 -188c97 -11 155 -69 155 -141c0 -98 -118 -216 -276 -216h-357c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 10 20 29 20h336 c120 0 186 -64 186 -138zM665 549c0 44 -21 103 -109 103h-129c-43 0 -45 -3 -54 -38l-62 -248h146c122 0 208 95 208 183zM609 227c0 43 -19 117 -115 117h-189l-69 -279c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h136c118 0 207 97 207 196Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D435" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 760.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper C</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D436" d="M760 695l-63 -255c-5 -18 -5 -20 -18 -20c-4 0 -15 0 -15 10s3 11 3 51c0 116 -59 193 -161 193c-89 0 -183 -50 -244 -121c-100 -117 -121 -279 -121 -336c0 -156 106 -208 196 -208c52 0 115 17 184 73c69 58 92 129 101 158c2 8 7 10 13 10c0 0 12 0 12 -10 c0 -3 -17 -94 -110 -176c-53 -46 -129 -86 -216 -86c-153 0 -271 109 -271 274c0 232 225 453 448 453c111 0 157 -75 166 -89l70 77c11 11 12 12 15 12c9 0 11 -7 11 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D436" x="0" y="0"></use>
</g>
</svg> (Figure&nbsp;<a href="#fig:bvh-abc-probabilities">7.6</a>), the
probability that a ray passing through <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.743ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 750.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper A</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D434" d="M721 20c0 -20 -12 -20 -18 -20c-25 0 -88 3 -113 3c-41 0 -84 -3 -125 -3c0 0 -14 0 -14 11c0 20 10 20 24 20c20 0 72 3 72 33c0 10 -14 146 -16 167h-251c-68 -116 -69 -116 -76 -128c-8 -14 -14 -25 -14 -37c0 -25 24 -33 47 -35c7 0 16 -1 16 -12 c0 -19 -13 -19 -19 -19c-32 0 -67 3 -100 3c-28 0 -59 -3 -86 -3c-8 0 -13 5 -13 11c0 19 9 19 21 20c44 3 83 17 123 84l348 584c6 10 10 17 26 17c17 0 17 -4 19 -24l61 -625c3 -29 3 -36 65 -36c13 0 23 0 23 -11zM528 262l-32 330l-197 -330h229Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D434" x="0" y="0"></use>
</g>
</svg> will also pass through either of
the subregions is easily computed.

</p>
<p></p>
<span class="anchor" id="fig:bvh-abc-probabilities"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="pha07f06.svg" title=""><img src="pha07f06.svg" width=617 height=183 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 7.6: <span class="legend"> If a node of the bounding hierarchy with
surface area <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.555ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 1100.2 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">s Subscript upper A</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D460" d="M420 356c0 -39 -24 -56 -46 -56s-31 15 -31 29c0 22 20 44 48 45c-15 39 -65 46 -90 46c-88 0 -112 -61 -112 -90c0 -45 40 -52 76 -60c44 -9 73 -14 100 -42c12 -12 31 -37 31 -73c0 -45 -39 -166 -201 -166c-86 0 -143 40 -143 97c0 45 30 66 56 66c21 0 37 -12 37 -35 c0 -28 -25 -58 -63 -53c23 -53 100 -53 114 -53c120 0 143 84 143 110c0 55 -52 66 -104 76c-29 6 -103 21 -103 99c0 44 37 146 169 146c76 0 119 -41 119 -86Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D434" d="M721 20c0 -20 -12 -20 -18 -20c-25 0 -88 3 -113 3c-41 0 -84 -3 -125 -3c0 0 -14 0 -14 11c0 20 10 20 24 20c20 0 72 3 72 33c0 10 -14 146 -16 167h-251c-68 -116 -69 -116 -76 -128c-8 -14 -14 -25 -14 -37c0 -25 24 -33 47 -35c7 0 16 -1 16 -12 c0 -19 -13 -19 -19 -19c-32 0 -67 3 -100 3c-28 0 -59 -3 -86 -3c-8 0 -13 5 -13 11c0 19 9 19 21 20c44 3 83 17 123 84l348 584c6 10 10 17 26 17c17 0 17 -4 19 -24l61 -625c3 -29 3 -36 65 -36c13 0 23 0 23 -11zM528 262l-32 330l-197 -330h229Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D460" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D434" x="663" y="-230"></use>
</g>
</svg> is split into two children with surface areas <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.183ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 939.9 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">s Subscript upper B</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D460" d="M420 356c0 -39 -24 -56 -46 -56s-31 15 -31 29c0 22 20 44 48 45c-15 39 -65 46 -90 46c-88 0 -112 -61 -112 -90c0 -45 40 -52 76 -60c44 -9 73 -14 100 -42c12 -12 31 -37 31 -73c0 -45 -39 -166 -201 -166c-86 0 -143 40 -143 97c0 45 30 66 56 66c21 0 37 -12 37 -35 c0 -28 -25 -58 -63 -53c23 -53 100 -53 114 -53c120 0 143 84 143 110c0 55 -52 66 -104 76c-29 6 -103 21 -103 99c0 44 37 146 169 146c76 0 119 -41 119 -86Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D435" d="M756 545c0 -95 -105 -169 -209 -188c97 -11 155 -69 155 -141c0 -98 -118 -216 -276 -216h-357c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 10 20 29 20h336 c120 0 186 -64 186 -138zM665 549c0 44 -21 103 -109 103h-129c-43 0 -45 -3 -54 -38l-62 -248h146c122 0 208 95 208 183zM609 227c0 43 -19 117 -115 117h-189l-69 -279c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h136c118 0 207 97 207 196Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D460" x="0" y="0"></use>
<g transform="translate(469,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D435" x="-236" y="0"></use>
</g>
</g>
</svg> and
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.572ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 1107.3 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">s Subscript upper C</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D460" d="M420 356c0 -39 -24 -56 -46 -56s-31 15 -31 29c0 22 20 44 48 45c-15 39 -65 46 -90 46c-88 0 -112 -61 -112 -90c0 -45 40 -52 76 -60c44 -9 73 -14 100 -42c12 -12 31 -37 31 -73c0 -45 -39 -166 -201 -166c-86 0 -143 40 -143 97c0 45 30 66 56 66c21 0 37 -12 37 -35 c0 -28 -25 -58 -63 -53c23 -53 100 -53 114 -53c120 0 143 84 143 110c0 55 -52 66 -104 76c-29 6 -103 21 -103 99c0 44 37 146 169 146c76 0 119 -41 119 -86Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D436" d="M760 695l-63 -255c-5 -18 -5 -20 -18 -20c-4 0 -15 0 -15 10s3 11 3 51c0 116 -59 193 -161 193c-89 0 -183 -50 -244 -121c-100 -117 -121 -279 -121 -336c0 -156 106 -208 196 -208c52 0 115 17 184 73c69 58 92 129 101 158c2 8 7 10 13 10c0 0 12 0 12 -10 c0 -3 -17 -94 -110 -176c-53 -46 -129 -86 -216 -86c-153 0 -271 109 -271 274c0 232 225 453 448 453c111 0 157 -75 166 -89l70 77c11 11 12 12 15 12c9 0 11 -7 11 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D460" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D436" x="663" y="-219"></use>
</g>
</svg>, the probabilities that a ray passing through <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.743ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 750.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper A</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D434" d="M721 20c0 -20 -12 -20 -18 -20c-25 0 -88 3 -113 3c-41 0 -84 -3 -125 -3c0 0 -14 0 -14 11c0 20 10 20 24 20c20 0 72 3 72 33c0 10 -14 146 -16 167h-251c-68 -116 -69 -116 -76 -128c-8 -14 -14 -25 -14 -37c0 -25 24 -33 47 -35c7 0 16 -1 16 -12 c0 -19 -13 -19 -19 -19c-32 0 -67 3 -100 3c-28 0 -59 -3 -86 -3c-8 0 -13 5 -13 11c0 19 9 19 21 20c44 3 83 17 123 84l348 584c6 10 10 17 26 17c17 0 17 -4 19 -24l61 -625c3 -29 3 -36 65 -36c13 0 23 0 23 -11zM528 262l-32 330l-197 -330h229Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D434" x="0" y="0"></use>
</g>
</svg> also passes through
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.764ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 759.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper B</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D435" d="M756 545c0 -95 -105 -169 -209 -188c97 -11 155 -69 155 -141c0 -98 -118 -216 -276 -216h-357c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 10 20 29 20h336 c120 0 186 -64 186 -138zM665 549c0 44 -21 103 -109 103h-129c-43 0 -45 -3 -54 -38l-62 -248h146c122 0 208 95 208 183zM609 227c0 43 -19 117 -115 117h-189l-69 -279c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h136c118 0 207 97 207 196Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D435" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 760.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper C</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D436" d="M760 695l-63 -255c-5 -18 -5 -20 -18 -20c-4 0 -15 0 -15 10s3 11 3 51c0 116 -59 193 -161 193c-89 0 -183 -50 -244 -121c-100 -117 -121 -279 -121 -336c0 -156 106 -208 196 -208c52 0 115 17 184 73c69 58 92 129 101 158c2 8 7 10 13 10c0 0 12 0 12 -10 c0 -3 -17 -94 -110 -176c-53 -46 -129 -86 -216 -86c-153 0 -271 109 -271 274c0 232 225 453 448 453c111 0 157 -75 166 -89l70 77c11 11 12 12 15 12c9 0 11 -7 11 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D436" x="0" y="0"></use>
</g>
</svg> are given by <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.514ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2373.9 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">s Subscript upper B Baseline slash s Subscript upper A</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D460" d="M420 356c0 -39 -24 -56 -46 -56s-31 15 -31 29c0 22 20 44 48 45c-15 39 -65 46 -90 46c-88 0 -112 -61 -112 -90c0 -45 40 -52 76 -60c44 -9 73 -14 100 -42c12 -12 31 -37 31 -73c0 -45 -39 -166 -201 -166c-86 0 -143 40 -143 97c0 45 30 66 56 66c21 0 37 -12 37 -35 c0 -28 -25 -58 -63 -53c23 -53 100 -53 114 -53c120 0 143 84 143 110c0 55 -52 66 -104 76c-29 6 -103 21 -103 99c0 44 37 146 169 146c76 0 119 -41 119 -86Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D435" d="M756 545c0 -95 -105 -169 -209 -188c97 -11 155 -69 155 -141c0 -98 -118 -216 -276 -216h-357c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 10 20 29 20h336 c120 0 186 -64 186 -138zM665 549c0 44 -21 103 -109 103h-129c-43 0 -45 -3 -54 -38l-62 -248h146c122 0 208 95 208 183zM609 227c0 43 -19 117 -115 117h-189l-69 -279c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h136c118 0 207 97 207 196Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2F" d="M445 730c0 -2 0 -5 -1 -7l-349 -960c-3 -8 -10 -13 -19 -13c-11 0 -20 9 -20 20c0 2 0 5 1 7l349 960c3 8 10 13 19 13c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D434" d="M721 20c0 -20 -12 -20 -18 -20c-25 0 -88 3 -113 3c-41 0 -84 -3 -125 -3c0 0 -14 0 -14 11c0 20 10 20 24 20c20 0 72 3 72 33c0 10 -14 146 -16 167h-251c-68 -116 -69 -116 -76 -128c-8 -14 -14 -25 -14 -37c0 -25 24 -33 47 -35c7 0 16 -1 16 -12 c0 -19 -13 -19 -19 -19c-32 0 -67 3 -100 3c-28 0 -59 -3 -86 -3c-8 0 -13 5 -13 11c0 19 9 19 21 20c44 3 83 17 123 84l348 584c6 10 10 17 26 17c17 0 17 -4 19 -24l61 -625c3 -29 3 -36 65 -36c13 0 23 0 23 -11zM528 262l-32 330l-197 -330h229Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D460" x="0" y="0"></use>
<g transform="translate(469,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D435" x="-236" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2F" x="939" y="0"></use>
<g transform="translate(1440,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D460" x="0" y="0"></use>
<g transform="translate(469,-163)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D434" x="-236" y="0"></use>
</g>
</g>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.902ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2541.3 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">s Subscript upper C Baseline slash s Subscript upper A</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D460" d="M420 356c0 -39 -24 -56 -46 -56s-31 15 -31 29c0 22 20 44 48 45c-15 39 -65 46 -90 46c-88 0 -112 -61 -112 -90c0 -45 40 -52 76 -60c44 -9 73 -14 100 -42c12 -12 31 -37 31 -73c0 -45 -39 -166 -201 -166c-86 0 -143 40 -143 97c0 45 30 66 56 66c21 0 37 -12 37 -35 c0 -28 -25 -58 -63 -53c23 -53 100 -53 114 -53c120 0 143 84 143 110c0 55 -52 66 -104 76c-29 6 -103 21 -103 99c0 44 37 146 169 146c76 0 119 -41 119 -86Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D436" d="M760 695l-63 -255c-5 -18 -5 -20 -18 -20c-4 0 -15 0 -15 10s3 11 3 51c0 116 -59 193 -161 193c-89 0 -183 -50 -244 -121c-100 -117 -121 -279 -121 -336c0 -156 106 -208 196 -208c52 0 115 17 184 73c69 58 92 129 101 158c2 8 7 10 13 10c0 0 12 0 12 -10 c0 -3 -17 -94 -110 -176c-53 -46 -129 -86 -216 -86c-153 0 -271 109 -271 274c0 232 225 453 448 453c111 0 157 -75 166 -89l70 77c11 11 12 12 15 12c9 0 11 -7 11 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2F" d="M445 730c0 -2 0 -5 -1 -7l-349 -960c-3 -8 -10 -13 -19 -13c-11 0 -20 9 -20 20c0 2 0 5 1 7l349 960c3 8 10 13 19 13c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D434" d="M721 20c0 -20 -12 -20 -18 -20c-25 0 -88 3 -113 3c-41 0 -84 -3 -125 -3c0 0 -14 0 -14 11c0 20 10 20 24 20c20 0 72 3 72 33c0 10 -14 146 -16 167h-251c-68 -116 -69 -116 -76 -128c-8 -14 -14 -25 -14 -37c0 -25 24 -33 47 -35c7 0 16 -1 16 -12 c0 -19 -13 -19 -19 -19c-32 0 -67 3 -100 3c-28 0 -59 -3 -86 -3c-8 0 -13 5 -13 11c0 19 9 19 21 20c44 3 83 17 123 84l348 584c6 10 10 17 26 17c17 0 17 -4 19 -24l61 -625c3 -29 3 -36 65 -36c13 0 23 0 23 -11zM528 262l-32 330l-197 -330h229Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D460" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D436" x="663" y="-219"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2F" x="1107" y="0"></use>
<g transform="translate(1607,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D460" x="0" y="0"></use>
<g transform="translate(469,-163)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D434" x="-236" y="0"></use>
</g>
</g>
</g>
</svg>, respectively.</span>
</figcaption>
</div></div><p>


</p>
<p>

</p>
<p>When <tt>splitMethod</tt> has the value <tt>SplitMethod::SAH</tt>, the SAH is
used for building the BVH; a partition of the primitives along the chosen
axis that gives a minimal SAH cost estimate is found by considering a
number of candidate partitions.  (This is the default <tt>SplitMethod</tt>,
and it creates the most efficient hierarchies of the partitioning options.)  However, once it
has refined down to two primitives, the implementation
switches over to directly partitioning them in half.  The incremental
computational cost for applying the SAH at that point is not beneficial.

</p>
<p></p>
<span class="anchor" id="fragment-PartitionprimitivesusingapproximateSAH-0"></span><div class="fragmentname">&lt;&lt;Partition primitives using approximate SAH&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (bvhPrimitives.size() &lt;= 2) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Partitionprimitivesintoequallysizedsubsets-0">Partition primitives into equally sized subsets</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1071" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1071"><i></i></a><div id="fragbit-1071" class="collapse show"><div class="fragmentcode">       mid = bvhPrimitives.size() / 2;
       std::nth_element(bvhPrimitives.begin(), bvhPrimitives.begin() + mid, 
                        bvhPrimitives.end(),
           [dim](const BVHPrimitive &amp;a, const BVHPrimitive &amp;b) { 
               return a.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim] &lt; b.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>()[dim];
           });</div></div>
} else {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-AllocatemonoBVHSplitBucketforSAHpartitionbuckets-0">Allocate <tt>BVHSplitBucket</tt> for SAH partition buckets</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1072" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1072"><i></i></a><div id="fragbit-1072" class="collapse show"><div class="fragmentcode">       constexpr int nBuckets = 12;
       BVHSplitBucket buckets[nBuckets];</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonoBVHSplitBucketforSAHpartitionbuckets-0">Initialize <tt>BVHSplitBucket</tt> for SAH partition buckets</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1073" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1073"><i></i></a><div id="fragbit-1073" class="collapse show"><div class="fragmentcode">       for (const auto &amp;prim : bvhPrimitives) {
           int b = nBuckets * centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Offset" class="code">Offset</a>(prim.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>())[dim];
           if (b == nBuckets) b = nBuckets - 1;
           buckets[b].<a href="#BVHSplitBucket::count" class="code">count</a>++;
           buckets[b].<a href="#BVHPrimitive::bounds" class="code">bounds</a> = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(buckets[b].<a href="#BVHPrimitive::bounds" class="code">bounds</a>, prim.<a href="#BVHPrimitive::bounds" class="code">bounds</a>);
       }</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Computecostsforsplittingaftereachbucket-0">Compute costs for splitting after each bucket</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1074" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1074"><i></i></a><div id="fragbit-1074" class="collapse show"><div class="fragmentcode">       constexpr int nSplits = nBuckets - 1;
       Float costs[nSplits] = {};
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Partiallyinitializemonocostsusingaforwardscanoversplits-0">Partially initialize <tt>costs</tt> using a forward scan over splits</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1075" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1075"><i></i></a><div id="fragbit-1075" class="collapse show"><div class="fragmentcode">          int countBelow = 0;
          <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> boundBelow;
          for (int i = 0; i &lt; nSplits; ++i) {
              boundBelow = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(boundBelow, buckets[i].bounds);
              countBelow += buckets[i].count;
              costs[i] += countBelow * boundBelow.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();
          }</div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Finishinitializingmonocostsusingabackwardscanoversplits-0">Finish initializing <tt>costs</tt> using a backward scan over splits</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1076" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1076"><i></i></a><div id="fragbit-1076" class="collapse show"><div class="fragmentcode">          int countAbove = 0;
          <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> boundAbove;
          for (int i = nSplits; i &gt;= 1; --i) {
              boundAbove = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(boundAbove, buckets[i].bounds);
              countAbove += buckets[i].count;
              costs[i - 1] += countAbove * boundAbove.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();
          }</div></div></div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-FindbuckettosplitatthatminimizesSAHmetric-0">Find bucket to split at that minimizes SAH metric</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1077" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1077"><i></i></a><div id="fragbit-1077" class="collapse show"><div class="fragmentcode">       int minCostSplitBucket = -1;
       Float minCost = Infinity;
       for (int i = 0; i &lt; nSplits; ++i) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Computecostforcandidatesplitandupdateminimumifnecessary-0">Compute cost for candidate split and update minimum if necessary</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1078" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1078"><i></i></a><div id="fragbit-1078" class="collapse show"><div class="fragmentcode">              if (costs[i] &lt; minCost) {
                  minCost = costs[i];
                  minCostSplitBucket = i;
              }</div></div>
       }
       &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputeleafcostandSAHsplitcostforchosensplit-0">Compute leaf cost and SAH split cost for chosen split</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1079" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1079"><i></i></a><div id="fragbit-1079" class="collapse show"><div class="fragmentcode">          Float leafCost = bvhPrimitives.size();
          minCost = 1.f / 2.f + minCost / bounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();</div></div></div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-EithercreateleaforsplitprimitivesatselectedSAHbucket-0">Either create leaf or split primitives at selected SAH bucket</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1080" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1080"><i></i></a><div id="fragbit-1080" class="collapse show"><div class="fragmentcode">       if (bvhPrimitives.size() &gt; <a href="#BVHAggregate::maxPrimsInNode" class="code">maxPrimsInNode</a> || minCost &lt; leafCost) {
           auto midIter = std::partition(bvhPrimitives.begin(),
               bvhPrimitives.end(),
               [=](const BVHPrimitive &amp;bp) {
                   int b = nBuckets * centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Offset" class="code">Offset</a>(bp.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>())[dim];
                   if (b == nBuckets) b = nBuckets - 1;
                   return b &lt;= minCostSplitBucket;
               });
           mid = midIter - bvhPrimitives.begin();
       } else {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-CreateleafmonoBVHBuildNode-0">Create leaf <tt>BVHBuildNode</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1081" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1081"><i></i></a><div id="fragbit-1081" class="collapse show"><div class="fragmentcode">              int firstPrimOffset = orderedPrimsOffset-&gt;fetch_add(bvhPrimitives.size());
              for (size_t i = 0; i &lt; bvhPrimitives.size(); ++i) {
                  int index = bvhPrimitives[i].<a href="#BVHPrimitive::primitiveIndex" class="code">primitiveIndex</a>;
                  orderedPrims[firstPrimOffset + i] = primitives[index];
              }
              node-&gt;<a href="#BVHBuildNode::InitLeaf" class="code">InitLeaf</a>(firstPrimOffset, bvhPrimitives.size(), bounds);
              return node;</div></div>
       }</div></div>
}</div><p>


</p>
<p>Rather than exhaustively considering all <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.557ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 1101 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">2 n</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="500" y="0"></use>
</g>
</svg> possible partitions along the
axis, computing the SAH for each to select the best, the implementation
here instead divides the range along the axis into a small number of
buckets of equal extent.  It then only considers partitions at bucket
boundaries.  This approach is more efficient than considering all
partitions while usually still producing partitions that are nearly as
effective.  This idea is illustrated in Figure&nbsp;<a href="#fig:bvh-sah-buckets">7.7</a>.

</p>
<p></p>
<span class="anchor" id="fig:bvh-sah-buckets"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="pha07f07.svg" title=""><img src="pha07f07.svg" width=458 height=281 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 7.7: Choosing a Splitting Plane with the Surface Area Heuristic for
  BVHs. <span class="legend"> The projected extent of primitive bounds centroids is
  projected onto the chosen split axis.  Each primitive is placed in a
  bucket along the axis based on the centroid of its bounds.  The
  implementation then estimates the cost for splitting the primitives using
  the planes at each of the bucket boundaries (solid vertical lines); whichever
  one gives the minimum cost per the surface area heuristic is
  selected.
</span>
</figcaption>
</div></div><p>


</p>
<p></p>
<span class="anchor" id="fragment-BVHSplitBucketDefinition-0"></span><div class="fragmentname">&lt;&lt;BVHSplitBucket Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">struct <span class="anchor" id="BVHSplitBucket"></span>BVHSplitBucket {
    int <span class="anchor" id="BVHSplitBucket::count"></span>count = 0;
    <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> <span class="anchor" id="BVHSplitBucket::bounds"></span>bounds;
};</div><p>


</p>
<p>We have found that 12 buckets usually work well in practice.  An 
improvement may be to increase this value when there are many primitives
and to decrease it when there are few.

</p>
<p></p>
<span class="anchor" id="fragment-AllocatemonoBVHSplitBucketforSAHpartitionbuckets-0"></span><div class="fragmentname">&lt;&lt;Allocate <tt>BVHSplitBucket</tt> for SAH partition buckets&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">constexpr int nBuckets = 12;
BVHSplitBucket buckets[nBuckets];</div><p>


</p>
<p>For each primitive, the following fragment determines the
bucket that its centroid lies in and updates the bucket&rsquo;s bounds to include
the primitive&rsquo;s bounds.

</p>
<p></p>
<span class="anchor" id="fragment-InitializemonoBVHSplitBucketforSAHpartitionbuckets-0"></span><div class="fragmentname">&lt;&lt;Initialize <tt>BVHSplitBucket</tt> for SAH partition buckets&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">for (const auto &amp;prim : bvhPrimitives) {
    int b = nBuckets * centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Offset" class="code">Offset</a>(prim.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>())[dim];
    if (b == nBuckets) b = nBuckets - 1;
    buckets[b].<a href="#BVHSplitBucket::count" class="code">count</a>++;
    buckets[b].<a href="#BVHPrimitive::bounds" class="code">bounds</a> = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(buckets[b].<a href="#BVHPrimitive::bounds" class="code">bounds</a>, prim.<a href="#BVHPrimitive::bounds" class="code">bounds</a>);
}</div><p>


</p>
<p>For each bucket, we now have a count of the number of primitives and the
bounds of all of their respective bounding boxes.  We want to use the SAH
to estimate the cost of splitting at each of the bucket boundaries.  The
fragment below loops over all the buckets and initializes the
<tt>cost[i]</tt> array to store the estimated SAH cost for splitting after
the <tt>i</tt>th bucket.  (It does not consider a split after the last
bucket, which by definition would not split the primitives.)

</p>
<p>We arbitrarily set the estimated intersection cost to&nbsp;1, and then set the
estimated traversal cost to <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.487ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 1501.5 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">1 slash 2</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2F" d="M445 730c0 -2 0 -5 -1 -7l-349 -960c-3 -8 -10 -13 -19 -13c-11 0 -20 9 -20 20c0 2 0 5 1 7l349 960c3 8 10 13 19 13c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2F" x="500" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="1001" y="0"></use>
</g>
</svg>.  (One of the two of them can always be
set to&nbsp;1 since it is the relative, rather than absolute, magnitudes of the
estimated traversal and intersection costs that determine their effect.)
However, not only is the absolute amount of computation necessary for node traversal&mdash;a
ray&ndash;bounding box intersection&mdash;much less than the amount of
computation needed to intersect a ray with a shape, the full cost of a
shape intersection test is even higher.  It includes the overhead of at
least two instances of dynamic dispatch (one or more via
<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive"><tt>Primitive</tt></a>s and one via a <tt>Shape</tt>), the cost of
computing all the geometric information needed to initialize a
<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction"><tt>SurfaceInteraction</tt></a> if an intersection is found, and any resulting
costs from possibly applying additional transformations and interpolating animated
transformations.

</p>
<p>We have intentionally underestimated the performance ratio between these
two costs because the raw amount of computation each performs does not
measure their full expense.  With a lower traversal cost, the resulting
BVHs would be deeper and require more nodes.  For complex scenes, this
additional memory use may be undesirable.  Even for simpler scenes, visiting more
nodes when a ray is traced will generally incur the cost of cache misses,
which not only may reduce performance for that ray, but may harm future
performance from displacing other useful data from the cache.  We have
found the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.262ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 1835.1 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">2 colon 1</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-3A" d="M192 378c0 -29 -24 -53 -53 -53s-53 24 -53 53s24 53 53 53s53 -24 53 -53zM192 53c0 -29 -24 -53 -53 -53s-53 24 -53 53s24 53 53 53s53 -24 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-3A" x="778" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="1334" y="0"></use>
</g>
</svg> ratio that we have used here to make a reasonable trade-off
between all of these issues.

</p>
<p>In order to be able to choose a split in linear time, the implementation
first performs a forward scan over the buckets and then a backward scan
over the buckets that incrementally compute each bucket&rsquo;s


cost.<button style="button" data-toggle="tooltip" data-placement="right" data-html="true" class="btn footnote-button" title="Previous versions of <tt>pbrt</tt> instead computed these values
from scratch for each candidate split, which resulted in <i>O</i>(<i>n</i><sup>2</sup>)
performance.  Even with the small <i>n</i> here, we have found that this
implementation speeds up BVH construction by approximately 2&times;.">
      <sup>&dagger;</sup>
    </button>
		

There is one fewer candidate split than the number of
buckets, since all splits are between pairs of buckets.

</p>
<p></p>
<span class="anchor" id="fragment-Computecostsforsplittingaftereachbucket-0"></span><div class="fragmentname">&lt;&lt;Compute costs for splitting after each bucket&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">constexpr int nSplits = nBuckets - 1;
Float costs[nSplits] = {};
&lt;&lt;<span class="fragmentname"><a href="#fragment-Partiallyinitializemonocostsusingaforwardscanoversplits-0">Partially initialize <tt>costs</tt> using a forward scan over splits</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1082" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1082"><i></i></a><div id="fragbit-1082" class="collapse show"><div class="fragmentcode">   int countBelow = 0;
   <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> boundBelow;
   for (int i = 0; i &lt; nSplits; ++i) {
       boundBelow = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(boundBelow, buckets[i].bounds);
       countBelow += buckets[i].count;
       costs[i] += countBelow * boundBelow.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();
   }</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Finishinitializingmonocostsusingabackwardscanoversplits-0">Finish initializing <tt>costs</tt> using a backward scan over splits</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1083" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1083"><i></i></a><div id="fragbit-1083" class="collapse show"><div class="fragmentcode">   int countAbove = 0;
   <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> boundAbove;
   for (int i = nSplits; i &gt;= 1; --i) {
       boundAbove = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(boundAbove, buckets[i].bounds);
       countAbove += buckets[i].count;
       costs[i - 1] += countAbove * boundAbove.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();
   }</div></div></div><p>


</p>
<p>The loop invariant is that <tt>countBelow</tt> stores the number of primitives that are
below the corresponding candidate split, and <tt>boundsBelow</tt> stores
their bounds.  With these values in hand, the value of the first sum in
Equation&nbsp;(<a href="#eq:sah">7.1</a>) can be evaluated for each split.

</p>
<p></p>
<span class="anchor" id="fragment-Partiallyinitializemonocostsusingaforwardscanoversplits-0"></span><div class="fragmentname">&lt;&lt;Partially initialize <tt>costs</tt> using a forward scan over splits&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int countBelow = 0;
<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> boundBelow;
for (int i = 0; i &lt; nSplits; ++i) {
    boundBelow = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(boundBelow, buckets[i].bounds);
    countBelow += buckets[i].count;
    costs[i] += countBelow * boundBelow.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();
}</div><p>


</p>
<p>A similar backward scan over the buckets finishes initializing the
<tt>costs</tt> array.

</p>
<p></p>
<span class="anchor" id="fragment-Finishinitializingmonocostsusingabackwardscanoversplits-0"></span><div class="fragmentname">&lt;&lt;Finish initializing <tt>costs</tt> using a backward scan over splits&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int countAbove = 0;
<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> boundAbove;
for (int i = nSplits; i &gt;= 1; --i) {
    boundAbove = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(boundAbove, buckets[i].bounds);
    countAbove += buckets[i].count;
    costs[i - 1] += countAbove * boundAbove.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();
}</div><p>


</p>
<p>Given all the costs, a linear search over the potential splits finds the
partition with minimum cost.

</p>
<p></p>
<span class="anchor" id="fragment-FindbuckettosplitatthatminimizesSAHmetric-0"></span><div class="fragmentname">&lt;&lt;Find bucket to split at that minimizes SAH metric&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int minCostSplitBucket = -1;
Float minCost = Infinity;
for (int i = 0; i &lt; nSplits; ++i) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Computecostforcandidatesplitandupdateminimumifnecessary-0">Compute cost for candidate split and update minimum if necessary</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1084" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1084"><i></i></a><div id="fragbit-1084" class="collapse show"><div class="fragmentcode">       if (costs[i] &lt; minCost) {
           minCost = costs[i];
           minCostSplitBucket = i;
       }</div></div>
}
&lt;&lt;<span class="fragmentname"><a href="#fragment-ComputeleafcostandSAHsplitcostforchosensplit-0">Compute leaf cost and SAH split cost for chosen split</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1085" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1085"><i></i></a><div id="fragbit-1085" class="collapse show"><div class="fragmentcode">   Float leafCost = bvhPrimitives.size();
   minCost = 1.f / 2.f + minCost / bounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();</div></div></div><p>


</p>
<p>To find the best split, we evaluate a simplified version of Equation
(<a href="#eq:sah">7.1</a>), neglecting the traversal cost and the division by the
surface area of the bounding box of all the primitives to compute the
probabilities <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.32ex" height="2.009ex" style="vertical-align: -0.671ex; margin-left: -0.073ex;" viewBox="-31.5 -576.1 999 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">p Subscript upper A</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45D" d="M490 282c0 -147 -125 -293 -241 -293c-51 0 -79 35 -92 64c-7 -25 -49 -188 -49 -200c0 -9 0 -16 50 -16c14 0 24 0 24 -11c0 -20 -13 -20 -18 -20c-32 0 -66 3 -99 3c-28 0 -57 -3 -84 -3c-8 0 -13 4 -13 12c0 19 11 19 23 19c44 0 46 7 54 41l112 445c4 17 7 28 7 51 c0 38 -14 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 3 13 63 31 97c9 18 28 57 74 57c37 0 80 -21 90 -75c33 39 81 75 131 75c76 0 133 -66 133 -160zM418 326c0 59 -24 94 -64 94c-17 0 -46 -7 -81 -38c-18 -15 -45 -43 -52 -70 l-49 -196c-3 -12 -3 -16 -3 -16c0 -6 13 -89 79 -89c37 0 85 33 119 103c18 38 51 153 51 212Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D434" d="M721 20c0 -20 -12 -20 -18 -20c-25 0 -88 3 -113 3c-41 0 -84 -3 -125 -3c0 0 -14 0 -14 11c0 20 10 20 24 20c20 0 72 3 72 33c0 10 -14 146 -16 167h-251c-68 -116 -69 -116 -76 -128c-8 -14 -14 -25 -14 -37c0 -25 24 -33 47 -35c7 0 16 -1 16 -12 c0 -19 -13 -19 -19 -19c-32 0 -67 3 -100 3c-28 0 -59 -3 -86 -3c-8 0 -13 5 -13 11c0 19 9 19 21 20c44 3 83 17 123 84l348 584c6 10 10 17 26 17c17 0 17 -4 19 -24l61 -625c3 -29 3 -36 65 -36c13 0 23 0 23 -11zM528 262l-32 330l-197 -330h229Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45D" x="0" y="0"></use>
<g transform="translate(503,-163)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D434" x="-236" y="0"></use>
</g>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.335ex" height="2.009ex" style="vertical-align: -0.671ex; margin-left: -0.073ex;" viewBox="-31.5 -576.1 1005.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">p Subscript upper B</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45D" d="M490 282c0 -147 -125 -293 -241 -293c-51 0 -79 35 -92 64c-7 -25 -49 -188 -49 -200c0 -9 0 -16 50 -16c14 0 24 0 24 -11c0 -20 -13 -20 -18 -20c-32 0 -66 3 -99 3c-28 0 -57 -3 -84 -3c-8 0 -13 4 -13 12c0 19 11 19 23 19c44 0 46 7 54 41l112 445c4 17 7 28 7 51 c0 38 -14 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 3 13 63 31 97c9 18 28 57 74 57c37 0 80 -21 90 -75c33 39 81 75 131 75c76 0 133 -66 133 -160zM418 326c0 59 -24 94 -64 94c-17 0 -46 -7 -81 -38c-18 -15 -45 -43 -52 -70 l-49 -196c-3 -12 -3 -16 -3 -16c0 -6 13 -89 79 -89c37 0 85 33 119 103c18 38 51 153 51 212Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D435" d="M756 545c0 -95 -105 -169 -209 -188c97 -11 155 -69 155 -141c0 -98 -118 -216 -276 -216h-357c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 10 20 29 20h336 c120 0 186 -64 186 -138zM665 549c0 44 -21 103 -109 103h-129c-43 0 -45 -3 -54 -38l-62 -248h146c122 0 208 95 208 183zM609 227c0 43 -19 117 -115 117h-189l-69 -279c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h136c118 0 207 97 207 196Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45D" x="0" y="0"></use>
<g transform="translate(503,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D435" x="-236" y="0"></use>
</g>
</g>
</svg>; these have no effect on the choice of the
best split.  That cost is precisely what is stored in <tt>costs</tt>, so the
split with minimum cost is easily found.

</p>
<p></p>
<span class="anchor" id="fragment-Computecostforcandidatesplitandupdateminimumifnecessary-0"></span><div class="fragmentname">&lt;&lt;Compute cost for candidate split and update minimum if necessary&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (costs[i] &lt; minCost) {
    minCost = costs[i];
    minCostSplitBucket = i;
}</div><p>


</p>
<p>To compute the final SAH cost for a split, we need to divide by the surface
area of the overall bounding box to compute the probabilities <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.32ex" height="2.009ex" style="vertical-align: -0.671ex; margin-left: -0.073ex;" viewBox="-31.5 -576.1 999 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">p Subscript upper A</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45D" d="M490 282c0 -147 -125 -293 -241 -293c-51 0 -79 35 -92 64c-7 -25 -49 -188 -49 -200c0 -9 0 -16 50 -16c14 0 24 0 24 -11c0 -20 -13 -20 -18 -20c-32 0 -66 3 -99 3c-28 0 -57 -3 -84 -3c-8 0 -13 4 -13 12c0 19 11 19 23 19c44 0 46 7 54 41l112 445c4 17 7 28 7 51 c0 38 -14 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 3 13 63 31 97c9 18 28 57 74 57c37 0 80 -21 90 -75c33 39 81 75 131 75c76 0 133 -66 133 -160zM418 326c0 59 -24 94 -64 94c-17 0 -46 -7 -81 -38c-18 -15 -45 -43 -52 -70 l-49 -196c-3 -12 -3 -16 -3 -16c0 -6 13 -89 79 -89c37 0 85 33 119 103c18 38 51 153 51 212Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D434" d="M721 20c0 -20 -12 -20 -18 -20c-25 0 -88 3 -113 3c-41 0 -84 -3 -125 -3c0 0 -14 0 -14 11c0 20 10 20 24 20c20 0 72 3 72 33c0 10 -14 146 -16 167h-251c-68 -116 -69 -116 -76 -128c-8 -14 -14 -25 -14 -37c0 -25 24 -33 47 -35c7 0 16 -1 16 -12 c0 -19 -13 -19 -19 -19c-32 0 -67 3 -100 3c-28 0 -59 -3 -86 -3c-8 0 -13 5 -13 11c0 19 9 19 21 20c44 3 83 17 123 84l348 584c6 10 10 17 26 17c17 0 17 -4 19 -24l61 -625c3 -29 3 -36 65 -36c13 0 23 0 23 -11zM528 262l-32 330l-197 -330h229Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45D" x="0" y="0"></use>
<g transform="translate(503,-163)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D434" x="-236" y="0"></use>
</g>
</g>
</svg> and
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.335ex" height="2.009ex" style="vertical-align: -0.671ex; margin-left: -0.073ex;" viewBox="-31.5 -576.1 1005.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">p Subscript upper B</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45D" d="M490 282c0 -147 -125 -293 -241 -293c-51 0 -79 35 -92 64c-7 -25 -49 -188 -49 -200c0 -9 0 -16 50 -16c14 0 24 0 24 -11c0 -20 -13 -20 -18 -20c-32 0 -66 3 -99 3c-28 0 -57 -3 -84 -3c-8 0 -13 4 -13 12c0 19 11 19 23 19c44 0 46 7 54 41l112 445c4 17 7 28 7 51 c0 38 -14 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 3 13 63 31 97c9 18 28 57 74 57c37 0 80 -21 90 -75c33 39 81 75 131 75c76 0 133 -66 133 -160zM418 326c0 59 -24 94 -64 94c-17 0 -46 -7 -81 -38c-18 -15 -45 -43 -52 -70 l-49 -196c-3 -12 -3 -16 -3 -16c0 -6 13 -89 79 -89c37 0 85 33 119 103c18 38 51 153 51 212Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D435" d="M756 545c0 -95 -105 -169 -209 -188c97 -11 155 -69 155 -141c0 -98 -118 -216 -276 -216h-357c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 10 20 29 20h336 c120 0 186 -64 186 -138zM665 549c0 44 -21 103 -109 103h-129c-43 0 -45 -3 -54 -38l-62 -248h146c122 0 208 95 208 183zM609 227c0 43 -19 117 -115 117h-189l-69 -279c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h136c118 0 207 97 207 196Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45D" x="0" y="0"></use>
<g transform="translate(503,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D435" x="-236" y="0"></use>
</g>
</g>
</svg> before adding the estimated traversal cost, <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.487ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 1501.5 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">1 slash 2</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2F" d="M445 730c0 -2 0 -5 -1 -7l-349 -960c-3 -8 -10 -13 -19 -13c-11 0 -20 9 -20 20c0 2 0 5 1 7l349 960c3 8 10 13 19 13c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2F" x="500" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="1001" y="0"></use>
</g>
</svg>.  Because we set
the estimated intersection cost to&nbsp;1 previously, the estimated cost for
just creating a leaf node is equal to the number of primitives.

</p>
<p></p>
<span class="anchor" id="fragment-ComputeleafcostandSAHsplitcostforchosensplit-0"></span><div class="fragmentname">&lt;&lt;Compute leaf cost and SAH split cost for chosen split&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">Float leafCost = bvhPrimitives.size();
minCost = 1.f / 2.f + minCost / bounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();</div><p>


</p>
<p>If the chosen bucket boundary for partitioning has a lower estimated cost
than building a node with the existing primitives or if more than the
maximum number of primitives allowed in a node is present, the
<tt>std::partition()</tt> function is used to do the work of reordering nodes
in the <tt>bvhPrimitives</tt> array.  Recall from its use earlier that it
ensures that all elements of the array that return <tt>true</tt>
from the given predicate appear before those that return <tt>false</tt> and
that it returns a pointer to the first element where the predicate returns
<tt>false</tt>.  

</p>
<p></p>
<span class="anchor" id="fragment-EithercreateleaforsplitprimitivesatselectedSAHbucket-0"></span><div class="fragmentname">&lt;&lt;Either create leaf or split primitives at selected SAH bucket&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (bvhPrimitives.size() &gt; <a href="#BVHAggregate::maxPrimsInNode" class="code">maxPrimsInNode</a> || minCost &lt; leafCost) {
    auto midIter = std::partition(bvhPrimitives.begin(),
        bvhPrimitives.end(),
        [=](const BVHPrimitive &amp;bp) {
            int b = nBuckets * centroidBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Offset" class="code">Offset</a>(bp.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>())[dim];
            if (b == nBuckets) b = nBuckets - 1;
            return b &lt;= minCostSplitBucket;
        });
    mid = midIter - bvhPrimitives.begin();
} else {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-CreateleafmonoBVHBuildNode-0">Create leaf <tt>BVHBuildNode</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1086" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1086"><i></i></a><div id="fragbit-1086" class="collapse show"><div class="fragmentcode">       int firstPrimOffset = orderedPrimsOffset-&gt;fetch_add(bvhPrimitives.size());
       for (size_t i = 0; i &lt; bvhPrimitives.size(); ++i) {
           int index = bvhPrimitives[i].<a href="#BVHPrimitive::primitiveIndex" class="code">primitiveIndex</a>;
           orderedPrims[firstPrimOffset + i] = primitives[index];
       }
       node-&gt;<a href="#BVHBuildNode::InitLeaf" class="code">InitLeaf</a>(firstPrimOffset, bvhPrimitives.size(), bounds);
       return node;</div></div>
}</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#LinearBoundingVolumeHierarchies"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:hlbvh"></span><span id="LinearBoundingVolumeHierarchies"></span><h3>7.3.3  Linear Bounding Volume Hierarchies</h3><p>



</p>
<p>While building bounding volume hierarchies using the surface area heuristic
gives very good results, that approach does have two disadvantages: first,
many passes are taken over the scene primitives to compute the SAH costs at
all the levels of the tree.  Second, top-down BVH construction is
difficult to parallelize well: the approach used in
<tt>buildRecursive()</tt>&mdash;performing parallel construction of independent
subtrees&mdash;suffers from limited independent work until the top few levels
of the tree have been built, which in turn inhibits parallel scalability.
(This second issue is particularly an issue on GPUs, which perform poorly
if massive parallelism is not available.)

</p>
<p><em>Linear bounding volume hierarchies</em> (LBVHs) were developed to address
these issues.  With LBVHs, the tree is built with a small number of
lightweight passes over the primitives; tree construction time is linear in
the number of primitives.  Further, the algorithm quickly partitions the
primitives into clusters that can be processed independently.  This
processing can be fairly easily parallelized and is well suited to GPU
implementation.

</p>
<p>The key idea behind LBVHs is to turn BVH construction into a sorting
problem.  Because there is no single ordering function for sorting
multidimensional data, LBVHs are based on <em>Morton codes</em>, which
map nearby points in <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 600.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
</g>
</svg> dimensions to nearby points along the 1D line,
where there is an obvious ordering function.  After the primitives have
been sorted, spatially nearby clusters of primitives are in contiguous
segments of the sorted array.

</p>
<p>Morton codes are based on a simple transformation: given <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 600.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
</g>
</svg>-dimensional
integer coordinate values, their Morton-coded representation is found by
interleaving the bits of the coordinates in base 2.  For example, consider
a 2D coordinate <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.312ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2287.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis x comma y right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="389" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="962" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="1407" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="1897" y="0"></use>
</g>
</svg> where the bits of <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg> are denoted by <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.129ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 916.8 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x Subscript i</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D456" d="M284 625c0 -30 -30 -53 -53 -53c-24 0 -38 17 -38 36c0 27 27 53 54 53c23 0 37 -16 37 -36zM293 143c0 -9 -37 -154 -131 -154c-48 0 -82 35 -82 82c0 21 13 54 23 80c16 43 61 159 69 185c4 10 11 31 11 52c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124 c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -13 -53c-10 -27 -10 -29 -22 -58l-39 -105c-23 -61 -29 -75 -29 -100c0 -23 7 -33 24 -33c51 0 84 61 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D456" x="809" y="-213"></use>
</g>
</svg>
and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.939ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 834.8 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y Subscript i</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D456" d="M284 625c0 -30 -30 -53 -53 -53c-24 0 -38 17 -38 36c0 27 27 53 54 53c23 0 37 -16 37 -36zM293 143c0 -9 -37 -154 -131 -154c-48 0 -82 35 -82 82c0 21 13 54 23 80c16 43 61 159 69 185c4 10 11 31 11 52c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124 c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -13 -53c-10 -27 -10 -29 -22 -58l-39 -105c-23 -61 -29 -75 -29 -100c0 -23 7 -33 24 -33c51 0 84 61 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D456" x="693" y="-213"></use>
</g>
</svg>.  The corresponding Morton-coded value is
</p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">
<div class="displaymath"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="23.857ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 10271.6 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">midline-horizontal-ellipsis y 3 x 3 y 2 x 2 y 1 x 1 y 0 x 0 period</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-22EF" d="M162 250c0 -29 -24 -53 -53 -53s-53 24 -53 53s24 53 53 53s53 -24 53 -53zM441 250c0 -29 -24 -53 -53 -53s-53 24 -53 53s24 53 53 53s53 -24 53 -53zM720 250c0 -29 -24 -53 -53 -53s-53 24 -53 53s24 53 53 53s53 -24 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-33" d="M457 171c0 -102 -91 -193 -213 -193c-109 0 -202 66 -202 157c0 44 32 58 56 58c29 0 56 -20 56 -56c0 -38 -31 -60 -66 -55c35 -59 110 -76 153 -76c44 0 113 29 113 165c0 98 -37 166 -119 166h-44c-17 0 -24 0 -24 11c0 10 7 11 15 12c7 0 31 2 39 3c25 1 59 4 89 52 c26 44 28 102 28 114c0 90 -55 112 -96 112c-36 0 -102 -13 -133 -62c15 0 62 0 62 -50c0 -29 -20 -51 -51 -51c-29 0 -51 19 -51 52c0 76 76 136 177 136c96 0 184 -56 184 -138c0 -79 -58 -149 -140 -176c104 -21 167 -99 167 -181Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2E" d="M192 53c0 -29 -24 -53 -53 -53s-53 24 -53 53s24 53 53 53s53 -24 53 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-22EF" x="0" y="0"></use>
<g transform="translate(943,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-33" x="693" y="-213"></use>
</g>
<g transform="translate(2054,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-33" x="809" y="-213"></use>
</g>
<g transform="translate(3247,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-32" x="693" y="-213"></use>
</g>
<g transform="translate(4358,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-32" x="809" y="-213"></use>
</g>
<g transform="translate(5551,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="693" y="-213"></use>
</g>
<g transform="translate(6662,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="809" y="-213"></use>
</g>
<g transform="translate(7855,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-30" x="693" y="-213"></use>
</g>
<g transform="translate(8966,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-30" x="809" y="-213"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2E" x="9993" y="0"></use>
</g>
</svg>
</div>
<p>


</p>
<p>Figure&nbsp;<a href="#fig:morton-curve-basics">7.8</a> shows a plot of the 2D points in
Morton order&mdash;note that they are visited along a path that follows a
reversed &ldquo;z&rdquo; shape.  (The Morton path is sometimes called &ldquo;z-order&rdquo; for
this reason.)  We can see that points with coordinates that are close
together in 2D are generally close together along the Morton
curve.<button style="button" data-toggle="tooltip" data-placement="right" data-html="true" class="btn footnote-button" title="Many GPUs store texture images in memory using a Morton
layout.  One advantage of doing so is that when performing bilinear
interpolation between four texel values, the values are much more likely to
be close together in memory than if the texture is laid out in scanline
order.  In turn, texture cache performance benefits.">
      <sup>&dagger;</sup>
    </button>
		

</p>
<p></p>
<span class="anchor" id="fig:morton-curve-basics"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="pha07f08.svg" title=""><img src="pha07f08.svg" width=241 height=238 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 7.8: The Order That Points Are Visited along the Morton Curve. <span class="legend">
  Coordinate values along the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg> axes are shown in binary.  If we
  connect the integer coordinate points in the order of their
  Morton indices, we see that the Morton curve visits the points along a
  hierarchical &ldquo;z&rdquo;-shaped path.
</span>
</figcaption>
</div></div><p>


</p>
<p>A Morton-encoded value also encodes useful information about the position
of the point that it represents.  Consider the case of 4-bit coordinate
values in 2D: the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg> coordinates are integers in <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.815ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2503.7 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-bracket 0 comma 15 right-bracket</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-5B" d="M256 -230c0 -11 -9 -20 -20 -20h-122v1000h122c11 0 20 -9 20 -20s-9 -20 -20 -20h-82v-920h82c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-35" d="M449 201c0 -127 -102 -223 -218 -223c-112 0 -181 97 -181 183c0 46 35 53 49 53c33 0 50 -25 50 -49s-17 -49 -50 -49c-11 0 -14 1 -17 2c17 -59 74 -112 147 -112c46 0 83 26 107 65c24 42 24 102 24 137c0 50 -2 89 -18 126c-8 18 -33 64 -85 64 c-81 0 -118 -54 -129 -70c-4 -6 -6 -9 -13 -9c-14 0 -14 8 -14 26v296c0 16 0 24 10 24c0 0 4 0 12 -3c47 -21 93 -28 133 -28c67 0 116 20 136 29c5 3 8 3 8 3c7 0 10 -5 10 -11c0 -13 -70 -104 -193 -104c-32 0 -65 7 -85 13v-195c36 35 79 51 127 51 c108 0 190 -100 190 -219Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-5D" d="M164 -250h-122c-11 0 -20 9 -20 20s9 20 20 20h82v920h-82c-11 0 -20 9 -20 20s9 20 20 20h122v-1000Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-5B" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-30" x="278" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="779" y="0"></use>
<g transform="translate(1224,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-31"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-35" x="500" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-5D" x="2225" y="0"></use>
</g>
</svg> and the
Morton code has 8 bits: <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="21.019ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 9049.9 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y 3 x 3 y 2 x 2 y 1 x 1 y 0 x 0</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-33" d="M457 171c0 -102 -91 -193 -213 -193c-109 0 -202 66 -202 157c0 44 32 58 56 58c29 0 56 -20 56 -56c0 -38 -31 -60 -66 -55c35 -59 110 -76 153 -76c44 0 113 29 113 165c0 98 -37 166 -119 166h-44c-17 0 -24 0 -24 11c0 10 7 11 15 12c7 0 31 2 39 3c25 1 59 4 89 52 c26 44 28 102 28 114c0 90 -55 112 -96 112c-36 0 -102 -13 -133 -62c15 0 62 0 62 -50c0 -29 -20 -51 -51 -51c-29 0 -51 19 -51 52c0 76 76 136 177 136c96 0 184 -56 184 -138c0 -79 -58 -149 -140 -176c104 -21 167 -99 167 -181Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-33" x="693" y="-213"></use>
<g transform="translate(1111,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-33" x="809" y="-213"></use>
</g>
<g transform="translate(2304,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-32" x="693" y="-213"></use>
</g>
<g transform="translate(3415,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-32" x="809" y="-213"></use>
</g>
<g transform="translate(4608,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="693" y="-213"></use>
</g>
<g transform="translate(5719,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="809" y="-213"></use>
</g>
<g transform="translate(6912,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-30" x="693" y="-213"></use>
</g>
<g transform="translate(8023,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-30" x="809" y="-213"></use>
</g>
</g>
</svg>.  Many interesting properties follow from the encoding; a few examples
include:
</p>
<ul>
<li> For a Morton-encoded 8-bit value where the high bit <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.193ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 944.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y 3</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-33" d="M457 171c0 -102 -91 -193 -213 -193c-109 0 -202 66 -202 157c0 44 32 58 56 58c29 0 56 -20 56 -56c0 -38 -31 -60 -66 -55c35 -59 110 -76 153 -76c44 0 113 29 113 165c0 98 -37 166 -119 166h-44c-17 0 -24 0 -24 11c0 10 7 11 15 12c7 0 31 2 39 3c25 1 59 4 89 52 c26 44 28 102 28 114c0 90 -55 112 -96 112c-36 0 -102 -13 -133 -62c15 0 62 0 62 -50c0 -29 -20 -51 -51 -51c-29 0 -51 19 -51 52c0 76 76 136 177 136c96 0 184 -56 184 -138c0 -79 -58 -149 -140 -176c104 -21 167 -99 167 -181Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-33" x="693" y="-213"></use>
</g>
</svg> is set,
we then know that the high bit of its underlying <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg> coordinate is set and
thus <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.4ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 2325.1 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y greater-than-or-equal-to 8</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2265" d="M686 314l-581 -275c-25 -11 -42 25 -18 36l548 259l-548 259c-24 11 -7 47 18 36l581 -275c17 -8 17 -32 0 -40zM702 -99c0 -11 -9 -20 -20 -20h-586c-11 0 -20 9 -20 20s9 20 20 20h586c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-38" d="M457 168c0 -107 -95 -190 -208 -190c-105 0 -207 67 -207 173c0 99 86 155 144 184c-25 17 -62 42 -73 54c-42 47 -44 92 -44 110c0 93 81 167 181 167c91 0 180 -57 180 -149c0 -66 -49 -118 -121 -155c64 -40 80 -50 99 -71c38 -42 49 -87 49 -123zM386 517 c0 72 -64 124 -137 124c-71 0 -136 -42 -136 -103c0 -17 4 -51 50 -81l124 -80c60 35 99 83 99 140zM407 132c0 61 -47 91 -75 110l-123 78c-85 -47 -117 -111 -117 -169c0 -83 72 -145 158 -145c82 0 157 52 157 126Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2265" x="768" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-38" x="1824" y="0"></use>
</g>
</svg> (Figure&nbsp;<a href="#fig:morton-bit-implications">7.9</a>(a)).

<li> The next bit value, <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.384ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 1026.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x 3</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-33" d="M457 171c0 -102 -91 -193 -213 -193c-109 0 -202 66 -202 157c0 44 32 58 56 58c29 0 56 -20 56 -56c0 -38 -31 -60 -66 -55c35 -59 110 -76 153 -76c44 0 113 29 113 165c0 98 -37 166 -119 166h-44c-17 0 -24 0 -24 11c0 10 7 11 15 12c7 0 31 2 39 3c25 1 59 4 89 52 c26 44 28 102 28 114c0 90 -55 112 -96 112c-36 0 -102 -13 -133 -62c15 0 62 0 62 -50c0 -29 -20 -51 -51 -51c-29 0 -51 19 -51 52c0 76 76 136 177 136c96 0 184 -56 184 -138c0 -79 -58 -149 -140 -176c104 -21 167 -99 167 -181Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-33" x="809" y="-213"></use>
</g>
</svg>, splits the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg> axis in the middle (Figure&nbsp;<a href="#fig:morton-bit-implications">7.9</a>(b)).  If
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.193ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 944.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y 3</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-33" d="M457 171c0 -102 -91 -193 -213 -193c-109 0 -202 66 -202 157c0 44 32 58 56 58c29 0 56 -20 56 -56c0 -38 -31 -60 -66 -55c35 -59 110 -76 153 -76c44 0 113 29 113 165c0 98 -37 166 -119 166h-44c-17 0 -24 0 -24 11c0 10 7 11 15 12c7 0 31 2 39 3c25 1 59 4 89 52 c26 44 28 102 28 114c0 90 -55 112 -96 112c-36 0 -102 -13 -133 -62c15 0 62 0 62 -50c0 -29 -20 -51 -51 -51c-29 0 -51 19 -51 52c0 76 76 136 177 136c96 0 184 -56 184 -138c0 -79 -58 -149 -140 -176c104 -21 167 -99 167 -181Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-33" x="693" y="-213"></use>
</g>
</svg> is set and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.384ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 1026.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x 3</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-33" d="M457 171c0 -102 -91 -193 -213 -193c-109 0 -202 66 -202 157c0 44 32 58 56 58c29 0 56 -20 56 -56c0 -38 -31 -60 -66 -55c35 -59 110 -76 153 -76c44 0 113 29 113 165c0 98 -37 166 -119 166h-44c-17 0 -24 0 -24 11c0 10 7 11 15 12c7 0 31 2 39 3c25 1 59 4 89 52 c26 44 28 102 28 114c0 90 -55 112 -96 112c-36 0 -102 -13 -133 -62c15 0 62 0 62 -50c0 -29 -20 -51 -51 -51c-29 0 -51 19 -51 52c0 76 76 136 177 136c96 0 184 -56 184 -138c0 -79 -58 -149 -140 -176c104 -21 167 -99 167 -181Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-33" x="809" y="-213"></use>
</g>
</svg> is off, for example, then the corresponding point must
lie in the shaded area of Figure&nbsp;<a href="#fig:morton-bit-implications">7.9</a>(c).  In
general, points with a number of matching high bits lie in a power-of-two
sized and axis-aligned region of space determined by the matching bit values.

<li> The value of <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.193ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 944.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y 2</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-32" x="693" y="-213"></use>
</g>
</svg> splits the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg> axis into four regions
(Figure&nbsp;<a href="#fig:morton-bit-implications">7.9</a>(d)).
</ul><p>


</p>
<p></p>
<span class="anchor" id="fig:morton-bit-implications"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="pha07f09.svg" title=""><img src="pha07f09.svg" width=575 height=533 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 7.9: Implications of the Morton Encoding. <span class="legend"> 
The values of various bits in the Morton value indicate the region of space
that the corresponding coordinate lies in.
(a)&nbsp;In 2D, the high bit of the Morton-coded value of a point&rsquo;s coordinates
defines a splitting plane along the middle of the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg> axis.  If the high bit is set, the
point is above the plane.
(b)&nbsp;Similarly, the second-highest bit of the Morton value splits the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg>
axis in the middle.
(c)&nbsp;If the high <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg> bit is&nbsp;1 and the high <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg> bit is&nbsp;0, then the point
must lie in the shaded region.
(d)&nbsp;The second-from-highest <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg> bit splits the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg> axis into four regions.
</span>
</figcaption>
</div></div><p>


</p>
<p>Another way to interpret these bit-based properties is in terms of
Morton-coded values.  For example,
Figure&nbsp;<a href="#fig:morton-bit-implications">7.9</a>(a) corresponds to the index being
in the range <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.815ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2503.7 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-bracket 8 comma 15 right-bracket</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-5B" d="M256 -230c0 -11 -9 -20 -20 -20h-122v1000h122c11 0 20 -9 20 -20s-9 -20 -20 -20h-82v-920h82c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-38" d="M457 168c0 -107 -95 -190 -208 -190c-105 0 -207 67 -207 173c0 99 86 155 144 184c-25 17 -62 42 -73 54c-42 47 -44 92 -44 110c0 93 81 167 181 167c91 0 180 -57 180 -149c0 -66 -49 -118 -121 -155c64 -40 80 -50 99 -71c38 -42 49 -87 49 -123zM386 517 c0 72 -64 124 -137 124c-71 0 -136 -42 -136 -103c0 -17 4 -51 50 -81l124 -80c60 35 99 83 99 140zM407 132c0 61 -47 91 -75 110l-123 78c-85 -47 -117 -111 -117 -169c0 -83 72 -145 158 -145c82 0 157 52 157 126Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-35" d="M449 201c0 -127 -102 -223 -218 -223c-112 0 -181 97 -181 183c0 46 35 53 49 53c33 0 50 -25 50 -49s-17 -49 -50 -49c-11 0 -14 1 -17 2c17 -59 74 -112 147 -112c46 0 83 26 107 65c24 42 24 102 24 137c0 50 -2 89 -18 126c-8 18 -33 64 -85 64 c-81 0 -118 -54 -129 -70c-4 -6 -6 -9 -13 -9c-14 0 -14 8 -14 26v296c0 16 0 24 10 24c0 0 4 0 12 -3c47 -21 93 -28 133 -28c67 0 116 20 136 29c5 3 8 3 8 3c7 0 10 -5 10 -11c0 -13 -70 -104 -193 -104c-32 0 -65 7 -85 13v-195c36 35 79 51 127 51 c108 0 190 -100 190 -219Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-5D" d="M164 -250h-122c-11 0 -20 9 -20 20s9 20 20 20h82v920h-82c-11 0 -20 9 -20 20s9 20 20 20h122v-1000Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-5B" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-38" x="278" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="779" y="0"></use>
<g transform="translate(1224,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-31"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-35" x="500" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-5D" x="2225" y="0"></use>
</g>
</svg>, and Figure&nbsp;<a href="#fig:morton-bit-implications">7.9</a>(c)
corresponds to <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.815ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2503.7 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-bracket 8 comma 11 right-bracket</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-5B" d="M256 -230c0 -11 -9 -20 -20 -20h-122v1000h122c11 0 20 -9 20 -20s-9 -20 -20 -20h-82v-920h82c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-38" d="M457 168c0 -107 -95 -190 -208 -190c-105 0 -207 67 -207 173c0 99 86 155 144 184c-25 17 -62 42 -73 54c-42 47 -44 92 -44 110c0 93 81 167 181 167c91 0 180 -57 180 -149c0 -66 -49 -118 -121 -155c64 -40 80 -50 99 -71c38 -42 49 -87 49 -123zM386 517 c0 72 -64 124 -137 124c-71 0 -136 -42 -136 -103c0 -17 4 -51 50 -81l124 -80c60 35 99 83 99 140zM407 132c0 61 -47 91 -75 110l-123 78c-85 -47 -117 -111 -117 -169c0 -83 72 -145 158 -145c82 0 157 52 157 126Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-5D" d="M164 -250h-122c-11 0 -20 9 -20 20s9 20 20 20h82v920h-82c-11 0 -20 9 -20 20s9 20 20 20h122v-1000Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-5B" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-38" x="278" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="779" y="0"></use>
<g transform="translate(1224,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-31"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="500" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-5D" x="2225" y="0"></use>
</g>
</svg>.  Thus, given a set of sorted Morton indices, we
could find the range of points corresponding to an area like
Figure&nbsp;<a href="#fig:morton-bit-implications">7.9</a>(c) by performing a binary search
to find each endpoint in the array.

</p>
<p>LBVHs are BVHs built by partitioning primitives using 
splitting planes that are at the midpoint of each region of space
(i.e., equivalent to the <tt>SplitMethod::Middle</tt> path defined earlier).
Partitioning is extremely efficient, as it takes advantage of properties of the
Morton encoding described above.

</p>
<p>Just reimplementing <tt>Middle</tt> in a different manner is not particularly
interesting, so in the implementation here, we will build a
<em>hierarchical linear bounding volume hierarchy</em> (HLBVH).  With this
approach, Morton-curve-based clustering is used to first build trees for
the lower levels of the hierarchy (referred to as &ldquo;treelets&rdquo; in the
following), and the top levels of the tree are then created using the
surface area heuristic.  The <tt>buildHLBVH()</tt> method implements this
approach and returns the root node of the resulting tree.

</p>
<p></p>
<span class="anchor" id="fragment-BVHAggregateMethodDefinitions-2"></span><div class="fragmentname">&lt;&lt;BVHAggregate Method Definitions&gt;&gt;+=&nbsp;<a href="#fragment-BVHAggregateMethodDefinitions-1"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-BVHAggregateMethodDefinitions-3"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">BVHBuildNode *<span class="anchor" id="BVHAggregate::buildHLBVH"></span>BVHAggregate::buildHLBVH(
        <a href="../Introduction/Using_and_Understanding_the_Code.html#Allocator" class="code">Allocator</a> alloc, const std::vector&lt;BVHPrimitive&gt; &amp;bvhPrimitives,
        std::atomic&lt;int&gt; *totalNodes,
        std::vector&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; &amp;orderedPrims) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Computeboundingboxofallprimitivecentroids-0">Compute bounding box of all primitive centroids</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1087" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1087"><i></i></a><div id="fragbit-1087" class="collapse show"><div class="fragmentcode">       <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> bounds;
       for (const BVHPrimitive &amp;prim : bvhPrimitives)
           bounds = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(bounds, prim.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>());</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputeMortonindicesofprimitives-0">Compute Morton indices of primitives</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1088" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1088"><i></i></a><div id="fragbit-1088" class="collapse show"><div class="fragmentcode">       std::vector&lt;MortonPrimitive&gt; mortonPrims(bvhPrimitives.size());
       <a href="../Utilities/Parallelism.html#ParallelFor" class="code">ParallelFor</a>(0, bvhPrimitives.size(), [&amp;](int64_t i) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonomortonPrimsiformonoithprimitive-0">Initialize <tt>mortonPrims[i]</tt> for <tt>i</tt>th primitive</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1089" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1089"><i></i></a><div id="fragbit-1089" class="collapse show"><div class="fragmentcode">              constexpr int mortonBits = 10;
              constexpr int mortonScale = 1 &lt;&lt; mortonBits;
              mortonPrims[i].<a href="#BVHPrimitive::primitiveIndex" class="code">primitiveIndex</a> = bvhPrimitives[i].<a href="#BVHPrimitive::primitiveIndex" class="code">primitiveIndex</a>;
              <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> centroidOffset = bounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Offset" class="code">Offset</a>(bvhPrimitives[i].<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>());
              <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> offset = centroidOffset * mortonScale;
              mortonPrims[i].mortonCode = <a href="../Utilities/Mathematical_Infrastructure.html#EncodeMorton3" class="code">EncodeMorton3</a>(offset.x, offset.y, offset.z);</div></div>
       });</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-RadixsortprimitiveMortonindices-0">Radix sort primitive Morton indices</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1090" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1090"><i></i></a><div id="fragbit-1090" class="collapse show"><div class="fragmentcode">       <a href="#RadixSort" class="code">RadixSort</a>(&amp;mortonPrims);</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-CreateLBVHtreeletsatbottomofBVH-0">Create LBVH treelets at bottom of BVH</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1091" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1091"><i></i></a><div id="fragbit-1091" class="collapse show"><div class="fragmentcode">       &lt;&lt;<span class="fragmentname"><a href="#fragment-Findintervalsofprimitivesforeachtreelet-0">Find intervals of primitives for each treelet</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1092" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1092"><i></i></a><div id="fragbit-1092" class="collapse show"><div class="fragmentcode">          std::vector&lt;LBVHTreelet&gt; treeletsToBuild;
          for (size_t start = 0, end = 1; end &lt;= mortonPrims.size(); ++end) {
              uint32_t mask = 0b00111111111111000000000000000000;
              if (end == (int)mortonPrims.size() ||
                  ((mortonPrims[start].<a href="#MortonPrimitive::mortonCode" class="code">mortonCode</a> &amp; mask) !=
                   (mortonPrims[end].<a href="#MortonPrimitive::mortonCode" class="code">mortonCode</a> &amp; mask))) {
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-AddentrytomonotreeletsToBuildforthistreelet-0">Add entry to <tt>treeletsToBuild</tt> for this treelet</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1093" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1093"><i></i></a><div id="fragbit-1093" class="collapse show"><div class="fragmentcode">                     size_t nPrimitives = end - start;
                     int maxBVHNodes = 2 * nPrimitives - 1;
                     BVHBuildNode *nodes = alloc.<a href="../Introduction/Using_and_Understanding_the_Code.html#std::pmr::polymorphic_allocator::allocate_object" class="code">allocate_object</a>&lt;BVHBuildNode&gt;(maxBVHNodes);
                     treeletsToBuild.push_back({start, nPrimitives, nodes});</div></div> 
                  start = end;
              }
          }</div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-CreateLBVHsfortreeletsinparallel-0">Create LBVHs for treelets in parallel</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1094" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1094"><i></i></a><div id="fragbit-1094" class="collapse show"><div class="fragmentcode">          std::atomic&lt;int&gt; orderedPrimsOffset(0);
          <a href="../Utilities/Parallelism.html#ParallelFor" class="code">ParallelFor</a>(0, treeletsToBuild.size(), [&amp;](int i) {
              &lt;&lt;<span class="fragmentname"><a href="#fragment-GeneratemonoithLBVHtreelet-0">Generate <tt>i</tt>th LBVH treelet</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1095" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1095"><i></i></a><div id="fragbit-1095" class="collapse show"><div class="fragmentcode">                 int nodesCreated = 0;
                 const int firstBitIndex = 29 - 12;
                 LBVHTreelet &amp;tr = treeletsToBuild[i];
                 tr.<a href="#LBVHTreelet::buildNodes" class="code">buildNodes</a> = 
                     <a href="#BVHAggregate::emitLBVH" class="code">emitLBVH</a>(tr.<a href="#LBVHTreelet::buildNodes" class="code">buildNodes</a>, bvhPrimitives, &amp;mortonPrims[tr.<a href="#LBVHTreelet::startIndex" class="code">startIndex</a>],
                              tr.<a href="#LBVHTreelet::nPrimitives" class="code">nPrimitives</a>, &amp;nodesCreated, orderedPrims,
                              &amp;orderedPrimsOffset, firstBitIndex);
                 *totalNodes += nodesCreated;</div></div> 
          });</div></div></div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-CreateandreturnSAHBVHfromLBVHtreelets-0">Create and return SAH BVH from LBVH treelets</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1096" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1096"><i></i></a><div id="fragbit-1096" class="collapse show"><div class="fragmentcode">       std::vector&lt;BVHBuildNode *&gt; finishedTreelets;
       for (LBVHTreelet &amp;treelet : treeletsToBuild)
           finishedTreelets.push_back(treelet.<a href="#LBVHTreelet::buildNodes" class="code">buildNodes</a>);
       return buildUpperSAH(alloc, finishedTreelets, 0,
                            finishedTreelets.size(), totalNodes);</div></div>
}</div><p>


</p>
<p>The BVH is built using only the centroids of primitive bounding boxes to
sort them&mdash;it does not account for the actual spatial extent of each
primitive.  This simplification is critical to the performance that HLBVHs
offer, but it also means that for scenes with primitives that span a wide
range of sizes, the tree that is built will not account for this variation
as an SAH-based tree would.

</p>
<p>Because the Morton encoding operates on integer coordinates, we first need
to bound the centroids of all the primitives so that we can quantize
centroid positions with respect to the overall bounds.

</p>
<p></p>
<span class="anchor" id="fragment-Computeboundingboxofallprimitivecentroids-0"></span><div class="fragmentname">&lt;&lt;Compute bounding box of all primitive centroids&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> bounds;
for (const BVHPrimitive &amp;prim : bvhPrimitives)
    bounds = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(bounds, prim.<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>());</div><p>


</p>
<p>Given the overall bounds, we can now compute the Morton code for each
primitive.  This is a fairly lightweight calculation, but given that there
may be millions of primitives, it is worth parallelizing.  

</p>
<p></p>
<span class="anchor" id="fragment-ComputeMortonindicesofprimitives-0"></span><div class="fragmentname">&lt;&lt;Compute Morton indices of primitives&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::vector&lt;MortonPrimitive&gt; mortonPrims(bvhPrimitives.size());
<a href="../Utilities/Parallelism.html#ParallelFor" class="code">ParallelFor</a>(0, bvhPrimitives.size(), [&amp;](int64_t i) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonomortonPrimsiformonoithprimitive-0">Initialize <tt>mortonPrims[i]</tt> for <tt>i</tt>th primitive</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1097" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1097"><i></i></a><div id="fragbit-1097" class="collapse show"><div class="fragmentcode">       constexpr int mortonBits = 10;
       constexpr int mortonScale = 1 &lt;&lt; mortonBits;
       mortonPrims[i].<a href="#BVHPrimitive::primitiveIndex" class="code">primitiveIndex</a> = bvhPrimitives[i].<a href="#BVHPrimitive::primitiveIndex" class="code">primitiveIndex</a>;
       <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> centroidOffset = bounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Offset" class="code">Offset</a>(bvhPrimitives[i].<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>());
       <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> offset = centroidOffset * mortonScale;
       mortonPrims[i].mortonCode = <a href="../Utilities/Mathematical_Infrastructure.html#EncodeMorton3" class="code">EncodeMorton3</a>(offset.x, offset.y, offset.z);</div></div>
});</div><p>


</p>
<p>A <tt>MortonPrimitive</tt> instance is created for each primitive; it stores
the index of the primitive, as well as its
Morton code, in the <tt>bvhPrimitives</tt> array.

</p>
<p></p>
<span class="anchor" id="fragment-MortonPrimitiveDefinition-0"></span><div class="fragmentname">&lt;&lt;MortonPrimitive Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">struct <span class="anchor" id="MortonPrimitive"></span>MortonPrimitive {
    int <span class="anchor" id="MortonPrimitive::primitiveIndex"></span>primitiveIndex;
    uint32_t <span class="anchor" id="MortonPrimitive::mortonCode"></span>mortonCode;
};</div><p>


</p>
<p>We use 10 bits for each of the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg>, <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg>, and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.086ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 467.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">z</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D467" d="M467 432c0 -4 -22 -52 -117 -145c-36 -36 -98 -90 -98 -90c-36 -31 -65 -56 -119 -114c9 3 27 3 27 3c21 0 36 -4 70 -17c21 -7 39 -13 59 -13c33 0 97 19 120 84c3 7 5 13 14 13c8 0 12 -5 12 -10c0 -27 -58 -154 -157 -154c-29 0 -47 16 -64 37c-25 29 -35 38 -58 38 c-32 0 -62 -27 -85 -62c-6 -11 -8 -13 -16 -13c0 0 -12 0 -12 10c0 7 35 64 103 131l90 84c19 16 103 88 139 131c-26 0 -37 0 -77 15c-23 8 -42 15 -63 15c-8 0 -66 -1 -85 -47c-2 -6 -4 -11 -13 -11s-12 6 -12 11c0 21 46 114 121 114c33 0 50 -20 69 -43 c15 -17 27 -32 51 -32s45 16 75 64c5 9 8 11 15 11c0 0 11 0 11 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D467" x="0" y="0"></use>
</g>
</svg> dimensions, giving a
total of 30 bits for the Morton code.  This granularity allows the values
to fit into a single 32-bit variable. Floating-point centroid offsets
inside the bounding box are in <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.653ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2003.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-bracket 0 comma 1 right-bracket</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-5B" d="M256 -230c0 -11 -9 -20 -20 -20h-122v1000h122c11 0 20 -9 20 -20s-9 -20 -20 -20h-82v-920h82c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-5D" d="M164 -250h-122c-11 0 -20 9 -20 20s9 20 20 20h82v920h-82c-11 0 -20 9 -20 20s9 20 20 20h122v-1000Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-5B" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-30" x="278" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="779" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="1224" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-5D" x="1724" y="0"></use>
</g>
</svg>, so we scale them by
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.676ex" style="vertical-align: -0.338ex;" viewBox="0 -1006.6 1308.3 1152.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">2 Superscript 10</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="0" y="0"></use>
<g transform="translate(500,393)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-30" x="500" y="0"></use>
</g>
</g>
</svg> to get integer coordinates that fit in 10 bits.  The
<a href="../Utilities/Mathematical_Infrastructure.html#EncodeMorton3"><tt>EncodeMorton3()</tt></a> function, which is defined with other bitwise utility
functions in Section&nbsp;<a href="../Utilities/Mathematical_Infrastructure.html#sec:bit-ops">B.2.7</a>, returns the 3D Morton code for the
given integer values.

</p>
<p></p>
<span class="anchor" id="fragment-InitializemonomortonPrimsiformonoithprimitive-0"></span><div class="fragmentname">&lt;&lt;Initialize <tt>mortonPrims[i]</tt> for <tt>i</tt>th primitive&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">constexpr int mortonBits = 10;
constexpr int mortonScale = 1 &lt;&lt; mortonBits;
mortonPrims[i].<a href="#BVHPrimitive::primitiveIndex" class="code">primitiveIndex</a> = bvhPrimitives[i].<a href="#BVHPrimitive::primitiveIndex" class="code">primitiveIndex</a>;
<a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> centroidOffset = bounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Offset" class="code">Offset</a>(bvhPrimitives[i].<a href="#BVHPrimitive::Centroid" class="code">Centroid</a>());
<a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> offset = centroidOffset * mortonScale;
mortonPrims[i].mortonCode = <a href="../Utilities/Mathematical_Infrastructure.html#EncodeMorton3" class="code">EncodeMorton3</a>(offset.x, offset.y, offset.z);</div><p>


</p>
<p>Once the Morton indices have been computed, we will sort the
<tt>mortonPrims</tt> by Morton index value using a radix sort.  We have found
that for BVH construction, our radix sort implementation is noticeably
faster than using <tt>std::sort()</tt> from our system&rsquo;s standard library
(which is a mixture of a quicksort and an insertion sort).

</p>
<p></p>
<span class="anchor" id="fragment-RadixsortprimitiveMortonindices-0"></span><div class="fragmentname">&lt;&lt;Radix sort primitive Morton indices&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="#RadixSort" class="code">RadixSort</a>(&amp;mortonPrims);</div><p>


</p>
<p>Recall that a radix sort differs from most sorting algorithms in that it is
not based on comparing pairs of values but rather is based on bucketing
items based on some key.  Radix sort can be used to sort integer values by
sorting them one digit at a time, going from the rightmost digit to the
leftmost.  Especially with binary values, it is worth sorting multiple
digits at a time; doing so reduces the total number of passes taken over
the data.  In the implementation here, <tt>bitsPerPass</tt> sets the number
of bits processed per pass; with the value 6, we have 5 passes to sort the
30 bits.

</p>
<p></p>
<span class="anchor" id="fragment-BVHAggregateUtilityFunctions-0"></span><div class="fragmentname">&lt;&lt;BVHAggregate Utility Functions&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">static void <span class="anchor" id="RadixSort"></span>RadixSort(std::vector&lt;MortonPrimitive&gt; *v) {
    std::vector&lt;MortonPrimitive&gt; tempVector(v-&gt;size());
    constexpr int bitsPerPass = 6;
    constexpr int nBits = 30;
    constexpr int nPasses = nBits / bitsPerPass;
    for (int pass = 0; pass &lt; nPasses; ++pass) {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-PerformonepassofradixsortsortingmonobitsPerPassbits-0">Perform one pass of radix sort, sorting <tt>bitsPerPass</tt> bits</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1098" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1098"><i></i></a><div id="fragbit-1098" class="collapse show"><div class="fragmentcode">           int lowBit = pass * bitsPerPass;
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Setinandoutvectorreferencesforradixsortpass-0">Set in and out vector references for radix sort pass</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1099" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1099"><i></i></a><div id="fragbit-1099" class="collapse show"><div class="fragmentcode">              std::vector&lt;MortonPrimitive&gt; &amp;in = (pass &amp; 1) ? tempVector : *v;
              std::vector&lt;MortonPrimitive&gt; &amp;out = (pass &amp; 1) ? *v : tempVector;</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Countnumberofzerobitsinarrayforcurrentradixsortbit-0">Count number of zero bits in array for current radix sort bit</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1100" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1100"><i></i></a><div id="fragbit-1100" class="collapse show"><div class="fragmentcode">              constexpr int nBuckets = 1 &lt;&lt; bitsPerPass;
              int bucketCount[nBuckets] = { 0 };
              constexpr int bitMask = (1 &lt;&lt; bitsPerPass) - 1;
              for (const MortonPrimitive &amp;mp : in) {
                  int bucket = (mp.<a href="#MortonPrimitive::mortonCode" class="code">mortonCode</a> &gt;&gt; lowBit) &amp; bitMask;
                  ++bucketCount[bucket];
              }</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Computestartingindexinoutputarrayforeachbucket-0">Compute starting index in output array for each bucket</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1101" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1101"><i></i></a><div id="fragbit-1101" class="collapse show"><div class="fragmentcode">              int outIndex[nBuckets];
              outIndex[0] = 0;
              for (int i = 1; i &lt; nBuckets; ++i)
                  outIndex[i] = outIndex[i - 1] + bucketCount[i - 1];</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Storesortedvaluesinoutputarray-0">Store sorted values in output array</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1102" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1102"><i></i></a><div id="fragbit-1102" class="collapse show"><div class="fragmentcode">              for (const MortonPrimitive &amp;mp : in) {
                  int bucket = (mp.<a href="#MortonPrimitive::mortonCode" class="code">mortonCode</a> &gt;&gt; lowBit) &amp; bitMask;
                  out[outIndex[bucket]++] = mp;
              }</div></div></div></div>
    }
    &lt;&lt;<span class="fragmentname"><a href="#fragment-CopyfinalresultfrommonotempVectorifneeded-0">Copy final result from <tt>tempVector</tt>, if needed</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1103" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1103"><i></i></a><div id="fragbit-1103" class="collapse show"><div class="fragmentcode">       if (nPasses &amp; 1)
           std::swap(*v, tempVector);</div></div>
}</div><p>


</p>
<p>
Each pass sorts <tt>bitsPerPass</tt> bits, starting at
<tt>lowBit</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-PerformonepassofradixsortsortingmonobitsPerPassbits-0"></span><div class="fragmentname">&lt;&lt;Perform one pass of radix sort, sorting <tt>bitsPerPass</tt> bits&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int lowBit = pass * bitsPerPass;
&lt;&lt;<span class="fragmentname"><a href="#fragment-Setinandoutvectorreferencesforradixsortpass-0">Set in and out vector references for radix sort pass</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1104" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1104"><i></i></a><div id="fragbit-1104" class="collapse show"><div class="fragmentcode">   std::vector&lt;MortonPrimitive&gt; &amp;in = (pass &amp; 1) ? tempVector : *v;
   std::vector&lt;MortonPrimitive&gt; &amp;out = (pass &amp; 1) ? *v : tempVector;</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Countnumberofzerobitsinarrayforcurrentradixsortbit-0">Count number of zero bits in array for current radix sort bit</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1105" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1105"><i></i></a><div id="fragbit-1105" class="collapse show"><div class="fragmentcode">   constexpr int nBuckets = 1 &lt;&lt; bitsPerPass;
   int bucketCount[nBuckets] = { 0 };
   constexpr int bitMask = (1 &lt;&lt; bitsPerPass) - 1;
   for (const MortonPrimitive &amp;mp : in) {
       int bucket = (mp.<a href="#MortonPrimitive::mortonCode" class="code">mortonCode</a> &gt;&gt; lowBit) &amp; bitMask;
       ++bucketCount[bucket];
   }</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Computestartingindexinoutputarrayforeachbucket-0">Compute starting index in output array for each bucket</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1106" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1106"><i></i></a><div id="fragbit-1106" class="collapse show"><div class="fragmentcode">   int outIndex[nBuckets];
   outIndex[0] = 0;
   for (int i = 1; i &lt; nBuckets; ++i)
       outIndex[i] = outIndex[i - 1] + bucketCount[i - 1];</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Storesortedvaluesinoutputarray-0">Store sorted values in output array</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1107" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1107"><i></i></a><div id="fragbit-1107" class="collapse show"><div class="fragmentcode">   for (const MortonPrimitive &amp;mp : in) {
       int bucket = (mp.<a href="#MortonPrimitive::mortonCode" class="code">mortonCode</a> &gt;&gt; lowBit) &amp; bitMask;
       out[outIndex[bucket]++] = mp;
   }</div></div></div><p>


</p>
<p>The <tt>in</tt> and <tt>out</tt> references correspond to the vector to be sorted and
the vector to store the sorted values in, respectively.  Each pass through
the loop alternates between the input vector <tt>*v</tt> and the temporary
vector for each of them.

</p>
<p></p>
<span class="anchor" id="fragment-Setinandoutvectorreferencesforradixsortpass-0"></span><div class="fragmentname">&lt;&lt;Set in and out vector references for radix sort pass&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::vector&lt;MortonPrimitive&gt; &amp;in = (pass &amp; 1) ? tempVector : *v;
std::vector&lt;MortonPrimitive&gt; &amp;out = (pass &amp; 1) ? *v : tempVector;</div><p>


</p>
<p>If we are sorting <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 600.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
</g>
</svg> bits per pass, then there are <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.381ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 1025.1 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">2 Superscript n</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="707" y="557"></use>
</g>
</svg> buckets that each
value may land in.  We first count how many values will land in each
bucket; this will let us determine where to store sorted values in the
output array.  To compute the bucket index for the current value, the
implementation shifts the index so that the bit at index <tt>lowBit</tt> is at bit&nbsp;0
and then masks off the low <tt>bitsPerPass</tt> bits.

</p>
<p></p>
<span class="anchor" id="fragment-Countnumberofzerobitsinarrayforcurrentradixsortbit-0"></span><div class="fragmentname">&lt;&lt;Count number of zero bits in array for current radix sort bit&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">constexpr int nBuckets = 1 &lt;&lt; bitsPerPass;
int bucketCount[nBuckets] = { 0 };
constexpr int bitMask = (1 &lt;&lt; bitsPerPass) - 1;
for (const MortonPrimitive &amp;mp : in) {
    int bucket = (mp.<a href="#MortonPrimitive::mortonCode" class="code">mortonCode</a> &gt;&gt; lowBit) &amp; bitMask;
    ++bucketCount[bucket];
}</div><p>


</p>
<p>Given the count of how many values land in each bucket, we can compute the
offset in the output array where each bucket&rsquo;s values start; this is just
the sum of how many values land in the preceding buckets.

</p>
<p></p>
<span class="anchor" id="fragment-Computestartingindexinoutputarrayforeachbucket-0"></span><div class="fragmentname">&lt;&lt;Compute starting index in output array for each bucket&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int outIndex[nBuckets];
outIndex[0] = 0;
for (int i = 1; i &lt; nBuckets; ++i)
    outIndex[i] = outIndex[i - 1] + bucketCount[i - 1];</div><p>


</p>
<p>Now that we know where to start storing values for each bucket, we can take
another pass over the primitives to recompute the bucket that each one lands
in and to store their <tt>MortonPrimitive</tt>s in the output array.  This
completes the sorting pass for the current group of bits.

</p>
<p></p>
<span class="anchor" id="fragment-Storesortedvaluesinoutputarray-0"></span><div class="fragmentname">&lt;&lt;Store sorted values in output array&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">for (const MortonPrimitive &amp;mp : in) {
    int bucket = (mp.<a href="#MortonPrimitive::mortonCode" class="code">mortonCode</a> &gt;&gt; lowBit) &amp; bitMask;
    out[outIndex[bucket]++] = mp;
}</div><p>


</p>
<p>When sorting is done, if an odd number of radix sort passes were performed,
then the final sorted values need to be copied from the temporary vector to
the output vector that was originally passed to <tt>RadixSort()</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-CopyfinalresultfrommonotempVectorifneeded-0"></span><div class="fragmentname">&lt;&lt;Copy final result from <tt>tempVector</tt>, if needed&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (nPasses &amp; 1)
    std::swap(*v, tempVector);</div><p>


</p>
<p>Given the sorted array of primitives, we can now find clusters of
primitives with nearby centroids and then create an LBVH over the
primitives in each cluster.  This step is a good one to parallelize as
there are generally many clusters and each cluster can be processed
independently.

</p>
<p></p>
<span class="anchor" id="fragment-CreateLBVHtreeletsatbottomofBVH-0"></span><div class="fragmentname">&lt;&lt;Create LBVH treelets at bottom of BVH&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">&lt;&lt;<span class="fragmentname"><a href="#fragment-Findintervalsofprimitivesforeachtreelet-0">Find intervals of primitives for each treelet</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1108" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1108"><i></i></a><div id="fragbit-1108" class="collapse show"><div class="fragmentcode">   std::vector&lt;LBVHTreelet&gt; treeletsToBuild;
   for (size_t start = 0, end = 1; end &lt;= mortonPrims.size(); ++end) {
       uint32_t mask = 0b00111111111111000000000000000000;
       if (end == (int)mortonPrims.size() ||
           ((mortonPrims[start].<a href="#MortonPrimitive::mortonCode" class="code">mortonCode</a> &amp; mask) !=
            (mortonPrims[end].<a href="#MortonPrimitive::mortonCode" class="code">mortonCode</a> &amp; mask))) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-AddentrytomonotreeletsToBuildforthistreelet-0">Add entry to <tt>treeletsToBuild</tt> for this treelet</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1109" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1109"><i></i></a><div id="fragbit-1109" class="collapse show"><div class="fragmentcode">              size_t nPrimitives = end - start;
              int maxBVHNodes = 2 * nPrimitives - 1;
              BVHBuildNode *nodes = alloc.<a href="../Introduction/Using_and_Understanding_the_Code.html#std::pmr::polymorphic_allocator::allocate_object" class="code">allocate_object</a>&lt;BVHBuildNode&gt;(maxBVHNodes);
              treeletsToBuild.push_back({start, nPrimitives, nodes});</div></div> 
           start = end;
       }
   }</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-CreateLBVHsfortreeletsinparallel-0">Create LBVHs for treelets in parallel</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1110" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1110"><i></i></a><div id="fragbit-1110" class="collapse show"><div class="fragmentcode">   std::atomic&lt;int&gt; orderedPrimsOffset(0);
   <a href="../Utilities/Parallelism.html#ParallelFor" class="code">ParallelFor</a>(0, treeletsToBuild.size(), [&amp;](int i) {
       &lt;&lt;<span class="fragmentname"><a href="#fragment-GeneratemonoithLBVHtreelet-0">Generate <tt>i</tt>th LBVH treelet</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1111" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1111"><i></i></a><div id="fragbit-1111" class="collapse show"><div class="fragmentcode">          int nodesCreated = 0;
          const int firstBitIndex = 29 - 12;
          LBVHTreelet &amp;tr = treeletsToBuild[i];
          tr.<a href="#LBVHTreelet::buildNodes" class="code">buildNodes</a> = 
              <a href="#BVHAggregate::emitLBVH" class="code">emitLBVH</a>(tr.<a href="#LBVHTreelet::buildNodes" class="code">buildNodes</a>, bvhPrimitives, &amp;mortonPrims[tr.<a href="#LBVHTreelet::startIndex" class="code">startIndex</a>],
                       tr.<a href="#LBVHTreelet::nPrimitives" class="code">nPrimitives</a>, &amp;nodesCreated, orderedPrims,
                       &amp;orderedPrimsOffset, firstBitIndex);
          *totalNodes += nodesCreated;</div></div> 
   });</div></div></div><p>


</p>
<p>Each primitive cluster is represented by an <tt>LBVHTreelet</tt>.  It encodes
the index in the <tt>mortonPrims</tt> array of the first primitive in the
cluster as well as the number of following primitives. (See
Figure&nbsp;<a href="#fig:lbvh-clusters">7.10</a>.)

</p>
<p></p>
<span class="anchor" id="fragment-LBVHTreeletDefinition-0"></span><div class="fragmentname">&lt;&lt;LBVHTreelet Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">struct <span class="anchor" id="LBVHTreelet"></span>LBVHTreelet {
   size_t <span class="anchor" id="LBVHTreelet::startIndex"></span>startIndex, <span class="anchor" id="LBVHTreelet::nPrimitives"></span>nPrimitives;
   BVHBuildNode *<span class="anchor" id="LBVHTreelet::buildNodes"></span>buildNodes;
};</div><p>


</p>
<p></p>
<span class="anchor" id="fig:lbvh-clusters"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="pha07f10.svg" title=""><img src="pha07f10.svg" width=253 height=253 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 7.10: Primitive Clusters for LBVH Treelets. <span class="legend">
  Primitive centroids are clustered in a uniform grid over their bounds.
  An LBVH is created for each cluster of primitives within a cell that
  are in contiguous sections of the sorted Morton index values.</span>
</figcaption>
</div></div><p>


</p>
<p>Recall from Figure&nbsp;<a href="#fig:morton-bit-implications">7.9</a> that a set of points with
Morton codes that match in their high bit values lie in a power-of-two
aligned and sized subset of the original volume.  Because we have already
sorted the <tt>mortonPrims</tt> array by Morton-coded value, primitives with
matching high bit values are already together in contiguous sections of the
array.

</p>
<p>Here we will find sets of primitives that have the same values for the high
12 bits of their 30-bit Morton codes.  Clusters are found by taking a
linear pass through the <tt>mortonPrims</tt> array and finding the offsets
where any of the high 12 bits changes.  This corresponds to clustering
primitives in a regular grid of <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.787ex" height="2.676ex" style="vertical-align: -0.338ex;" viewBox="0 -1006.6 4644.4 1152.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">2 Superscript 12 Baseline equals 4096</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-3D" d="M722 347c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20zM722 153c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-34" d="M471 165h-100v-87c0 -36 2 -47 76 -47h21v-31c-41 3 -94 3 -136 3s-94 0 -135 -3v31h21c74 0 76 11 76 47v87h-266v31l307 469c8 12 11 12 20 12c16 0 16 -6 16 -26v-455h100v-31zM300 196v373l-244 -373h244Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-39" d="M457 329c0 -215 -122 -351 -251 -351c-85 0 -139 41 -139 108c0 39 30 48 46 48c22 0 46 -15 46 -46c0 -17 -8 -46 -52 -46c27 -34 81 -36 98 -36c58 0 162 46 162 280v32c-23 -58 -64 -100 -125 -100c-112 0 -200 98 -200 223c0 75 23 117 64 162c43 45 92 63 147 63 c89 0 204 -68 204 -337zM365 421c0 46 -4 109 -16 141c-17 45 -50 79 -96 79c-35 0 -73 -13 -100 -63c-21 -37 -21 -84 -21 -138c0 -49 0 -99 18 -136c31 -63 77 -63 93 -63c88 0 122 97 122 180Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-36" d="M457 204c0 -132 -95 -226 -206 -226c-93 0 -209 71 -209 338c0 221 135 350 263 350c83 0 127 -48 127 -108c0 -39 -30 -48 -46 -48c-22 0 -46 15 -46 46c0 45 40 45 55 45c-22 34 -64 40 -88 40c-51 0 -175 -36 -175 -289v-24c20 48 57 99 125 99 c111 0 200 -96 200 -223zM367 205c0 49 0 100 -18 137c-31 62 -77 62 -93 62c-90 0 -122 -100 -122 -178c0 -18 0 -98 18 -145c6 -15 36 -75 99 -75c23 0 69 5 99 65c17 36 17 86 17 134Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="0" y="0"></use>
<g transform="translate(500,393)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-32" x="500" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-3D" x="1586" y="0"></use>
<g transform="translate(2642,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-34"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-30" x="500" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-39" x="1001" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-36" x="1501" y="0"></use>
</g>
</g>
</svg> total grid cells with <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.64ex" height="2.676ex" style="vertical-align: -0.338ex;" viewBox="0 -1006.6 3289.5 1152.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">2 Superscript 4 Baseline equals 16</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-34" d="M471 165h-100v-87c0 -36 2 -47 76 -47h21v-31c-41 3 -94 3 -136 3s-94 0 -135 -3v31h21c74 0 76 11 76 47v87h-266v31l307 469c8 12 11 12 20 12c16 0 16 -6 16 -26v-455h100v-31zM300 196v373l-244 -373h244Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-3D" d="M722 347c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20zM722 153c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-36" d="M457 204c0 -132 -95 -226 -206 -226c-93 0 -209 71 -209 338c0 221 135 350 263 350c83 0 127 -48 127 -108c0 -39 -30 -48 -46 -48c-22 0 -46 15 -46 46c0 45 40 45 55 45c-22 34 -64 40 -88 40c-51 0 -175 -36 -175 -289v-24c20 48 57 99 125 99 c111 0 200 -96 200 -223zM367 205c0 49 0 100 -18 137c-31 62 -77 62 -93 62c-90 0 -122 -100 -122 -178c0 -18 0 -98 18 -145c6 -15 36 -75 99 -75c23 0 69 5 99 65c17 36 17 86 17 134Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-34" x="707" y="557"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-3D" x="1232" y="0"></use>
<g transform="translate(2288,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-31"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-36" x="500" y="0"></use>
</g>
</g>
</svg> cells in each dimension.  In practice, many of the grid cells will be
empty, though we will still expect to find many independent clusters here.

</p>
<p></p>
<span class="anchor" id="fragment-Findintervalsofprimitivesforeachtreelet-0"></span><div class="fragmentname">&lt;&lt;Find intervals of primitives for each treelet&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::vector&lt;LBVHTreelet&gt; treeletsToBuild;
for (size_t start = 0, end = 1; end &lt;= mortonPrims.size(); ++end) {
    uint32_t mask = 0b00111111111111000000000000000000;
    if (end == (int)mortonPrims.size() ||
        ((mortonPrims[start].<a href="#MortonPrimitive::mortonCode" class="code">mortonCode</a> &amp; mask) !=
         (mortonPrims[end].<a href="#MortonPrimitive::mortonCode" class="code">mortonCode</a> &amp; mask))) {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-AddentrytomonotreeletsToBuildforthistreelet-0">Add entry to <tt>treeletsToBuild</tt> for this treelet</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1112" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1112"><i></i></a><div id="fragbit-1112" class="collapse show"><div class="fragmentcode">           size_t nPrimitives = end - start;
           int maxBVHNodes = 2 * nPrimitives - 1;
           BVHBuildNode *nodes = alloc.<a href="../Introduction/Using_and_Understanding_the_Code.html#std::pmr::polymorphic_allocator::allocate_object" class="code">allocate_object</a>&lt;BVHBuildNode&gt;(maxBVHNodes);
           treeletsToBuild.push_back({start, nPrimitives, nodes});</div></div> 
        start = end;
    }
}</div><p>


</p>
<p>When a cluster of primitives has been found for a treelet,
<tt>BVHBuildNode</tt>s are immediately allocated for it.  (Recall that the
number of nodes in a BVH is bounded by twice the number of leaf nodes,
which in turn is bounded by the number of primitives.)  It is simpler to
preallocate this memory now in a serial phase of execution than during
parallel construction of LBVHs.

</p>
<p></p>
<span class="anchor" id="fragment-AddentrytomonotreeletsToBuildforthistreelet-0"></span><div class="fragmentname">&lt;&lt;Add entry to <tt>treeletsToBuild</tt> for this treelet&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">size_t nPrimitives = end - start;
int maxBVHNodes = 2 * nPrimitives - 1;
BVHBuildNode *nodes = alloc.<a href="../Introduction/Using_and_Understanding_the_Code.html#std::pmr::polymorphic_allocator::allocate_object" class="code">allocate_object</a>&lt;BVHBuildNode&gt;(maxBVHNodes);
treeletsToBuild.push_back({start, nPrimitives, nodes});</div><p>


</p>
<p>Once the primitives for each treelet have been identified, we can create
LBVHs for them in parallel.  When construction is finished, the
<tt>buildNodes</tt> pointer for each <a href="#LBVHTreelet"><tt>LBVHTreelet</tt></a> will point to the root
of the corresponding LBVH.

</p>
<p>There are two places where the worker threads building LBVHs must
coordinate with each other.  First, the total number of nodes in all the
LBVHs needs to be computed and returned via the <tt>totalNodes</tt> pointer
passed to <tt>buildHLBVH()</tt>.  Second, when leaf nodes are created for the
LBVHs, a contiguous segment of the <tt>orderedPrims</tt> array is needed to
record the indices of the primitives in the leaf node.  Our implementation
uses atomic variables for both.

</p>
<p></p>
<span class="anchor" id="fragment-CreateLBVHsfortreeletsinparallel-0"></span><div class="fragmentname">&lt;&lt;Create LBVHs for treelets in parallel&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::atomic&lt;int&gt; orderedPrimsOffset(0);
<a href="../Utilities/Parallelism.html#ParallelFor" class="code">ParallelFor</a>(0, treeletsToBuild.size(), [&amp;](int i) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-GeneratemonoithLBVHtreelet-0">Generate <tt>i</tt>th LBVH treelet</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1113" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1113"><i></i></a><div id="fragbit-1113" class="collapse show"><div class="fragmentcode">       int nodesCreated = 0;
       const int firstBitIndex = 29 - 12;
       LBVHTreelet &amp;tr = treeletsToBuild[i];
       tr.<a href="#LBVHTreelet::buildNodes" class="code">buildNodes</a> = 
           <a href="#BVHAggregate::emitLBVH" class="code">emitLBVH</a>(tr.<a href="#LBVHTreelet::buildNodes" class="code">buildNodes</a>, bvhPrimitives, &amp;mortonPrims[tr.<a href="#LBVHTreelet::startIndex" class="code">startIndex</a>],
                    tr.<a href="#LBVHTreelet::nPrimitives" class="code">nPrimitives</a>, &amp;nodesCreated, orderedPrims,
                    &amp;orderedPrimsOffset, firstBitIndex);
       *totalNodes += nodesCreated;</div></div> 
});</div><p>


</p>
<p>The work of building the treelet is performed by <tt>emitLBVH()</tt>, which
takes primitives with centroids in some region of space and successively
partitions them with splitting planes that divide the current region of
space into two halves along the center of the region along one of the three
axes.

</p>
<p>

</p>
<p>Note that instead of taking a pointer to the atomic variable
<tt>totalNodes</tt> to count the number of nodes created, <tt>emitLBVH()</tt>
updates a non-atomic local variable. The fragment here then only updates
<tt>totalNodes</tt> once per treelet when each treelet is done.  This
approach gives measurably better performance than the alternative&mdash;having
the worker threads frequently modify <tt>totalNodes</tt> over the course of
their execution.  (To understand why this is so, see the discussion of the
overhead of multi-core memory coherence models in
Appendix&nbsp;<a href="../Utilities/Parallelism.html#sec:multi-thread-memory-perf">B.6.3</a>.)

</p>
<p></p>
<span class="anchor" id="fragment-GeneratemonoithLBVHtreelet-0"></span><div class="fragmentname">&lt;&lt;Generate <tt>i</tt>th LBVH treelet&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int nodesCreated = 0;
const int firstBitIndex = 29 - 12;
LBVHTreelet &amp;tr = treeletsToBuild[i];
tr.<a href="#LBVHTreelet::buildNodes" class="code">buildNodes</a> = 
    <a href="#BVHAggregate::emitLBVH" class="code">emitLBVH</a>(tr.<a href="#LBVHTreelet::buildNodes" class="code">buildNodes</a>, bvhPrimitives, &amp;mortonPrims[tr.<a href="#LBVHTreelet::startIndex" class="code">startIndex</a>],
             tr.<a href="#LBVHTreelet::nPrimitives" class="code">nPrimitives</a>, &amp;nodesCreated, orderedPrims,
             &amp;orderedPrimsOffset, firstBitIndex);
*totalNodes += nodesCreated;</div><p>


</p>
<p>Thanks to the Morton encoding, the current region of space does not need to
be explicitly represented in <tt>emitLBVH()</tt>: the sorted
<tt>MortonPrim</tt>s passed in have some number of matching high bits, which
in turn corresponds to a spatial bound.  For each of the remaining bits in
the Morton codes, this function tries to split the primitives along the
plane corresponding to the <tt>bitIndex</tt> bit (recall
Figure&nbsp;<a href="#fig:morton-bit-implications">7.9</a>(d)) and then calls itself
recursively.  The index of the next bit to try splitting with is passed as
the last argument to the function: initially it is <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.49ex" height="2.343ex" style="vertical-align: -0.505ex;" viewBox="0 -791.3 3224.9 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">29 minus 12</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-39" d="M457 329c0 -215 -122 -351 -251 -351c-85 0 -139 41 -139 108c0 39 30 48 46 48c22 0 46 -15 46 -46c0 -17 -8 -46 -52 -46c27 -34 81 -36 98 -36c58 0 162 46 162 280v32c-23 -58 -64 -100 -125 -100c-112 0 -200 98 -200 223c0 75 23 117 64 162c43 45 92 63 147 63 c89 0 204 -68 204 -337zM365 421c0 46 -4 109 -16 141c-17 45 -50 79 -96 79c-35 0 -73 -13 -100 -63c-21 -37 -21 -84 -21 -138c0 -49 0 -99 18 -136c31 -63 77 -63 93 -63c88 0 122 97 122 180Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2212" d="M722 250c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-32"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-39" x="500" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2212" x="1223" y="0"></use>
<g transform="translate(2223,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-31"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="500" y="0"></use>
</g>
</g>
</svg>, since <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.325ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 1001 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">29</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-39" d="M457 329c0 -215 -122 -351 -251 -351c-85 0 -139 41 -139 108c0 39 30 48 46 48c22 0 46 -15 46 -46c0 -17 -8 -46 -52 -46c27 -34 81 -36 98 -36c58 0 162 46 162 280v32c-23 -58 -64 -100 -125 -100c-112 0 -200 98 -200 223c0 75 23 117 64 162c43 45 92 63 147 63 c89 0 204 -68 204 -337zM365 421c0 46 -4 109 -16 141c-17 45 -50 79 -96 79c-35 0 -73 -13 -100 -63c-21 -37 -21 -84 -21 -138c0 -49 0 -99 18 -136c31 -63 77 -63 93 -63c88 0 122 97 122 180Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-32"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-39" x="500" y="0"></use>
</g>
</svg> is
the index of the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.325ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 1001 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">30</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-33" d="M457 171c0 -102 -91 -193 -213 -193c-109 0 -202 66 -202 157c0 44 32 58 56 58c29 0 56 -20 56 -56c0 -38 -31 -60 -66 -55c35 -59 110 -76 153 -76c44 0 113 29 113 165c0 98 -37 166 -119 166h-44c-17 0 -24 0 -24 11c0 10 7 11 15 12c7 0 31 2 39 3c25 1 59 4 89 52 c26 44 28 102 28 114c0 90 -55 112 -96 112c-36 0 -102 -13 -133 -62c15 0 62 0 62 -50c0 -29 -20 -51 -51 -51c-29 0 -51 19 -51 52c0 76 76 136 177 136c96 0 184 -56 184 -138c0 -79 -58 -149 -140 -176c104 -21 167 -99 167 -181Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-33"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-30" x="500" y="0"></use>
</g>
</svg>th bit with zero-based indexing, and we previously
used the high <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.325ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 1001 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">12</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-31"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="500" y="0"></use>
</g>
</svg> bits of the Morton-coded value to cluster the
primitives; thus, we know that those bits must all match for the cluster.

</p>
<p></p>
<span class="anchor" id="fragment-BVHAggregateMethodDefinitions-3"></span><div class="fragmentname">&lt;&lt;BVHAggregate Method Definitions&gt;&gt;+=&nbsp;<a href="#fragment-BVHAggregateMethodDefinitions-2"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-BVHAggregateMethodDefinitions-4"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">BVHBuildNode *<span class="anchor" id="BVHAggregate::emitLBVH"></span>BVHAggregate::emitLBVH(BVHBuildNode *&amp;buildNodes,
        const std::vector&lt;BVHPrimitive&gt; &amp;bvhPrimitives,
        MortonPrimitive *mortonPrims, int nPrimitives, int *totalNodes,
        std::vector&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; &amp;orderedPrims,
        std::atomic&lt;int&gt; *orderedPrimsOffset, int bitIndex) {
    if (bitIndex == -1 || nPrimitives &lt; <a href="#BVHAggregate::maxPrimsInNode" class="code">maxPrimsInNode</a>) {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-CreateandreturnleafnodeofLBVHtreelet-0">Create and return leaf node of LBVH treelet</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1114" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1114"><i></i></a><div id="fragbit-1114" class="collapse show"><div class="fragmentcode">           ++*totalNodes;
           BVHBuildNode *node = buildNodes++;
           <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> <a href="#BVHPrimitive::bounds" class="code">bounds</a>;
           int firstPrimOffset = orderedPrimsOffset-&gt;fetch_add(nPrimitives);
           for (int i = 0; i &lt; nPrimitives; ++i) {
               int <a href="#MortonPrimitive::primitiveIndex" class="code">primitiveIndex</a> = mortonPrims[i].<a href="#MortonPrimitive::primitiveIndex" class="code">primitiveIndex</a>;
               orderedPrims[firstPrimOffset + i] = primitives[<a href="#MortonPrimitive::primitiveIndex" class="code">primitiveIndex</a>];
               <a href="#BVHPrimitive::bounds" class="code">bounds</a> = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(<a href="#BVHPrimitive::bounds" class="code">bounds</a>, bvhPrimitives[<a href="#MortonPrimitive::primitiveIndex" class="code">primitiveIndex</a>].<a href="#BVHPrimitive::bounds" class="code">bounds</a>);
           }
           node-&gt;<a href="#BVHBuildNode::InitLeaf" class="code">InitLeaf</a>(firstPrimOffset, nPrimitives, <a href="#BVHPrimitive::bounds" class="code">bounds</a>);
           return node;</div></div>
    } else {
        int mask = 1 &lt;&lt; bitIndex;
        &lt;&lt;<span class="fragmentname"><a href="#fragment-AdvancetonextsubtreelevelifthereisnoLBVHsplitforthisbit-0">Advance to next subtree level if there is no LBVH split for this bit</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1115" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1115"><i></i></a><div id="fragbit-1115" class="collapse show"><div class="fragmentcode">           if ((mortonPrims[0].<a href="#MortonPrimitive::mortonCode" class="code">mortonCode</a> &amp; mask) ==
               (mortonPrims[nPrimitives - 1].<a href="#MortonPrimitive::mortonCode" class="code">mortonCode</a> &amp; mask))
               return <a href="#BVHAggregate::emitLBVH" class="code">emitLBVH</a>(buildNodes, bvhPrimitives, mortonPrims, nPrimitives,
                               totalNodes, orderedPrims, orderedPrimsOffset,
                               bitIndex - 1);</div></div>
        &lt;&lt;<span class="fragmentname"><a href="#fragment-FindLBVHsplitpointforthisdimension-0">Find LBVH split point for this dimension</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1116" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1116"><i></i></a><div id="fragbit-1116" class="collapse show"><div class="fragmentcode">           int splitOffset = <a href="../Utilities/Mathematical_Infrastructure.html#FindInterval" class="code">FindInterval</a>(nPrimitives, [&amp;](int index) {
               return ((mortonPrims[0].mortonCode &amp; mask) ==
                       (mortonPrims[index].mortonCode &amp; mask));
           });
           ++splitOffset;
           </div></div>
        &lt;&lt;<span class="fragmentname"><a href="#fragment-CreateandreturninteriorLBVHnode-0">Create and return interior LBVH node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1117" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1117"><i></i></a><div id="fragbit-1117" class="collapse show"><div class="fragmentcode">           (*totalNodes)++;
           BVHBuildNode *node = buildNodes++;
           BVHBuildNode *lbvh[2] = {
               <a href="#BVHAggregate::emitLBVH" class="code">emitLBVH</a>(buildNodes, bvhPrimitives, mortonPrims, splitOffset,
                        totalNodes, orderedPrims, orderedPrimsOffset, bitIndex - 1),
               <a href="#BVHAggregate::emitLBVH" class="code">emitLBVH</a>(buildNodes, bvhPrimitives, &amp;mortonPrims[splitOffset],
                        nPrimitives - splitOffset, totalNodes, orderedPrims,
                        orderedPrimsOffset, bitIndex - 1)
           };
           int axis = bitIndex % 3;
           node-&gt;<a href="#BVHBuildNode::InitInterior" class="code">InitInterior</a>(axis, lbvh[0], lbvh[1]);
           return node;</div></div>
    }
}</div><p>


</p>
<p>After <tt>emitLBVH()</tt> has partitioned the primitives with the final low
bit, no more splitting is possible and a leaf node is created.
Alternatively, it also stops and makes a leaf node if it is down to a small
number of primitives.

</p>
<p>Recall that <tt>orderedPrimsOffset</tt> is the offset to the next available
element in the <tt>orderedPrims</tt> array.  Here, the call to
<tt>fetch_add()</tt> atomically adds the value of <tt>nPrimitives</tt> to
<tt>orderedPrimsOffset</tt> and returns its old value before the addition.
Given space in the array, leaf construction is similar to the
approach implemented earlier in &lt;&lt;<span class="fragmentname"><a href="#fragment-CreateleafmonoBVHBuildNode-0">Create leaf <tt>BVHBuildNode</tt></a></span>&gt;&gt;.

</p>
<p></p>
<span class="anchor" id="fragment-CreateandreturnleafnodeofLBVHtreelet-0"></span><div class="fragmentname">&lt;&lt;Create and return leaf node of LBVH treelet&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">++*totalNodes;
BVHBuildNode *node = buildNodes++;
<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> <a href="#BVHPrimitive::bounds" class="code">bounds</a>;
int firstPrimOffset = orderedPrimsOffset-&gt;fetch_add(nPrimitives);
for (int i = 0; i &lt; nPrimitives; ++i) {
    int <a href="#MortonPrimitive::primitiveIndex" class="code">primitiveIndex</a> = mortonPrims[i].<a href="#MortonPrimitive::primitiveIndex" class="code">primitiveIndex</a>;
    orderedPrims[firstPrimOffset + i] = primitives[<a href="#MortonPrimitive::primitiveIndex" class="code">primitiveIndex</a>];
    <a href="#BVHPrimitive::bounds" class="code">bounds</a> = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(<a href="#BVHPrimitive::bounds" class="code">bounds</a>, bvhPrimitives[<a href="#MortonPrimitive::primitiveIndex" class="code">primitiveIndex</a>].<a href="#BVHPrimitive::bounds" class="code">bounds</a>);
}
node-&gt;<a href="#BVHBuildNode::InitLeaf" class="code">InitLeaf</a>(firstPrimOffset, nPrimitives, <a href="#BVHPrimitive::bounds" class="code">bounds</a>);
return node;</div><p>


</p>
<p>It may be the case that all the primitives lie on the same side of the
splitting plane; since the primitives are sorted by their Morton index,
this case can be efficiently checked by seeing if the first and last
primitive in the range both have the same bit value for this plane.  In
this case, <tt>emitLBVH()</tt> proceeds to the next bit without unnecessarily
creating a node.

</p>
<p></p>
<span class="anchor" id="fragment-AdvancetonextsubtreelevelifthereisnoLBVHsplitforthisbit-0"></span><div class="fragmentname">&lt;&lt;Advance to next subtree level if there is no LBVH split for this bit&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if ((mortonPrims[0].<a href="#MortonPrimitive::mortonCode" class="code">mortonCode</a> &amp; mask) ==
    (mortonPrims[nPrimitives - 1].<a href="#MortonPrimitive::mortonCode" class="code">mortonCode</a> &amp; mask))
    return <a href="#BVHAggregate::emitLBVH" class="code">emitLBVH</a>(buildNodes, bvhPrimitives, mortonPrims, nPrimitives,
                    totalNodes, orderedPrims, orderedPrimsOffset,
                    bitIndex - 1);</div><p>


</p>
<p>If there are primitives on both sides of the splitting plane, then a binary
search efficiently finds the dividing point where the <tt>bitIndex</tt>th bit goes
from&nbsp;0 to&nbsp;1 in the current set of primitives.

</p>
<p></p>
<span class="anchor" id="fragment-FindLBVHsplitpointforthisdimension-0"></span><div class="fragmentname">&lt;&lt;Find LBVH split point for this dimension&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int splitOffset = <a href="../Utilities/Mathematical_Infrastructure.html#FindInterval" class="code">FindInterval</a>(nPrimitives, [&amp;](int index) {
    return ((mortonPrims[0].mortonCode &amp; mask) ==
            (mortonPrims[index].mortonCode &amp; mask));
});
++splitOffset;
</div><p>


</p>
<p>Given the split offset, the method can now claim a node to use as an
interior node and recursively build LBVHs for both partitioned sets of
primitives.  Note a further efficiency benefit from Morton encoding:
entries in the <tt>mortonPrims</tt> array do not need to be copied or
reordered for the partition: because they are all sorted by their Morton
code value and because it is processing bits from high to low, the two
spans of primitives are already on the correct sides of the partition
plane.

</p>
<p></p>
<span class="anchor" id="fragment-CreateandreturninteriorLBVHnode-0"></span><div class="fragmentname">&lt;&lt;Create and return interior LBVH node&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">(*totalNodes)++;
BVHBuildNode *node = buildNodes++;
BVHBuildNode *lbvh[2] = {
    <a href="#BVHAggregate::emitLBVH" class="code">emitLBVH</a>(buildNodes, bvhPrimitives, mortonPrims, splitOffset,
             totalNodes, orderedPrims, orderedPrimsOffset, bitIndex - 1),
    <a href="#BVHAggregate::emitLBVH" class="code">emitLBVH</a>(buildNodes, bvhPrimitives, &amp;mortonPrims[splitOffset],
             nPrimitives - splitOffset, totalNodes, orderedPrims,
             orderedPrimsOffset, bitIndex - 1)
};
int axis = bitIndex % 3;
node-&gt;<a href="#BVHBuildNode::InitInterior" class="code">InitInterior</a>(axis, lbvh[0], lbvh[1]);
return node;</div><p>


</p>
<p>Once all the LBVH treelets have been created, <tt>buildUpperSAH()</tt>
creates a BVH of all the treelets.  Since there are generally tens or
hundreds of them (and in any case, no more than 4096), this step takes very
little time.

</p>
<p></p>
<span class="anchor" id="fragment-CreateandreturnSAHBVHfromLBVHtreelets-0"></span><div class="fragmentname">&lt;&lt;Create and return SAH BVH from LBVH treelets&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::vector&lt;BVHBuildNode *&gt; finishedTreelets;
for (LBVHTreelet &amp;treelet : treeletsToBuild)
    finishedTreelets.push_back(treelet.<a href="#LBVHTreelet::buildNodes" class="code">buildNodes</a>);
return buildUpperSAH(alloc, finishedTreelets, 0,
                     finishedTreelets.size(), totalNodes);</div><p>


</p>
<p>The implementation of <tt>buildUpperSAH()</tt> is not included here, as it
follows the same approach as fully SAH-based BVH construction, just over
treelet root nodes rather than scene primitives.

</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#CompactBVHforTraversal"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:compact-bvh"></span><span id="CompactBVHforTraversal"></span><h3>7.3.4  Compact BVH for Traversal</h3><p>



</p>
<p>Once the BVH is built, the last step is to convert it into a compact
representation&mdash;doing so improves cache, memory, and thus
overall system performance.  The final BVH is stored in a linear array in
memory.  The nodes of the original tree are laid out in depth-first order,
which means that the first child of each interior node is immediately after
the node in memory. In this case, only the offset to the second
child of each interior node must be stored
explicitly. See Figure&nbsp;<a href="#fig:bvh-linear-layout">7.11</a> for an
illustration of the relationship between tree topology and node order in
memory.

</p>
<p></p>
<span class="anchor" id="fig:bvh-linear-layout"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="pha07f11.svg" title=""><img src="pha07f11.svg" width=325 height=136 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 7.11: Linear Layout of a BVH in Memory. <span class="legend"> The nodes of the BVH
(left) are stored in memory in depth-first order (right).  Therefore, for any interior
  node of the tree (A and B in this example), the first child is found
  immediately after the parent node in memory.  The second child is found
  via an offset pointer, represented here by lines with arrows.  Leaf
  nodes of the tree (D, E, and C) have no children.
</span>
</figcaption>
</div></div><p>


</p>
<p>The <a href="#LinearBVHNode"><tt>LinearBVHNode</tt></a> structure stores the information needed to traverse
the BVH.  In addition to the bounding box for each node, for leaf nodes it
stores the offset and primitive count for the primitives in the node.  For
interior nodes, it stores the offset to the second child as well as which
of the coordinate axes the primitives were partitioned along when the
hierarchy was built; this information is used in the traversal routine
below to try to visit nodes in front-to-back order along the ray.

</p>
<p>The structure is declared to require 32-byte alignment in memory.  It could
otherwise be allocated at an alignment that was sufficient to satisfy the first
member variable, which would be 4 bytes for the <tt>Float</tt>-valued
<tt>Bounds3f::pMin::x</tt> member variable.  Because modern processor caches
are organized into cache lines of a size that is a multiple of 32, a more
stringent alignment constraint ensures that no <tt>LinearBVHNode</tt>
straddles two cache lines.  In turn, no more than a single cache miss will
be incurred when one is accessed, which improves performance.

</p>
<p></p>
<span class="anchor" id="fragment-LinearBVHNodeDefinition-0"></span><div class="fragmentname">&lt;&lt;LinearBVHNode Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">struct alignas(32) <span class="anchor" id="LinearBVHNode"></span>LinearBVHNode {
    <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> <span class="anchor" id="LinearBVHNode::bounds"></span>bounds;
    union {
        int <span class="anchor" id="LinearBVHNode::primitivesOffset"></span>primitivesOffset;    // leaf
        int <span class="anchor" id="LinearBVHNode::secondChildOffset"></span>secondChildOffset;   // interior
    };
    uint16_t <span class="anchor" id="LinearBVHNode::nPrimitives"></span>nPrimitives;  // 0 -&gt; interior node
    uint8_t <span class="anchor" id="LinearBVHNode::axis"></span>axis;          // interior node: xyz
};</div><p>


</p>
<p>The built tree is transformed to the <a href="#LinearBVHNode"><tt>LinearBVHNode</tt></a> representation by
the <tt>flattenBVH()</tt> method, which performs a depth-first
traversal and stores the nodes in memory in linear order.  It is helpful to
release the memory in the <tt>bvhPrimitives</tt> array before doing so, since
that may be a significant amount of storage for complex scenes and is no
longer needed at this point.  This is handled by the <tt>resize(0)</tt> and <tt>shrink_to_fit()</tt> calls.

</p>
<p></p>
<span class="anchor" id="fragment-ConvertBVHintocompactrepresentationinmononodesarray-0"></span><div class="fragmentname">&lt;&lt;Convert BVH into compact representation in <tt>nodes</tt> array&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">bvhPrimitives.resize(0);
bvhPrimitives.shrink_to_fit();
nodes = new LinearBVHNode[totalNodes];
int offset = 0;
<a href="#BVHAggregate::flattenBVH" class="code">flattenBVH</a>(root, &amp;offset);
</div><p>


</p>
<p>The pointer to the array of <tt>LinearBVHNode</tt>s is stored as a
<a href="#BVHAggregate"><tt>BVHAggregate</tt></a> member variable.

</p>
<p></p>
<span class="anchor" id="fragment-BVHAggregatePrivateMembers-1"></span><div class="fragmentname">&lt;&lt;BVHAggregate Private Members&gt;&gt;+=&nbsp;<a href="#fragment-BVHAggregatePrivateMembers-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">LinearBVHNode *<span class="anchor" id="BVHAggregate::nodes"></span>nodes = nullptr;</div><p>


</p>
<p>Flattening the tree to the linear representation is straightforward; the
<tt>*offset</tt> parameter tracks the current offset into the
<a href="#BVHAggregate::nodes"><tt>BVHAggregate::nodes</tt></a> array.  Note that the current node is added to the
array before any recursive calls to process its children.

</p>
<p></p>
<span class="anchor" id="fragment-BVHAggregateMethodDefinitions-4"></span><div class="fragmentname">&lt;&lt;BVHAggregate Method Definitions&gt;&gt;+=&nbsp;<a href="#fragment-BVHAggregateMethodDefinitions-3"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-BVHAggregateMethodDefinitions-5"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">int <span class="anchor" id="BVHAggregate::flattenBVH"></span>BVHAggregate::flattenBVH(BVHBuildNode *node, int *offset) {
    LinearBVHNode *linearNode = &amp;<a href="#BVHAggregate::nodes" class="code">nodes</a>[*offset];
    linearNode-&gt;<a href="#BVHBuildNode::bounds" class="code">bounds</a> = node-&gt;<a href="#BVHBuildNode::bounds" class="code">bounds</a>;
    int nodeOffset = (*offset)++;
    if (node-&gt;<a href="#BVHBuildNode::nPrimitives" class="code">nPrimitives</a> &gt; 0) {
        linearNode-&gt;<a href="#LinearBVHNode::primitivesOffset" class="code">primitivesOffset</a> = node-&gt;<a href="#BVHBuildNode::firstPrimOffset" class="code">firstPrimOffset</a>;
        linearNode-&gt;<a href="#BVHBuildNode::nPrimitives" class="code">nPrimitives</a> = node-&gt;<a href="#BVHBuildNode::nPrimitives" class="code">nPrimitives</a>;
    } else {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-CreateinteriorflattenedBVHnode-0">Create interior flattened BVH node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1118" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1118"><i></i></a><div id="fragbit-1118" class="collapse show"><div class="fragmentcode">           linearNode-&gt;<a href="#LinearBVHNode::axis" class="code">axis</a> = node-&gt;<a href="#BVHBuildNode::splitAxis" class="code">splitAxis</a>;
           linearNode-&gt;<a href="#LinearBVHNode::nPrimitives" class="code">nPrimitives</a> = 0;
           <a href="#BVHAggregate::flattenBVH" class="code">flattenBVH</a>(node-&gt;<a href="#BVHBuildNode::children" class="code">children</a>[0], offset);
           linearNode-&gt;<a href="#LinearBVHNode::secondChildOffset" class="code">secondChildOffset</a> = <a href="#BVHAggregate::flattenBVH" class="code">flattenBVH</a>(node-&gt;<a href="#BVHBuildNode::children" class="code">children</a>[1], offset);</div></div>
    }
    return nodeOffset;
}</div><p>


</p>
<p>

</p>
<p>At interior nodes, recursive calls are made to flatten the two subtrees.
The first one ends up immediately after the current node in the array, as
desired, and the offset of the second one, returned by its recursive
<tt>flattenBVH()</tt> call, is stored in this node&rsquo;s
<tt>secondChildOffset</tt> member.

</p>
<p></p>
<span class="anchor" id="fragment-CreateinteriorflattenedBVHnode-0"></span><div class="fragmentname">&lt;&lt;Create interior flattened BVH node&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">linearNode-&gt;<a href="#LinearBVHNode::axis" class="code">axis</a> = node-&gt;<a href="#BVHBuildNode::splitAxis" class="code">splitAxis</a>;
linearNode-&gt;<a href="#LinearBVHNode::nPrimitives" class="code">nPrimitives</a> = 0;
<a href="#BVHAggregate::flattenBVH" class="code">flattenBVH</a>(node-&gt;<a href="#BVHBuildNode::children" class="code">children</a>[0], offset);
linearNode-&gt;<a href="#LinearBVHNode::secondChildOffset" class="code">secondChildOffset</a> = <a href="#BVHAggregate::flattenBVH" class="code">flattenBVH</a>(node-&gt;<a href="#BVHBuildNode::children" class="code">children</a>[1], offset);</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#BoundingandIntersectionTests"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="BoundingandIntersectionTests"></span><h3>7.3.5  Bounding and Intersection Tests</h3><p>


</p>
<p>Given a built BVH, the implementation of the <tt>Bounds()</tt> method is
easy: by definition, the root node&rsquo;s bounds are the bounds of all the
primitives in the tree, so those can be returned directly.
 
</p>
<span class="anchor" id="fragment-BVHAggregateMethodDefinitions-5"></span><div class="fragmentname">&lt;&lt;BVHAggregate Method Definitions&gt;&gt;+=&nbsp;<a href="#fragment-BVHAggregateMethodDefinitions-4"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-BVHAggregateMethodDefinitions-6"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> <span class="anchor" id="BVHAggregate::Bounds"></span>BVHAggregate::Bounds() const {
    return <a href="#BVHAggregate::nodes" class="code">nodes</a>[0].<a href="#LinearBVHNode::bounds" class="code">bounds</a>;
}</div><p>


</p>
<p>The BVH traversal code is quite simple&mdash;there are no recursive function
calls and a small amount of data to maintain about the current state of
the traversal.  The <tt>Intersect()</tt> method starts by precomputing a few
values related to the ray that will be used repeatedly.

</p>
<p></p>
<span class="anchor" id="fragment-BVHAggregateMethodDefinitions-6"></span><div class="fragmentname">&lt;&lt;BVHAggregate Method Definitions&gt;&gt;+=&nbsp;<a href="#fragment-BVHAggregateMethodDefinitions-5"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">pstd::optional&lt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection" class="code">ShapeIntersection</a>&gt;
<span class="anchor" id="BVHAggregate::Intersect"></span>BVHAggregate::Intersect(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray, Float tMax) const {
    pstd::optional&lt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection" class="code">ShapeIntersection</a>&gt; si;
    <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> invDir(1 / ray.d.x, 1 / ray.d.y, 1 / ray.d.z);
    int dirIsNeg[3] = {int(invDir.x &lt; 0), int(invDir.y &lt; 0),
                       int(invDir.z &lt; 0)};
    &lt;&lt;<span class="fragmentname"><a href="#fragment-FollowraythroughBVHnodestofindprimitiveintersections-0">Follow ray through BVH nodes to find primitive intersections</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1119" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1119"><i></i></a><div id="fragbit-1119" class="collapse show"><div class="fragmentcode">       int toVisitOffset = 0, currentNodeIndex = 0;
       int nodesToVisit[64];
       while (true) {
           const LinearBVHNode *node = &amp;<a href="#BVHAggregate::nodes" class="code">nodes</a>[currentNodeIndex];
           &lt;&lt;<span class="fragmentname"><a href="#fragment-CheckrayagainstBVHnode-0">Check ray against BVH node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1120" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1120"><i></i></a><div id="fragbit-1120" class="collapse show"><div class="fragmentcode">              if (node-&gt;<a href="#LinearBVHNode::bounds" class="code">bounds</a>.<a href="../Shapes/Basic_Shape_Interface.html#Bounds3::IntersectP" class="code">IntersectP</a>(ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::o" class="code">o</a>, ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>, tMax, invDir, dirIsNeg)) {
                  if (node-&gt;<a href="#LinearBVHNode::nPrimitives" class="code">nPrimitives</a> &gt; 0) {
                      &lt;&lt;<span class="fragmentname"><a href="#fragment-IntersectraywithprimitivesinleafBVHnode-0">Intersect ray with primitives in leaf BVH node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1121" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1121"><i></i></a><div id="fragbit-1121" class="collapse show"><div class="fragmentcode">                         for (int i = 0; i &lt; node-&gt;<a href="#LinearBVHNode::nPrimitives" class="code">nPrimitives</a>; ++i) {
                             &lt;&lt;<span class="fragmentname"><a href="#fragment-CheckforintersectionwithprimitiveinBVHnode-0">Check for intersection with primitive in BVH node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1122" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1122"><i></i></a><div id="fragbit-1122" class="collapse show"><div class="fragmentcode">                                pstd::optional&lt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection" class="code">ShapeIntersection</a>&gt; primSi =
                                    <a href="#BVHAggregate::primitives" class="code">primitives</a>[node-&gt;<a href="#LinearBVHNode::primitivesOffset" class="code">primitivesOffset</a> + i].<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Intersect" class="code">Intersect</a>(ray, tMax);
                                if (primSi) {
                                    si = primSi;
                                    tMax = si-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection::tHit" class="code">tHit</a>;
                                }</div></div>
                         }
                         if (toVisitOffset == 0) break;
                         currentNodeIndex = nodesToVisit[--toVisitOffset];</div></div>
                  } else {
                      &lt;&lt;<span class="fragmentname"><a href="#fragment-PutfarBVHnodeonmononodesToVisitstackadvancetonearnode-0">Put far BVH node on <tt>nodesToVisit</tt> stack, advance to near node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1123" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1123"><i></i></a><div id="fragbit-1123" class="collapse show"><div class="fragmentcode">                         if (dirIsNeg[node-&gt;axis]) {
                            nodesToVisit[toVisitOffset++] = currentNodeIndex + 1;
                            currentNodeIndex = node-&gt;<a href="#LinearBVHNode::secondChildOffset" class="code">secondChildOffset</a>;
                         } else {
                            nodesToVisit[toVisitOffset++] = node-&gt;<a href="#LinearBVHNode::secondChildOffset" class="code">secondChildOffset</a>;
                            currentNodeIndex = currentNodeIndex + 1;
                         }</div></div>
                  }
              } else {
                  if (toVisitOffset == 0) break;
                  currentNodeIndex = nodesToVisit[--toVisitOffset];
              }</div></div>
       }</div></div>
    return si;
}</div><p>


</p>
<p>Each time the following <tt>while</tt> loop starts an
iteration, <tt>currentNodeIndex</tt> holds the offset into the <tt>nodes</tt>
array of the node to be visited.  It starts with a value of&nbsp;0, representing
the root of the tree.  The nodes that still need to be visited are stored
in the <tt>nodesToVisit[]</tt> array, which acts as a stack;
<tt>toVisitOffset</tt> holds the offset to the next free element in the
stack.  With the following traversal algorithm, the number of nodes in the
stack is never more than the maximum tree depth.  A statically allocated
stack of 64 entries is sufficient in practice. 

</p>
<p></p>
<span class="anchor" id="fragment-FollowraythroughBVHnodestofindprimitiveintersections-0"></span><div class="fragmentname">&lt;&lt;Follow ray through BVH nodes to find primitive intersections&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int toVisitOffset = 0, currentNodeIndex = 0;
int nodesToVisit[64];
while (true) {
    const LinearBVHNode *node = &amp;<a href="#BVHAggregate::nodes" class="code">nodes</a>[currentNodeIndex];
    &lt;&lt;<span class="fragmentname"><a href="#fragment-CheckrayagainstBVHnode-0">Check ray against BVH node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1124" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1124"><i></i></a><div id="fragbit-1124" class="collapse show"><div class="fragmentcode">       if (node-&gt;<a href="#LinearBVHNode::bounds" class="code">bounds</a>.<a href="../Shapes/Basic_Shape_Interface.html#Bounds3::IntersectP" class="code">IntersectP</a>(ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::o" class="code">o</a>, ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>, tMax, invDir, dirIsNeg)) {
           if (node-&gt;<a href="#LinearBVHNode::nPrimitives" class="code">nPrimitives</a> &gt; 0) {
               &lt;&lt;<span class="fragmentname"><a href="#fragment-IntersectraywithprimitivesinleafBVHnode-0">Intersect ray with primitives in leaf BVH node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1125" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1125"><i></i></a><div id="fragbit-1125" class="collapse show"><div class="fragmentcode">                  for (int i = 0; i &lt; node-&gt;<a href="#LinearBVHNode::nPrimitives" class="code">nPrimitives</a>; ++i) {
                      &lt;&lt;<span class="fragmentname"><a href="#fragment-CheckforintersectionwithprimitiveinBVHnode-0">Check for intersection with primitive in BVH node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1126" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1126"><i></i></a><div id="fragbit-1126" class="collapse show"><div class="fragmentcode">                         pstd::optional&lt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection" class="code">ShapeIntersection</a>&gt; primSi =
                             <a href="#BVHAggregate::primitives" class="code">primitives</a>[node-&gt;<a href="#LinearBVHNode::primitivesOffset" class="code">primitivesOffset</a> + i].<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Intersect" class="code">Intersect</a>(ray, tMax);
                         if (primSi) {
                             si = primSi;
                             tMax = si-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection::tHit" class="code">tHit</a>;
                         }</div></div>
                  }
                  if (toVisitOffset == 0) break;
                  currentNodeIndex = nodesToVisit[--toVisitOffset];</div></div>
           } else {
               &lt;&lt;<span class="fragmentname"><a href="#fragment-PutfarBVHnodeonmononodesToVisitstackadvancetonearnode-0">Put far BVH node on <tt>nodesToVisit</tt> stack, advance to near node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1127" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1127"><i></i></a><div id="fragbit-1127" class="collapse show"><div class="fragmentcode">                  if (dirIsNeg[node-&gt;axis]) {
                     nodesToVisit[toVisitOffset++] = currentNodeIndex + 1;
                     currentNodeIndex = node-&gt;<a href="#LinearBVHNode::secondChildOffset" class="code">secondChildOffset</a>;
                  } else {
                     nodesToVisit[toVisitOffset++] = node-&gt;<a href="#LinearBVHNode::secondChildOffset" class="code">secondChildOffset</a>;
                     currentNodeIndex = currentNodeIndex + 1;
                  }</div></div>
           }
       } else {
           if (toVisitOffset == 0) break;
           currentNodeIndex = nodesToVisit[--toVisitOffset];
       }</div></div>
}</div><p>


</p>
<p></p>
<span class="anchor" id="fig:bvh-number-of-nodes-visited"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="pha07f12.svg" title=""><img src="pha07f12.svg" width=771 height=1123 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 7.12: Visualization of BVH Performance with the <em>Kroken</em> Scene. <span class="legend">
(a)&nbsp;Number of BVH nodes visited when tracing the camera ray at each pixel
for the scene shown in Figure&nbsp;<a href="../Introduction.html#fig:pbrt-kroken-view">1.1</a>.
Not only are more nodes visited in geometrically complex regions of the
scene such as the rug, but objects that are not accurately
bounded by axis-aligned bounding boxes such as the support under the bottom
shelf lead to many nodes being visited.
(b)&nbsp;Number of ray&ndash;triangle intersection tests performed for the camera ray
at each pixel.  The BVH is effective at limiting the
number of intersection tests even in highly complex regions of the scene
like the rug.  However, objects that are poorly fit by axis-aligned
bounding boxes lead to many intersection tests for rays in their vicinity.
<em>(Kroken scene courtesy of Angelo Ferretti.)</em>
</span>
</figcaption>
</div></div><p>


</p>
<p> </p>
<span class="anchor" id="fig:moana-bvh-number-of-nodes-visited"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="pha07f13.svg" title=""><img src="pha07f13.svg" width=967 height=854 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 7.13: Visualization of BVH Performance with the <em>Moana Island</em> Scene. <span class="legend">
(a)&nbsp;Number of BVH nodes visited when tracing the camera ray at each pixel
for the scene shown in Figure&nbsp;<a href="../Introduction/Photorealistic_Rendering_and_the_Ray-Tracing_Algorithm.html#fig:moana-island-view">1.4</a>.
As with the <em>Kroken</em> scene, silhouette edges and regions where the ray passes
by many objects before finding an intersection see the most nodes visited.
(b)&nbsp;Number of ray&ndash;triangle intersection tests performed for the camera ray
at each pixel.  The most geometrically complex trees and the detailed
ground cover on the beach require the most intersection tests.
<em>(Scene courtesy of Walt Disney Animation Studios.)</em>
</span>
</figcaption>
</div></div><p>


</p>
<p>At each node, the first step is to check if the ray intersects the node&rsquo;s
bounding box (or starts inside of it).  The node is visited if so, with its
primitives tested for intersection if it is a leaf node or its children are
visited if it is an interior node.  If no intersection is found, then the
offset of the next node to be visited is retrieved from
<tt>nodesToVisit[]</tt> (or traversal is complete if the stack is empty).
See Figures&nbsp;<a href="#fig:bvh-number-of-nodes-visited">7.12</a>
and&nbsp;<a href="#fig:moana-bvh-number-of-nodes-visited">7.13</a> for visualizations of how many
nodes are visited and how many intersection tests are performed at each
pixel for two complex scenes.

</p>
<p></p>
<span class="anchor" id="fragment-CheckrayagainstBVHnode-0"></span><div class="fragmentname">&lt;&lt;Check ray against BVH node&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (node-&gt;<a href="#LinearBVHNode::bounds" class="code">bounds</a>.<a href="../Shapes/Basic_Shape_Interface.html#Bounds3::IntersectP" class="code">IntersectP</a>(ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::o" class="code">o</a>, ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>, tMax, invDir, dirIsNeg)) {
    if (node-&gt;<a href="#LinearBVHNode::nPrimitives" class="code">nPrimitives</a> &gt; 0) {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-IntersectraywithprimitivesinleafBVHnode-0">Intersect ray with primitives in leaf BVH node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1128" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1128"><i></i></a><div id="fragbit-1128" class="collapse show"><div class="fragmentcode">           for (int i = 0; i &lt; node-&gt;<a href="#LinearBVHNode::nPrimitives" class="code">nPrimitives</a>; ++i) {
               &lt;&lt;<span class="fragmentname"><a href="#fragment-CheckforintersectionwithprimitiveinBVHnode-0">Check for intersection with primitive in BVH node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1129" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1129"><i></i></a><div id="fragbit-1129" class="collapse show"><div class="fragmentcode">                  pstd::optional&lt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection" class="code">ShapeIntersection</a>&gt; primSi =
                      <a href="#BVHAggregate::primitives" class="code">primitives</a>[node-&gt;<a href="#LinearBVHNode::primitivesOffset" class="code">primitivesOffset</a> + i].<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Intersect" class="code">Intersect</a>(ray, tMax);
                  if (primSi) {
                      si = primSi;
                      tMax = si-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection::tHit" class="code">tHit</a>;
                  }</div></div>
           }
           if (toVisitOffset == 0) break;
           currentNodeIndex = nodesToVisit[--toVisitOffset];</div></div>
    } else {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-PutfarBVHnodeonmononodesToVisitstackadvancetonearnode-0">Put far BVH node on <tt>nodesToVisit</tt> stack, advance to near node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1130" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1130"><i></i></a><div id="fragbit-1130" class="collapse show"><div class="fragmentcode">           if (dirIsNeg[node-&gt;axis]) {
              nodesToVisit[toVisitOffset++] = currentNodeIndex + 1;
              currentNodeIndex = node-&gt;<a href="#LinearBVHNode::secondChildOffset" class="code">secondChildOffset</a>;
           } else {
              nodesToVisit[toVisitOffset++] = node-&gt;<a href="#LinearBVHNode::secondChildOffset" class="code">secondChildOffset</a>;
              currentNodeIndex = currentNodeIndex + 1;
           }</div></div>
    }
} else {
    if (toVisitOffset == 0) break;
    currentNodeIndex = nodesToVisit[--toVisitOffset];
}</div><p>


</p>
<p>If the current node is a leaf, then the ray must be tested for intersection
with the primitives inside it.  The next node to visit is then found from
the <tt>nodesToVisit</tt> stack; even if an intersection is found in the
current node, the remaining nodes must be visited in case one of them
yields a closer intersection.

</p>
<p></p>
<span class="anchor" id="fragment-IntersectraywithprimitivesinleafBVHnode-0"></span><div class="fragmentname">&lt;&lt;Intersect ray with primitives in leaf BVH node&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">for (int i = 0; i &lt; node-&gt;<a href="#LinearBVHNode::nPrimitives" class="code">nPrimitives</a>; ++i) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-CheckforintersectionwithprimitiveinBVHnode-0">Check for intersection with primitive in BVH node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1131" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1131"><i></i></a><div id="fragbit-1131" class="collapse show"><div class="fragmentcode">       pstd::optional&lt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection" class="code">ShapeIntersection</a>&gt; primSi =
           <a href="#BVHAggregate::primitives" class="code">primitives</a>[node-&gt;<a href="#LinearBVHNode::primitivesOffset" class="code">primitivesOffset</a> + i].<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Intersect" class="code">Intersect</a>(ray, tMax);
       if (primSi) {
           si = primSi;
           tMax = si-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection::tHit" class="code">tHit</a>;
       }</div></div>
}
if (toVisitOffset == 0) break;
currentNodeIndex = nodesToVisit[--toVisitOffset];</div><p>


</p>
<p>

</p>
<p>If an intersection is found, the <tt>tMax</tt> value can be updated to the
intersection&rsquo;s parametric distance along the ray; this makes it possible to efficiently discard any
remaining nodes that are farther away than the intersection.

</p>
<p></p>
<span class="anchor" id="fragment-CheckforintersectionwithprimitiveinBVHnode-0"></span><div class="fragmentname">&lt;&lt;Check for intersection with primitive in BVH node&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">pstd::optional&lt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection" class="code">ShapeIntersection</a>&gt; primSi =
    <a href="#BVHAggregate::primitives" class="code">primitives</a>[node-&gt;<a href="#LinearBVHNode::primitivesOffset" class="code">primitivesOffset</a> + i].<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Intersect" class="code">Intersect</a>(ray, tMax);
if (primSi) {
    si = primSi;
    tMax = si-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection::tHit" class="code">tHit</a>;
}</div><p>


</p>
<p>For an interior node that the ray hits, it is necessary to visit both of
its children.  As described above, it is desirable to visit the first child
that the ray passes through before visiting the second one in case
the ray intersects a primitive in the first one.  If so, the ray&rsquo;s
<tt>tMax</tt> value can be updated, thus reducing the ray&rsquo;s extent and thus
the number of node bounding boxes it intersects.

</p>
<p>An efficient way to perform a front-to-back traversal without incurring the
expense of intersecting the ray with both child nodes and comparing the
distances is to use the sign of the ray&rsquo;s direction vector for the
coordinate axis along which primitives were partitioned for the current
node: if the sign is negative, we should visit the second child before the
first child, since the primitives that went into the second child&rsquo;s subtree
were on the upper side of the partition point.  (And conversely for a
positive-signed direction.)  Doing this is straightforward: the offset for
the node to be visited first is copied to <tt>currentNodeIndex</tt>, and the offset for the
other node is added to the <tt>nodesToVisit</tt> stack.  (Recall that the first child
is immediately after the current node due to the depth-first layout of
nodes in memory.)

</p>
<p></p>
<span class="anchor" id="fragment-PutfarBVHnodeonmononodesToVisitstackadvancetonearnode-0"></span><div class="fragmentname">&lt;&lt;Put far BVH node on <tt>nodesToVisit</tt> stack, advance to near node&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (dirIsNeg[node-&gt;axis]) {
   nodesToVisit[toVisitOffset++] = currentNodeIndex + 1;
   currentNodeIndex = node-&gt;<a href="#LinearBVHNode::secondChildOffset" class="code">secondChildOffset</a>;
} else {
   nodesToVisit[toVisitOffset++] = node-&gt;<a href="#LinearBVHNode::secondChildOffset" class="code">secondChildOffset</a>;
   currentNodeIndex = currentNodeIndex + 1;
}</div><p>


</p>
<p>The <span class="anchor" id="BVHAggregate::IntersectP"></span> <tt>BVHAggregate::IntersectP()</tt>
method is essentially the same as the regular intersection method, with the
two differences that <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive"><tt>Primitive</tt></a>&rsquo;s <tt>IntersectP()</tt> methods
are called rather than <tt>Intersect()</tt>, and traversal stops immediately
when any intersection is found.  It is thus not included here.

</p>
<p>

</p>
<p>

</p>
<p>

</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

</div>  <!-- container-fluid -->
</div>  <!-- maincontainer -->

<nav class="navbar navbar-expand-md bg-light navbar-light">
<div class="container-fluid">
  <span class="navbar-text"><i>Physically Based Rendering: From Theory To Implementation</i>,<br>
<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">&copy; 2004-2023</a> Matt Pharr, Wenzel Jakob, and Greg Humphreys.
<a href="https://github.com/mmp/pbr-book-website/"><span class="fab fa-github"></span></a><br>
Purchase a printed copy: <a href="https://www.amazon.com/Physically-Based-Rendering-fourth-Implementation/dp/0262048027?keywords=physically+based+rendering+4th+edition&qid=1671730412&sprefix=physically+based%!C(MISSING)aps%!C(MISSING)145&sr=8-1&linkCode=ll1&tag=pharr-20&linkId=81a816d90f0c7e872617f1f930a51fd6&language=en_US&ref_=as_li_ss_tl"><span class="fab fa-amazon"></span></a>
<a href="https://mitpress.mit.edu/9780262048026/physically-based-rendering/"><img src="/mitpress.png" width=10 height=16></a>
</span>
</div>
  <div class="container">
    <ul class="nav navbar-nav ml-auto">
      <li class="nav-item">Next: <a href="../Primitives_and_Intersection_Acceleration/Further_Reading.html">Primitives and Intersection Acceleration / Further Reading</a></li>
    </ul>
  </div>

</nav>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script>
  $(function () {
    $('[data-toggle="popover"]').popover()
    $('[data-toggle="tooltip"]').tooltip()
   })
</script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

<script>
// https://stackoverflow.com/a/17535094
// The function actually applying the offset
function offsetAnchor() {
  if (location.hash.length !== 0) {
    window.scrollTo(window.scrollX, window.scrollY - window.innerHeight / 8);
  }
}

// Captures click events of all <a> elements with href starting with #
$(document).on('click', 'a[href^="#"]', function(event) {
  // Click events are captured before hashchanges. Timeout
  // causes offsetAnchor to be called after the page jump.
  window.setTimeout(function() {
    offsetAnchor();
  }, 500);
});

// Set the offset when entering page with hash present in the url
window.setTimeout(offsetAnchor, 1500);
</script>

</body>
</html>
