
<!doctype html>
<html lang="en">
<head>

<!-- all praise to https://realfavicongenerator.net -->
<link rel="icon" href="/favicon.ico?v=2" /> <!-- force refresh -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="/fonts.css">
  <link rel="stylesheet" href="../pbrstyle.css">
  <link rel="stylesheet" href="/fontawesome-free-5.15.3-web/css/all.css">

<script async src="https://cse.google.com/cse.js?cx=22a43cef261a245ea"></script>  <script src="/react.min.js"></script>
  <script src="/react-dom.min.js"></script>
  <script src="/jeri.min.js"></script>
  <link rel="preload" href="/exr.worker.js" as="script" crossorigin="anonymous">
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/bootstrap.min.css">

  <title>pbrt: System Overview</title>
</head>
        
<body>

<nav class="fixed-top-lg-navbar navbar navbar-expand bg-light navbar-light">
  <ul class="nav navbar-nav">
    <a class="navbar-brand" href="../contents.html"><img src="../pbr.jpg" width=25 height=25></a>
    <li class="nav-item"><a class="nav-link" href="../Introduction.html">Introduction</a></li>
    <span class="navbar-text">/</span>
    <li class="nav-item"><a class="nav-link" href="#">pbrt: System Overview</a></li>
    <span class="navbar-text">&nbsp;&nbsp;</span>
    <li class="nav-item"><a class="nav-link" href="../Introduction/Photorealistic_Rendering_and_the_Ray-Tracing_Algorithm.html">(Previous: Photorealistic Rendering and the Ray-Tracing Algorithm)</a></li>
  </ul>

  <ul class="nav navbar-nav ml-auto d-none d-md-block">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
  <ul class="nav navbar-nav d-block d-md-none">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
</nav>

<div class="maincontainer">
<div class="container-fluid">

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#"><i class="fas fa-link "></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:pbrt-system-overview"></span><h2>1.3 pbrt: System Overview</h2><p>



</p>
<p> <tt>pbrt</tt> is structured using standard object-oriented techniques:
for each of a number of fundamental types, the system specifies an interface
that implementations of that type must fulfill.  For example, <tt>pbrt</tt> requires the implementation of a particular shape that represents
geometry in a scene to provide a set of methods including one that returns the
shape&rsquo;s bounding box, and another that tests for intersection with a given ray.  In
turn, the majority of the system can be implemented purely in terms of
those interfaces; for example, the code that checks for occluding objects
between a light source and a point being shaded calls the shape
intersection methods without needing to consider which particular types of
shapes are present in the scene.

</p>
<p>

</p>
<p>
 </p>
<span class="anchor" id="fig:plug-in-types"></span><div class="card outerfigure"><div class="card-body figure"><p>

</p>
<figcaption class="caption">Table 1.1: Main Interface Types. <span class="legend"> Most of <tt>pbrt</tt> is implemented in
  terms of 14 key base types, listed here.  Implementations of
  each of these can easily be added to the system to extend its
  functionality.
</span>
</figcaption><p>


<table class="table table-hover table-light table-sm"><thead><tr>
<th>Base type</th><th> Source Files</th><th> Section</th></tr>
</thead>
<tbody>
<tr>
<td><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#Spectrum"><tt>Spectrum</tt></a></td><td> <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/base/spectrum.h"><tt>base/spectrum.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/util/spectrum.h"><tt>util/spectrum.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/util/spectrum.cpp"><tt>util/spectrum.cpp</tt></a></td><td> <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#sec:spectrum">4.5</a></td></tr>
<tr>
<td><a href="../Cameras_and_Film/Camera_Interface.html#Camera"><tt>Camera</tt></a></td><td> <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/base/camera.h"><tt>base/camera.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/cameras.h"><tt>cameras.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/cameras.cpp"><tt>cameras.cpp</tt></a></td><td> <a href="../Cameras_and_Film/Camera_Interface.html#sec:camera-model">5.1</a></td></tr>
<tr>
<td><a href="../Shapes/Basic_Shape_Interface.html#Shape"><tt>Shape</tt></a> </td><td> <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/base/shape.h"><tt>base/shape.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/shapes.h"><tt>shapes.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/shapes.cpp"><tt>shapes.cpp</tt></a> </td><td> <a href="../Shapes/Basic_Shape_Interface.html#sec:shape-interface">6.1</a></td></tr>
<tr>
<td><a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive"><tt>Primitive</tt></a></td><td> <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/cpu/primitive.h"><tt>cpu/primitive.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/cpu/primitive.cpp"><tt>cpu/primitive.cpp</tt></a>,<a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/cpu/accelerators.h"><tt>cpu/accelerators.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/cpu/accelerators.cpp"><tt>cpu/accelerators.cpp</tt></a>, </td><td> <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#sec:primitives">7.1</a></td></tr>
<tr>
<td><a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a></td><td> <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/base/sampler.h"><tt>base/sampler.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/samplers.h"><tt>samplers.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/samplers.cpp"><tt>samplers.cpp</tt></a></td><td> <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#sec:sampling-interface">8.3</a></td></tr>
<tr>
<td><a href="../Sampling_and_Reconstruction/Image_Reconstruction.html#Filter"><tt>Filter</tt></a></td><td> <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/base/filter.h"><tt>base/filter.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/filters.h"><tt>filters.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/filters.cpp"><tt>filters.cpp</tt></a></td><td> <a href="../Sampling_and_Reconstruction/Image_Reconstruction.html#sec:filter-interface">8.8.1</a></td></tr>
<tr>
<td><a href="../Reflection_Models/BSDF_Representation.html#BxDF"><tt>BxDF</tt></a></td><td> <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/base/bxdf.h"><tt>base/bxdf.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/bxdfs.h"><tt>bxdfs.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/bxdfs.cpp"><tt>bxdfs.cpp</tt></a></td><td> <a href="../Reflection_Models/BSDF_Representation.html#sec:bxdf-interface">9.1.2</a></td></tr>
<tr>
<td><a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material"><tt>Material</tt></a></td><td> <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/base/material.h"><tt>base/material.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/materials.h"><tt>materials.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/materials.cpp"><tt>materials.cpp</tt></a></td><td> <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#sec:material-interface">10.5</a></td></tr>
<tr>
<td><a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture"><tt>FloatTexture</tt></a></td><td> </td><td></td></tr>
<tr>
<td><a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#SpectrumTexture"><tt>SpectrumTexture</tt></a></td><td> <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/base/texture.h"><tt>base/texture.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/textures.h"><tt>textures.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/textures.cpp"><tt>textures.cpp</tt></a></td><td> <a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#sec:texture-interface">10.3</a></td></tr>
<tr>
<td><a href="../Volume_Scattering/Media.html#Medium"><tt>Medium</tt></a></td><td> <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/base/medium.h"><tt>base/medium.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/media.h"><tt>media.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/media.cpp"><tt>media.cpp</tt></a></td><td> <a href="../Volume_Scattering/Media.html#sec:media">11.4</a></td></tr>
<tr>
<td><a href="../Light_Sources/Light_Interface.html#Light"><tt>Light</tt></a></td><td> <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/base/light.h"><tt>base/light.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/lights.h"><tt>lights.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/lights.cpp"><tt>lights.cpp</tt></a></td><td> <a href="../Light_Sources/Light_Interface.html#sec:light">12.1</a></td></tr>
<tr>
<td><a href="../Light_Sources/Light_Sampling.html#LightSampler"><tt>LightSampler</tt></a></td><td> <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/base/lightsampler.h"><tt>base/lightsampler.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/lightsamplers.h"><tt>lightsamplers.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/lightsamplers.cpp"><tt>lightsamplers.cpp</tt></a></td><td> <a href="../Light_Sources/Light_Sampling.html#sec:light-sampling">12.6</a></td></tr>
<tr>
<td><a href="#Integrator"><tt>Integrator</tt></a> </td><td> <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/cpu/integrators.h"><tt>cpu/integrators.h</tt></a>, <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/cpu/integrators.cpp"><tt>cpu/integrators.cpp</tt></a></td><td> <a href="#sec:integrator-intro">1.3.3</a> </td></tr>
</tbody></table>

</p>
</div></div><p>



</p>
<p>There are a total of 14 of these key base types, summarized in
Table&nbsp;<a href="#fig:plug-in-types">1.1</a>.  Adding a new implementation of one of these
types to the system is straightforward; the implementation must provide the
required methods, it must be compiled and linked into the executable, and the scene
object creation routines must be
modified to create instances of the object as needed as the scene
description file is parsed.  Section&nbsp;<a href="../Processing_the_Scene_Description/Adding_New_Object_Implementations.html#sec:adding-plugins">C.4</a> discusses
extending the system in more&nbsp;detail.

</p>
<p>Conventional practice in C++ would be to specify the interfaces for each of
these types using abstract base classes that define pure virtual functions
and to have implementations inherit from those base classes and implement
the required virtual functions.  In turn, the compiler would take care of
generating the code that calls the appropriate method, given a pointer to any
object of the base class type.  That approach was
used in the three previous versions of <tt>pbrt</tt>, but the addition of support
for rendering on graphics processing units (GPUs) in this version motivated
a more portable approach based on <em>tag-based dispatch</em>, where each
specific type implementation is assigned a unique integer that determines
its type at runtime.  (See Section&nbsp;<a href="../Introduction/Using_and_Understanding_the_Code.html#sec:dynamic-dispatch">1.5.7</a> for
more information about this topic.)
The polymorphic types that are implemented in this way in <tt>pbrt</tt> are all
defined in header files in the <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/base/"><tt>base/</tt></a> directory.

</p>
<p>This version of <tt>pbrt</tt> is capable of running on GPUs that support C++17 and
provide APIs for ray intersection tests.<button style="button" data-toggle="tooltip" data-placement="right" data-html="true" class="btn footnote-button" title="At the time of writing, these
capabilities are only available on NVIDIA hardware, but it would not be too
difficult to port <tt>pbrt</tt> to other architectures that provide them in the future.">
      <sup>&dagger;</sup>
    </button>
		
We have
carefully designed the system so that almost all of <tt>pbrt</tt>&rsquo;s implementation runs on
both CPUs and GPUs, just as it is presented in Chapters&nbsp;<a href="../Monte_Carlo_Integration.html#chap:mc">2</a>
through&nbsp;<a href="../Light_Sources.html#chap:lights">12</a>. We
will therefore generally say little about the CPU versus the GPU in most of the
following.

</p>
<p>The main differences between the CPU and GPU rendering paths in <tt>pbrt</tt> are
in their data flow and how they are parallelized&mdash;effectively, how the
pieces are connected together.  Both the basic rendering algorithm
described later in this chapter and the light transport algorithms described
in Chapters&nbsp;<a href="../Light_Transport_I_Surface_Reflection.html#chap:light-transport">13</a>


and&nbsp;<a href="../Light_Transport_II_Volume_Rendering.html#chap:volume-integration">14</a>

are
only available on the CPU.  The GPU rendering pipeline is discussed in
Chapter&nbsp;<a href="../Wavefront_Rendering_on_GPUs.html#chap:gpu">15</a>, though it, too, is also capable of running on the
CPU (not as efficiently as the CPU-targeted light transport algorithms,
however).

</p>
<p>While <tt>pbrt</tt> can render many scenes well with its current implementation,
it has frequently been extended by students, researchers, and developers.
Throughout this section are a number of notable images from those efforts.
Figures&nbsp;<a href="#fig:competition-snow">1.13</a>, <a href="#fig:ice-cave">1.14</a>,
and&nbsp;<a href="#fig:cotton-candy">1.15</a> were each created by students in a rendering
course where the final class project was to extend <tt>pbrt</tt> with new
functionality in order to render an image that it could not have rendered
before.  These images are
among the best from that course.

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fig:competition-snow"></span><div class="card outerfigure"><div class="card-body figure"><p>


</p>
<div class="figure-row">
<img src="nightsnow.png" style="max-width: 100%; height: auto;" width=1369 height=1027>
</div>
<p>

</p>
<figcaption class="caption">Figure 1.13: <span class="legend"> Guillaume Poncin and Pramod
Sharma extended <tt>pbrt</tt> in numerous ways, implementing a number of complex
rendering algorithms, to make this prize-winning image for Stanford&rsquo;s
CS348b rendering competition.  The trees are
modeled procedurally with L-systems, a glow image processing filter
increases the apparent realism of the lights on the tree, snow was modeled
procedurally with metaballs, and a subsurface scattering algorithm gave
the snow its realistic appearance by accounting for the effect of light
that travels beneath the snow for some distance before leaving it.</span>
</figcaption>
</div></div><p>


</p>
<p></p>
<span class="anchor" id="fig:ice-cave"></span><div class="card outerfigure"><div class="card-body figure"><p>


</p>
<div class="figure-row">
<img src="icecave.png" style="max-width: 100%; height: auto;" width=1388 height=1388>
</div>
<p>

</p>
<figcaption class="caption">Figure 1.14: <span class="legend">
Abe Davis, David Jacobs, and Jongmin Baek rendered this amazing image of an
ice cave to take the grand prize in the 2009 Stanford CS348b rendering
competition.
They first implemented a simulation of the physical process of glaciation,
the process where snow falls, melts, and refreezes over the course of many
years, forming stratified layers of ice.  They then simulated erosion of
the ice due to melted water runoff before generating a geometric model of
the ice.  Scattering of light inside the volume was simulated with
volumetric photon mapping; the blue color of the ice is entirely due to
modeling the wavelength-dependent absorption of light in the ice volume.
</span>
</figcaption>
</div></div><p>


</p>
<p></p>
<span class="anchor" id="fig:cotton-candy"></span><div class="card outerfigure"><div class="card-body figure"><p>


</p>
<div class="figure-row">
<img src="cotton_candy.png" style="max-width: 100%; height: auto;" width=1920 height=1080>
</div>
<p>

</p>
<figcaption class="caption">Figure 1.15: <span class="legend">
Chenlin Meng, Hubert Teo, and Jiren Zhu rendered this tasty-looking image
of cotton candy in a teacup to win the grand prize in the 2018 Stanford
CS348b rendering competition.  They modeled the cotton candy with multiple
layers of curves and then filled the center with a participating medium to
efficiently model scattering in its interior.</span>
</figcaption>
</div></div><p>


</p>
<p></p>
<span class="anchor" id="fig:imperial-crown"></span><div class="card outerfigure"><div class="card-body figure"><p>


</p>
<div class="figure-row">
<img src="crown.png" style="max-width: 100%; height: auto;" width=1000 height=1400>
</div>
<p>

</p>
<figcaption class="caption">Figure 1.16: <span class="legend">
Martin Lubich modeled this scene of the Austrian Imperial Crown using
<em>Blender</em>; it was originally rendered using <em>LuxRender,</em> which started
out as a fork of the <tt>pbrt-v1</tt> codebase.
The crown consists of approximately 3.5 million triangles that are 
illuminated by six area light sources with emission spectra based on
measured data from a real-world light source.  It was originally rendered
with 1280 samples per pixel in 73 hours of computation on a quad-core CPU.
On a modern GPU, <tt>pbrt</tt> renders this scene at the same sampling rate in 184
seconds.
</span>
</figcaption>
</div></div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#PhasesofExecution"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="PhasesofExecution"></span><h3>1.3.1  Phases of Execution</h3><p>


</p>
<p> <tt>pbrt</tt> can be conceptually divided into three phases of
execution.  First, it parses the scene description file provided by the
user.  The scene description is a text file that specifies the geometric
shapes that make up the scene, their material properties, the lights that
illuminate them, where the virtual camera is positioned in the scene, and
parameters to all the individual algorithms used throughout the system.
The scene file format is documented on the <tt>pbrt</tt> website,
<a href="https://pbrt.org">pbrt.org</a>.

</p>
<p>The result of the parsing phase is an instance of the <a href="../Processing_the_Scene_Description/BasicScene_and_Final_Object_Creation.html#BasicScene"><tt>BasicScene</tt></a>
class, which stores the scene specification, but not in a form yet suitable
for rendering.  In the second phase of execution, <tt>pbrt</tt> creates specific objects
corresponding to the scene; for example, if a perspective projection has
been specified, it is in this phase that a <a href="../Cameras_and_Film/Projective_Camera_Models.html#PerspectiveCamera"><tt>PerspectiveCamera</tt></a> object
corresponding to the specified viewing parameters is created.  Previous
versions of <tt>pbrt</tt> intermixed these first two phases, but for this version
we have separated them because the CPU and GPU rendering paths differ
in some of the ways that they represent the scene in memory.

</p>
<p>In the third phase, the main rendering loop executes. This
phase is where <tt>pbrt</tt> usually spends the majority of its running time, and
most of this book is devoted to code that executes during this phase.
To orchestrate the rendering, <tt>pbrt</tt> implements an <em>integrator</em>,
so-named because its main task is to evaluate the integral in
Equation&nbsp;(<a href="../Introduction/Photorealistic_Rendering_and_the_Ray-Tracing_Algorithm.html#eq:rendering-equation">1.1</a>).

</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#xttpbrtttrsquosmainFunction"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:pbrt-main"></span><span id="xttpbrtttrsquosmainFunction"></span><h3>1.3.2  <tt>pbrt</tt>&rsquo;s main() Function</h3><p>



</p>
<p>The <tt>main()</tt> function for the <tt>pbrt</tt> executable is defined in the file
<a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/cmd/pbrt.cpp"><tt>cmd/pbrt.cpp</tt></a> in the directory that holds the <tt>pbrt</tt> source
code, <tt>src/pbrt</tt> in the <tt>pbrt</tt> distribution.  It is only a hundred and
fifty or so lines of code, much of it devoted to processing command-line
arguments and related bookkeeping.

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-mainprogram-0"></span><div class="fragmentname">&lt;&lt;main program&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int <span class="anchor" id="main"></span>main(int argc, char *argv[]) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Convertcommand-lineargumentstovectorofstrings-0">Convert command-line arguments to vector of strings</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-5" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-5"><i></i></a><div id="fragbit-5" class="collapse show"><div class="fragmentcode">       std::vector&lt;std::string&gt; args = <a href="../Utilities/User_Interaction.html#GetCommandLineArguments" class="code">GetCommandLineArguments</a>(argv);</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Declarevariablesforparsedcommandline-0">Declare variables for parsed command line</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-6" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-6"><i></i></a><div id="fragbit-6" class="collapse show"><div class="fragmentcode">       <a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#PBRTOptions" class="code">PBRTOptions</a> options;
       std::vector&lt;std::string&gt; filenames;
       </div></div>
    &lt;&lt;<span class="fragmentname">Process command-line arguments</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-7" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-7"><i></i></a><div id="fragbit-7" class="collapse show"><div class="fragmentcode">       for (auto iter = args.begin(); iter != args.end(); ++iter) {
               if ((*iter)[0] != '-') {
                   filenames.push_back(*iter);
                   continue;
               }
       
               auto onError = [](const std::string &amp;err) {
                   usage(err);
                   exit(1);
               };
       
               std::string cropWindow, pixelBounds, pixel, pixelMaterial;
               if (ParseArg(&amp;iter, args.end(), "cropwindow", &amp;cropWindow, onError)) {
                   std::vector&lt;Float&gt; c = SplitStringToFloats(cropWindow, ',');
                   if (c.size() != 4) {
                       usage("Didn't find four values after --cropwindow");
                       return 1;
                   }
                   options.cropWindow = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2f" class="code">Bounds2f</a>(<a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(c[0], c[2]), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(c[1], c[3]));
               } else if (ParseArg(&amp;iter, args.end(), "pixel", &amp;pixel, onError)) {
                   std::vector&lt;int&gt; p = SplitStringToInts(pixel, ',');
                   if (p.size() != 2) {
                       usage("Didn't find two values after --pixel");
                       return 1;
                   }
                   options.pixelBounds =
                       <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2i" class="code">Bounds2i</a>(<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a>(p[0], p[1]), <a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a>(p[0] + 1, p[1] + 1));
               } else if (ParseArg(&amp;iter, args.end(), "pixelbounds", &amp;pixelBounds, onError)) {
                   std::vector&lt;int&gt; p = SplitStringToInts(pixelBounds, ',');
                   if (p.size() != 4) {
                       usage("Didn't find four integer values after --pixelbounds");
                       return 1;
                   }
                   options.pixelBounds = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2i" class="code">Bounds2i</a>(<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a>(p[0], p[2]), <a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a>(p[1], p[3]));
               } else if (ParseArg(&amp;iter, args.end(), "pixelmaterial", &amp;pixelMaterial, onError)) {
                   std::vector&lt;int&gt; p = SplitStringToInts(pixelMaterial, ',');
                   if (p.size() != 2) {
                       usage("Didn't find two values after --pixelmaterial");
                       return 1;
                   }
                   options.pixelMaterial = <a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a>(p[0], p[1]);
               } else if (
       #ifdef PBRT_BUILD_GPU_RENDERER
                   ParseArg(&amp;iter, args.end(), "gpu", &amp;options.useGPU, onError) ||
                   ParseArg(&amp;iter, args.end(), "gpu-device", &amp;options.gpuDevice, onError) ||
       #endif
                   ParseArg(&amp;iter, args.end(), "debugstart", &amp;options.debugStart, onError) ||
                   ParseArg(&amp;iter, args.end(), "disable-pixel-jitter", &amp;options.disablePixelJitter,
                            onError) ||
                   ParseArg(&amp;iter, args.end(), "disable-texture-filtering",
                            &amp;options.disableTextureFiltering, onError) ||
                   ParseArg(&amp;iter, args.end(), "disable-wavelength-jitter", &amp;options.disableWavelengthJitter,
                            onError) ||
                   ParseArg(&amp;iter, args.end(), "displacement-edge-scale",
                            &amp;options.displacementEdgeScale, onError) ||
                   ParseArg(&amp;iter, args.end(), "display-server", &amp;options.displayServer, onError) ||
                   ParseArg(&amp;iter, args.end(), "force-diffuse", &amp;options.forceDiffuse, onError) ||
                   ParseArg(&amp;iter, args.end(), "format", &amp;format, onError) ||
                   ParseArg(&amp;iter, args.end(), "log-level", &amp;logLevel, onError) ||
                   ParseArg(&amp;iter, args.end(), "log-utilization", &amp;options.logUtilization, onError) ||
                   ParseArg(&amp;iter, args.end(), "log-file", &amp;options.logFile, onError) ||
                   ParseArg(&amp;iter, args.end(), "mse-reference-image", &amp;options.mseReferenceImage, onError) ||
                   ParseArg(&amp;iter, args.end(), "mse-reference-out", &amp;options.mseReferenceOutput, onError) ||
                   ParseArg(&amp;iter, args.end(), "nthreads", &amp;options.nThreads, onError) ||
                   ParseArg(&amp;iter, args.end(), "outfile", &amp;options.imageFile, onError) ||
                   ParseArg(&amp;iter, args.end(), "pixelstats", &amp;options.recordPixelStatistics, onError) ||
                   ParseArg(&amp;iter, args.end(), "quick", &amp;options.quickRender, onError) ||
                   ParseArg(&amp;iter, args.end(), "quiet", &amp;options.quiet, onError) ||
                   ParseArg(&amp;iter, args.end(), "render-coord-sys", &amp;renderCoordSys, onError) ||
                   ParseArg(&amp;iter, args.end(), "seed", &amp;options.seed, onError) ||
                   ParseArg(&amp;iter, args.end(), "spp", &amp;options.pixelSamples, onError) ||
                   ParseArg(&amp;iter, args.end(), "stats", &amp;options.printStatistics, onError) ||
                   ParseArg(&amp;iter, args.end(), "toply", &amp;toPly, onError) ||
                   ParseArg(&amp;iter, args.end(), "wavefront", &amp;options.wavefront, onError) ||
                   ParseArg(&amp;iter, args.end(), "write-partial-images", &amp;options.writePartialImages,
                            onError) ||
                   ParseArg(&amp;iter, args.end(), "upgrade", &amp;options.upgrade, onError)) {
                   // success
               } else if (*iter == "--help" || *iter == "-help" || *iter == "-h") {
                   usage();
                   return 0;
               } else {
                   usage(StringPrintf("argument \"%s\" unknown", *iter));
                   return 1;
               }
           }</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Initializepbrt-0">Initialize pbrt</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-8" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-8"><i></i></a><div id="fragbit-8" class="collapse show"><div class="fragmentcode">       <a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#InitPBRT" class="code">InitPBRT</a>(options);</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Parseprovidedscenedescriptionfiles-0">Parse provided scene description files</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-9" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-9"><i></i></a><div id="fragbit-9" class="collapse show"><div class="fragmentcode">       <a href="../Processing_the_Scene_Description/BasicScene_and_Final_Object_Creation.html#BasicScene" class="code">BasicScene</a> scene;
       <a href="../Processing_the_Scene_Description/Managing_the_Scene_Description.html#BasicSceneBuilder" class="code">BasicSceneBuilder</a> builder(&amp;scene);
       <a href="../Processing_the_Scene_Description/Tokenizing_and_Parsing.html#ParseFiles" class="code">ParseFiles</a>(&amp;builder, filenames);</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Renderthescene-0">Render the scene</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-10" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-10"><i></i></a><div id="fragbit-10" class="collapse show"><div class="fragmentcode">       if (<a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#Options" class="code">Options</a>-&gt;<a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#BasicPBRTOptions::useGPU" class="code">useGPU</a> || <a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#Options" class="code">Options</a>-&gt;<a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#BasicPBRTOptions::wavefront" class="code">wavefront</a>)
           <a href="../Wavefront_Rendering_on_GPUs/Mapping_Path_Tracing_to_the_GPU.html#RenderWavefront" class="code">RenderWavefront</a>(scene);
       else
           <a href="#RenderCPU" class="code">RenderCPU</a>(scene);</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Cleanupafterrenderingthescene-0">Clean up after rendering the scene</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-11" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-11"><i></i></a><div id="fragbit-11" class="collapse show"><div class="fragmentcode">       <a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#CleanupPBRT" class="code">CleanupPBRT</a>();</div></div>
}</div><p>


</p>
<p>Rather than operate on the <tt>argv</tt> values provided to the <tt>main()</tt>
function directly, <tt>pbrt</tt> converts the provided arguments to a vector of
<tt>std::string</tt>s.  It does so not only for the greater convenience of
the <tt>string</tt> class, but also to support non-ASCII character sets.
Section&nbsp;<a href="../Utilities/User_Interaction.html#sec:character-encoding">B.3.2</a> has more information about character
encodings and how they are handled in <tt>pbrt</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-Convertcommand-lineargumentstovectorofstrings-0"></span><div class="fragmentname">&lt;&lt;Convert command-line arguments to vector of strings&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::vector&lt;std::string&gt; args = <a href="../Utilities/User_Interaction.html#GetCommandLineArguments" class="code">GetCommandLineArguments</a>(argv);</div><p>


</p>
<p>We will only include the definitions of some of the <tt>main</tt> function&rsquo;s
fragments in the book text here.  Some, such as the one that handles
parsing command-line arguments provided by the user, are both
simple enough and long enough that they are not worth the few
pages that they would add to the book&rsquo;s length.  However, we will include
the fragment that declares the variables in which the option values are
stored.

</p>
<p></p>
<span class="anchor" id="fragment-Declarevariablesforparsedcommandline-0"></span><div class="fragmentname">&lt;&lt;Declare variables for parsed command line&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#PBRTOptions" class="code">PBRTOptions</a> options;
std::vector&lt;std::string&gt; filenames;
</div><p>


</p>
<p>The <a href="../Utilities/User_Interaction.html#GetCommandLineArguments"><tt>GetCommandLineArguments()</tt></a> function and <a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#PBRTOptions"><tt>PBRTOptions</tt></a> type
appear in a <em>mini-index</em> in the page margin, along with the number of
the page where they are defined.  The mini-indices have pointers
to the definitions of almost all the functions, classes, methods, and
member variables used or referred to on each page.  (In the interests of
brevity, we will omit very widely used classes such as <tt>Ray</tt> from the
mini-indices, as well as types or methods that were just introduced in the
preceding few pages.)

</p>
<p>

</p>
<p>The <a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#PBRTOptions"><tt>PBRTOptions</tt></a> class stores various rendering options that are
generally more suited to be specified on the command line rather than in
scene description files&mdash;for example, how chatty <tt>pbrt</tt> should be about
its progress during rendering.  It is passed to the <a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#InitPBRT"><tt>InitPBRT()</tt></a>
function, which aggregates the various system-wide initialization tasks
that must be performed before any other work is done.  For example, it
initializes the logging system and launches a group of threads that are
used for the parallelization of <tt>pbrt</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-Initializepbrt-0"></span><div class="fragmentname">&lt;&lt;Initialize pbrt&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#InitPBRT" class="code">InitPBRT</a>(options);</div><p>


</p>
<p>

</p>
<p>After the arguments have been parsed and validated, the <a href="../Processing_the_Scene_Description/Tokenizing_and_Parsing.html#ParseFiles"><tt>ParseFiles()</tt></a>
function takes over to handle the first of the three phases of execution
described earlier.  With the assistance of two classes, 
<a href="../Processing_the_Scene_Description/Managing_the_Scene_Description.html#BasicSceneBuilder"><tt>BasicSceneBuilder</tt></a> and <a href="../Processing_the_Scene_Description/BasicScene_and_Final_Object_Creation.html#BasicScene"><tt>BasicScene</tt></a>, which are respectively described in
Sections&nbsp;<a href="../Processing_the_Scene_Description/Managing_the_Scene_Description.html#sec:basic-scene-builder">C.2</a> and&nbsp;<a href="../Processing_the_Scene_Description/BasicScene_and_Final_Object_Creation.html#sec:basic-scene">C.3</a>,
it loops over the provided filenames, parsing each file
in turn.  If <tt>pbrt</tt> is run with no filenames provided, it looks for the
scene description from standard input.  The mechanics of tokenizing and
parsing scene description files will not be described in this book, but the
parser implementation can be found in the files <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/parser.h"><tt>parser.h</tt></a> and
<a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/parser.cpp"><tt>parser.cpp</tt></a> in the <tt>src/pbrt</tt> directory.

</p>
<p></p>
<span class="anchor" id="fragment-Parseprovidedscenedescriptionfiles-0"></span><div class="fragmentname">&lt;&lt;Parse provided scene description files&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Processing_the_Scene_Description/BasicScene_and_Final_Object_Creation.html#BasicScene" class="code">BasicScene</a> scene;
<a href="../Processing_the_Scene_Description/Managing_the_Scene_Description.html#BasicSceneBuilder" class="code">BasicSceneBuilder</a> builder(&amp;scene);
<a href="../Processing_the_Scene_Description/Tokenizing_and_Parsing.html#ParseFiles" class="code">ParseFiles</a>(&amp;builder, filenames);</div><p>


</p>
<p>After the scene description has been parsed, one of two functions is called
to render the scene.  <a href="../Wavefront_Rendering_on_GPUs/Mapping_Path_Tracing_to_the_GPU.html#RenderWavefront"><tt>RenderWavefront()</tt></a> supports both the CPU and GPU
rendering paths, processing a million or so image samples in parallel.  It is the
topic of Chapter&nbsp;<a href="../Wavefront_Rendering_on_GPUs.html#chap:gpu">15</a>.
<tt>RenderCPU()</tt><span class="anchor" id="RenderCPU"></span> renders the scene using an
<a href="#Integrator"><tt>Integrator</tt></a> implementation and is only available when running on the
CPU.  It uses much less parallelism than <a href="../Wavefront_Rendering_on_GPUs/Mapping_Path_Tracing_to_the_GPU.html#RenderWavefront"><tt>RenderWavefront()</tt></a>, rendering
only as many image samples as there are CPU threads in parallel.

</p>
<p>Both of these functions start by converting the <a href="../Processing_the_Scene_Description/BasicScene_and_Final_Object_Creation.html#BasicScene"><tt>BasicScene</tt></a> into a
form suitable for efficient rendering and then pass control to a
processor-specific integrator.  (More information about this process is available
in Section&nbsp;<a href="../Processing_the_Scene_Description/BasicScene_and_Final_Object_Creation.html#sec:basic-scene">C.3</a>.)  We will for now gloss past
the details of this transformation in order to focus on the main rendering
loop in <tt>RenderCPU()</tt>, which is much more interesting.  For that, we
will take the efficient scene representation as a given.

</p>
<p></p>
<span class="anchor" id="fragment-Renderthescene-0"></span><div class="fragmentname">&lt;&lt;Render the scene&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (<a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#Options" class="code">Options</a>-&gt;<a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#BasicPBRTOptions::useGPU" class="code">useGPU</a> || <a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#Options" class="code">Options</a>-&gt;<a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#BasicPBRTOptions::wavefront" class="code">wavefront</a>)
    <a href="../Wavefront_Rendering_on_GPUs/Mapping_Path_Tracing_to_the_GPU.html#RenderWavefront" class="code">RenderWavefront</a>(scene);
else
    <a href="#RenderCPU" class="code">RenderCPU</a>(scene);</div><p>


</p>
<p>After the image has been rendered, <a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#CleanupPBRT"><tt>CleanupPBRT()</tt></a> takes care of
shutting the system down gracefully, including, for example, terminating
the threads launched by <a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#InitPBRT"><tt>InitPBRT()</tt></a>.

</p>
<p></p>
<span class="anchor" id="fragment-Cleanupafterrenderingthescene-0"></span><div class="fragmentname">&lt;&lt;Clean up after rendering the scene&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#CleanupPBRT" class="code">CleanupPBRT</a>();</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#IntegratorInterface"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:integrator-intro"></span><span id="IntegratorInterface"></span><h3>1.3.3  Integrator Interface</h3><p>



</p>
<p>In the <a href="#RenderCPU"><tt>RenderCPU()</tt></a> rendering path, an instance of a class that implements the
<tt>Integrator</tt> interface is responsible for rendering.  Because
<tt>Integrator</tt> implementations only run on the CPU, we will define
<tt>Integrator</tt> as a standard base class with pure virtual methods.
<tt>Integrator</tt> and the various implementations are each
defined in the files <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/cpu/integrator.h"><tt>cpu/integrator.h</tt></a> and
<a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/cpu/integrator.cpp"><tt>cpu/integrator.cpp</tt></a>.

</p>
<p></p>
<span class="anchor" id="fragment-IntegratorDefinition-0"></span><div class="fragmentname">&lt;&lt;Integrator Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="Integrator"></span>Integrator {
  public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-IntegratorPublicMethods-0">Integrator Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-12" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-12"><i></i></a><div id="fragbit-12" class="collapse show"><div class="fragmentcode">       virtual ~<a href="#Integrator" class="code">Integrator</a>();
       
       static std::unique_ptr&lt;<a href="#Integrator" class="code">Integrator</a>&gt; Create(const std::string &amp;name,
                                                 const ParameterDictionary &amp;parameters,
                                                 <a href="../Cameras_and_Film/Camera_Interface.html#Camera" class="code">Camera</a> camera, <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> sampler,
                                                 <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a> aggregate,
                                                 std::vector&lt;<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a>&gt; lights,
                                                 const <a href="../Radiometry,_Spectra,_and_Color/Color.html#RGBColorSpace" class="code">RGBColorSpace</a> *colorSpace,
                                                 const FileLoc *loc);
       
       virtual std::string ToString() const = 0;
       virtual void Render() = 0;
       pstd::optional&lt;ShapeIntersection&gt; Intersect(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray,
                                                   Float tMax = Infinity) const;
       bool <a href="#Integrator::IntersectP" class="code">IntersectP</a>(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray, Float tMax = Infinity) const;
       bool Unoccluded(const <a href="../Geometry_and_Transformations/Interactions.html#Interaction" class="code">Interaction</a> &amp;p0, const <a href="../Geometry_and_Transformations/Interactions.html#Interaction" class="code">Interaction</a> &amp;p1) const {
           return !<a href="#Integrator::IntersectP" class="code">IntersectP</a>(p0.<a href="../Shapes/Managing_Rounding_Error.html#Interaction::SpawnRayTo" class="code">SpawnRayTo</a>(p1), 1 - <a href="../Shapes/Managing_Rounding_Error.html#ShadowEpsilon" class="code">ShadowEpsilon</a>);
       }
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> Tr(const <a href="../Geometry_and_Transformations/Interactions.html#Interaction" class="code">Interaction</a> &amp;p0, const <a href="../Geometry_and_Transformations/Interactions.html#Interaction" class="code">Interaction</a> &amp;p1,
                          const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda) const;</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-IntegratorPublicMembers-0">Integrator Public Members</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-13" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-13"><i></i></a><div id="fragbit-13" class="collapse show"><div class="fragmentcode">       <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a> aggregate;
       std::vector&lt;<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a>&gt; lights;
       std::vector&lt;<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a>&gt; infiniteLights;</div></div>
  protected:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-IntegratorProtectedMethods-0">Integrator Protected Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-14" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-14"><i></i></a><div id="fragbit-14" class="collapse show"><div class="fragmentcode">       <a href="#Integrator" class="code">Integrator</a>(<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a> aggregate, std::vector&lt;<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a>&gt; lights)
           : aggregate(aggregate), lights(lights) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Integratorconstructorimplementation-0">Integrator constructor implementation</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-15" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-15"><i></i></a><div id="fragbit-15" class="collapse show"><div class="fragmentcode">              <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> sceneBounds = <a href="#Integrator::aggregate" class="code">aggregate</a> ? <a href="#Integrator::aggregate" class="code">aggregate</a>.<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Bounds" class="code">Bounds</a>() : <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a>();
              for (auto &amp;light : <a href="#Integrator::lights" class="code">lights</a>) {
                  light.<a href="../Light_Sources/Light_Interface.html#Light::Preprocess" class="code">Preprocess</a>(sceneBounds);
                  if (light.<a href="../Light_Sources/Light_Interface.html#Light::Type" class="code">Type</a>() == LightType::<a href="../Light_Sources/Light_Interface.html#LightType::Infinite" class="code">Infinite</a>)
                      <a href="#Integrator::infiniteLights" class="code">infiniteLights</a>.push_back(light);
              }</div></div>
       }</div></div>
};</div><p>


</p>
<p>

</p>
<p>The base <a href="#Integrator"><tt>Integrator</tt></a> constructor takes a single <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive"><tt>Primitive</tt></a> that
represents all the geometric objects in the scene as well as an array
that holds all the lights in the scene.

</p>
<p></p>
<span class="anchor" id="fragment-IntegratorProtectedMethods-0"></span><div class="fragmentname">&lt;&lt;Integrator Protected Methods&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="#Integrator" class="code">Integrator</a>(<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a> aggregate, std::vector&lt;<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a>&gt; lights)
    : aggregate(aggregate), lights(lights) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Integratorconstructorimplementation-0">Integrator constructor implementation</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-16" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-16"><i></i></a><div id="fragbit-16" class="collapse show"><div class="fragmentcode">       <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> sceneBounds = <a href="#Integrator::aggregate" class="code">aggregate</a> ? <a href="#Integrator::aggregate" class="code">aggregate</a>.<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Bounds" class="code">Bounds</a>() : <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a>();
       for (auto &amp;light : <a href="#Integrator::lights" class="code">lights</a>) {
           light.<a href="../Light_Sources/Light_Interface.html#Light::Preprocess" class="code">Preprocess</a>(sceneBounds);
           if (light.<a href="../Light_Sources/Light_Interface.html#Light::Type" class="code">Type</a>() == LightType::<a href="../Light_Sources/Light_Interface.html#LightType::Infinite" class="code">Infinite</a>)
               <a href="#Integrator::infiniteLights" class="code">infiniteLights</a>.push_back(light);
       }</div></div>
}</div><p>


</p>
<p>Each geometric object in the scene is represented by a
<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive"><tt>Primitive</tt></a>, which is primarily responsible for combining a <a href="../Shapes/Basic_Shape_Interface.html#Shape"><tt>Shape</tt></a> that
specifies its geometry and a <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material"><tt>Material</tt></a> that describes its appearance
(e.g., the object&rsquo;s color, or whether it has a dull or glossy finish).  In
turn, all the geometric primitives in a scene are collected into a single aggregate
primitive that is stored in the <a href="#Integrator::aggregate"><tt>Integrator::aggregate</tt></a> member
variable.  This aggregate is a special kind of primitive that itself holds
references to many other primitives.  The aggregate implementation stores
all the scene&rsquo;s primitives in an acceleration data structure that reduces
the number of unnecessary ray intersection tests with primitives that are
far away from a given ray.  Because it implements the <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive"><tt>Primitive</tt></a>
interface, it appears no different from a single primitive to the rest of
the system.

</p>
<p></p>
<span class="anchor" id="fragment-IntegratorPublicMembers-0"></span><div class="fragmentname">&lt;&lt;Integrator Public Members&gt;&gt;=&nbsp;<a href="#fragment-IntegratorPublicMembers-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a> <span class="anchor" id="Integrator::aggregate"></span>aggregate;
std::vector&lt;<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a>&gt; <span class="anchor" id="Integrator::lights"></span>lights;</div><p>


</p>
<p>
Each light source in the scene is represented by an object that implements
the <a href="../Light_Sources/Light_Interface.html#Light"><tt>Light</tt></a> interface, which allows the light to specify its shape and
the distribution of energy that it emits.  Some lights need to know the
bounding box of the entire scene, which is unavailable when they are first
created.  Therefore, the <tt>Integrator</tt> constructor calls their
<tt>Preprocess()</tt> methods, providing those bounds.
At this point any &ldquo;infinite&rdquo; lights are also
stored in a separate array.  This sort of light, which will be introduced
in Section&nbsp;<a href="../Light_Sources/Infinite_Area_Lights.html#sec:infinite-area-lights">12.5</a>, models infinitely far away
sources of light, which is a reasonable model for skylight as received on
Earth&rsquo;s surface, for example.  Sometimes it will be necessary to loop over
just those lights, and for scenes with thousands of light sources it would
be inefficient to loop over all of them just to find&nbsp;those.

</p>
<p></p>
<span class="anchor" id="fragment-Integratorconstructorimplementation-0"></span><div class="fragmentname">&lt;&lt;Integrator constructor implementation&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> sceneBounds = <a href="#Integrator::aggregate" class="code">aggregate</a> ? <a href="#Integrator::aggregate" class="code">aggregate</a>.<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Bounds" class="code">Bounds</a>() : <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a>();
for (auto &amp;light : <a href="#Integrator::lights" class="code">lights</a>) {
    light.<a href="../Light_Sources/Light_Interface.html#Light::Preprocess" class="code">Preprocess</a>(sceneBounds);
    if (light.<a href="../Light_Sources/Light_Interface.html#Light::Type" class="code">Type</a>() == LightType::<a href="../Light_Sources/Light_Interface.html#LightType::Infinite" class="code">Infinite</a>)
        <a href="#Integrator::infiniteLights" class="code">infiniteLights</a>.push_back(light);
}</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-IntegratorPublicMembers-1"></span><div class="fragmentname">&lt;&lt;Integrator Public Members&gt;&gt;+=&nbsp;<a href="#fragment-IntegratorPublicMembers-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">std::vector&lt;<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a>&gt; <span class="anchor" id="Integrator::infiniteLights"></span>infiniteLights;</div><p>


</p>
<p><a href="#Integrator"><tt>Integrator</tt></a>s must provide an implementation of the <tt>Render()</tt>
method, which takes no further arguments.  This method is called by the
<a href="#RenderCPU"><tt>RenderCPU()</tt></a> function once the scene representation has been
initialized.  The task of integrators is to render the scene as specified
by the aggregate and the lights.  Beyond that, it is up to the specific
integrator to define what it means to render the scene, using whichever
other classes that it needs to do so (e.g., a camera model).  This interface
is intentionally very general to permit a wide range of
implementations&mdash;for example, one could implement an <a href="#Integrator"><tt>Integrator</tt></a> that
measures light only at a sparse set of points distributed through the scene
rather than generating a regular 2D image.

</p>
<p></p>
<span class="anchor" id="fragment-IntegratorPublicMethods-0"></span><div class="fragmentname">&lt;&lt;Integrator Public Methods&gt;&gt;=&nbsp;<a href="../Light_Transport_I_Surface_Reflection/A_Simple_Path_Tracer.html#fragment-IntegratorPublicMethods-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">virtual void <span class="anchor" id="Integrator::Render"></span>Render() = 0;</div><p>


</p>
<p>The <a href="#Integrator"><tt>Integrator</tt></a> class provides two methods related to ray&ndash;primitive
intersection for use of its subclasses.  <tt>Intersect()</tt> takes a ray and
a maximum parametric distance <tt>tMax</tt>, traces the given ray into the
scene, and returns a <a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection"><tt>ShapeIntersection</tt></a> object corresponding to the
closest primitive that the ray hit, if there is an intersection along the
ray before <tt>tMax</tt>. (The <a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection"><tt>ShapeIntersection</tt></a> structure is defined
in Section&nbsp;<a href="../Shapes/Basic_Shape_Interface.html#sec:shape-intersection-tests">6.1.3</a>.)
One thing to note is that this method uses the type <tt>pstd::optional</tt>
for the return value rather than <tt>std::optional</tt> from the C++ standard
library; we have reimplemented parts of the standard library in the
<tt>pstd</tt> namespace for reasons that are discussed in
Section&nbsp;<a href="../Introduction/Using_and_Understanding_the_Code.html#sec:pstd">1.5.5</a>.

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-IntegratorMethodDefinitions-0"></span><div class="fragmentname">&lt;&lt;Integrator Method Definitions&gt;&gt;=&nbsp;<a href="#fragment-IntegratorMethodDefinitions-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">pstd::optional&lt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection" class="code">ShapeIntersection</a>&gt;
<span class="anchor" id="Integrator::Intersect"></span><a href="#Integrator" class="code">Integrator</a>::<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Intersect" class="code">Intersect</a>(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray, Float tMax) const {
    if (<a href="#Integrator::aggregate" class="code">aggregate</a>) return <a href="#Integrator::aggregate" class="code">aggregate</a>.<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Intersect" class="code">Intersect</a>(ray, tMax);
    else           return {};
}</div><p>


</p>
<p>Also note the capitalized floating-point type <a href="#Float"><tt>Float</tt></a> in
<tt>Intersect()</tt>&rsquo;s signature: almost all floating-point values in <tt>pbrt</tt> are declared as <span class="anchor" id="Float"></span><tt>Float</tt>s.  (The only exceptions are a
few cases where a 32-bit <tt>float</tt> or a 64-bit <tt>double</tt> is
specifically needed (e.g., when saving binary values to files).)  Depending
on the compilation flags of <tt>pbrt</tt>, <tt>Float</tt> is an alias for either
<tt>float</tt> or <tt>double</tt>, though
single precision <tt>float</tt> is almost always sufficient in practice. 
The definition of <tt>Float</tt> is in the <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/pbrt.h"><tt>pbrt.h</tt></a>
header file, which is included by all other source files in <tt>pbrt</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-FloatTypeDefinitions-0"></span><div class="fragmentname">&lt;&lt;Float Type Definitions&gt;&gt;=&nbsp;<a href="../Shapes/Managing_Rounding_Error.html#fragment-FloatTypeDefinitions-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">#ifdef PBRT_FLOAT_AS_DOUBLE
    using Float = double;
#else
    using Float = float;
#endif</div><p>


</p>
<p>
<a href="#Integrator::IntersectP"><tt>Integrator::IntersectP()</tt></a> is closely related to the
<tt>Intersect()</tt> method.  It checks for the existence of
intersections along the ray but only returns a Boolean indicating whether
an intersection was found.  (The &ldquo;P&rdquo; in its name indicates that it is a
function that evaluates a predicate, using a common naming convention from
the Lisp programming language.)
Because it does not need to search for the closest
intersection or return additional geometric information about intersections, <tt>IntersectP()</tt>
is generally more efficient than <a href="#Integrator::Intersect"><tt>Integrator::Intersect()</tt></a>.  This
routine is used for shadow rays.

</p>
<p></p>
<span class="anchor" id="fragment-IntegratorMethodDefinitions-1"></span><div class="fragmentname">&lt;&lt;Integrator Method Definitions&gt;&gt;+=&nbsp;<a href="#fragment-IntegratorMethodDefinitions-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">bool <span class="anchor" id="Integrator::IntersectP"></span><a href="#Integrator" class="code">Integrator</a>::<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::IntersectP" class="code">IntersectP</a>(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray, Float tMax) const {
    if (<a href="#Integrator::aggregate" class="code">aggregate</a>) return <a href="#Integrator::aggregate" class="code">aggregate</a>.<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::IntersectP" class="code">IntersectP</a>(ray, tMax);
    else           return false;
}</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#ImageTileIntegratorandtheMainRenderingLoop"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:image-tile-integrator"></span><span id="ImageTileIntegratorandtheMainRenderingLoop"></span><h3>1.3.4  ImageTileIntegrator and the
Main Rendering Loop</h3><p>



</p>
<p>Before implementing a basic integrator that simulates light transport to
render an image, we will define two <a href="#Integrator"><tt>Integrator</tt></a> subclasses that
provide additional common functionality used by that integrator as
well as many of the integrator implementations to come.  We start with
<tt>ImageTileIntegrator</tt>, which inherits from <a href="#Integrator"><tt>Integrator</tt></a>.  The next
section defines <a href="#RayIntegrator"><tt>RayIntegrator</tt></a>, which inherits from
<tt>ImageTileIntegrator</tt>.

</p>
<p>All of <tt>pbrt</tt>&rsquo;s CPU-based integrators render images using a camera model to
define the viewing parameters, and all parallelize rendering by splitting
the image into tiles and having different processors work on different
tiles.  Therefore, <tt>pbrt</tt> includes an <tt>ImageTileIntegrator</tt> that
provides common functionality for those tasks.
 
</p>
<span class="anchor" id="fragment-ImageTileIntegratorDefinition-0"></span><div class="fragmentname">&lt;&lt;ImageTileIntegrator Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="ImageTileIntegrator"></span>ImageTileIntegrator : public <a href="#Integrator" class="code">Integrator</a> {
  public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-ImageTileIntegratorPublicMethods-0">ImageTileIntegrator Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-17" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-17"><i></i></a><div id="fragbit-17" class="collapse show"><div class="fragmentcode">       <a href="#ImageTileIntegrator" class="code">ImageTileIntegrator</a>(<a href="../Cameras_and_Film/Camera_Interface.html#Camera" class="code">Camera</a> <a href="#ImageTileIntegrator::camera" class="code">camera</a>, <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> sampler,
               <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a> aggregate, std::vector&lt;<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a>&gt; lights)
           : <a href="#Integrator" class="code">Integrator</a>(aggregate, lights), <a href="#ImageTileIntegrator::camera" class="code">camera</a>(<a href="#ImageTileIntegrator::camera" class="code">camera</a>),
             <a href="#ImageTileIntegrator::samplerPrototype" class="code">samplerPrototype</a>(sampler) {}
       void Render();
       virtual void EvaluatePixelSample(<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> pPixel, int sampleIndex,
           <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> sampler, <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer" class="code">ScratchBuffer</a> &amp;scratchBuffer) = 0;</div></div>
  protected:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-ImageTileIntegratorProtectedMembers-0">ImageTileIntegrator Protected Members</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-18" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-18"><i></i></a><div id="fragbit-18" class="collapse show"><div class="fragmentcode">       <a href="../Cameras_and_Film/Camera_Interface.html#Camera" class="code">Camera</a> camera;
       <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> samplerPrototype;</div></div>
};</div><p>


</p>
<p>In addition to the aggregate and the lights, the <tt>ImageTileIntegrator</tt>
constructor takes a <a href="../Cameras_and_Film/Camera_Interface.html#Camera"><tt>Camera</tt></a> that specifies
the viewing and lens parameters such as
position, orientation, focus, and field of view.  <a href="../Cameras_and_Film/Film_and_Imaging.html#Film"><tt>Film</tt></a>
stored by the camera handles image storage.  The
<a href="../Cameras_and_Film/Camera_Interface.html#Camera"><tt>Camera</tt></a> classes are the subject of most of Chapter&nbsp;<a href="../Cameras_and_Film.html#chap:camera">5</a>,
and <a href="../Cameras_and_Film/Film_and_Imaging.html#Film"><tt>Film</tt></a> is described in Section&nbsp;<a href="../Cameras_and_Film/Film_and_Imaging.html#sec:image-pipeline">5.4</a>.  The
<a href="../Cameras_and_Film/Film_and_Imaging.html#Film"><tt>Film</tt></a> is responsible for writing the final image to a file.

</p>
<p>The constructor also takes a <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a>; its
role is more subtle, but its implementation can substantially
affect the quality of the images that the system generates.  First, the
sampler is responsible for choosing the points on the image plane that
determine which rays are initially traced into the scene.  Second, it is
responsible for supplying random sample values that are used by integrators
for estimating the value of the light transport integral,
Equation&nbsp;(<a href="../Introduction/Photorealistic_Rendering_and_the_Ray-Tracing_Algorithm.html#eq:rendering-equation">1.1</a>). For example, some integrators need
to choose random points on light sources to compute illumination from area
lights.  Generating a good distribution of these samples is an important
part of the rendering process that can substantially affect overall
efficiency; this topic is the main focus of
Chapter&nbsp;<a href="../Sampling_and_Reconstruction.html#chap:sampling-reconstruction">8</a>.

</p>
<p></p>
<span class="anchor" id="fragment-ImageTileIntegratorPublicMethods-0"></span><div class="fragmentname">&lt;&lt;ImageTileIntegrator Public Methods&gt;&gt;=&nbsp;<a href="#fragment-ImageTileIntegratorPublicMethods-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="#ImageTileIntegrator" class="code">ImageTileIntegrator</a>(<a href="../Cameras_and_Film/Camera_Interface.html#Camera" class="code">Camera</a> <a href="#ImageTileIntegrator::camera" class="code">camera</a>, <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> sampler,
        <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a> aggregate, std::vector&lt;<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a>&gt; lights)
    : <a href="#Integrator" class="code">Integrator</a>(aggregate, lights), <a href="#ImageTileIntegrator::camera" class="code">camera</a>(<a href="#ImageTileIntegrator::camera" class="code">camera</a>),
      <a href="#ImageTileIntegrator::samplerPrototype" class="code">samplerPrototype</a>(sampler) {}</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-ImageTileIntegratorProtectedMembers-0"></span><div class="fragmentname">&lt;&lt;ImageTileIntegrator Protected Members&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Cameras_and_Film/Camera_Interface.html#Camera" class="code">Camera</a> <span class="anchor" id="ImageTileIntegrator::camera"></span>camera;
<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> <span class="anchor" id="ImageTileIntegrator::samplerPrototype"></span>samplerPrototype;</div><p>


</p>
<p>For all of <tt>pbrt</tt>&rsquo;s integrators, the final color computed at each pixel is based
on random sampling algorithms.  If each pixel&rsquo;s final value is computed as
the average of multiple samples, then the quality of the image improves.
At low numbers of samples, sampling error manifests itself as grainy
high-frequency noise in images, though error goes down at a predictable
rate as the number of samples increases.  (This topic is discussed in
more depth in Section&nbsp;<a href="../Monte_Carlo_Integration/Monte_Carlo_Basics.html#sec:mc-error">2.1.4</a>.)
<tt>ImageTileIntegrator::Render()</tt> therefore renders the image in <em>waves</em> of a
few samples per pixel.  For the first two waves, only a single sample is
taken in each pixel. In the next wave, two samples are taken, with the
number of samples doubling after each wave up to a limit.  While it makes no difference to
the final image if the image was rendered in waves or with all the
samples being taken in a pixel before moving on to the next one, this
organization of the computation means that it is possible to see previews of
the final image during rendering where all pixels have some samples, rather
than a few pixels having many samples and the rest having none.

</p>
<p>Because <tt>pbrt</tt> is parallelized to run using multiple threads, there is a
balance to be struck with this approach.  There is a cost for threads to
acquire work for a new image tile, and some threads end up idle at
the end of each wave once there is no more work for them to do but other
threads are still working on the tiles they have been assigned.  These
considerations motivated the capped doubling approach.

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-ImageTileIntegratorMethodDefinitions-0"></span><div class="fragmentname">&lt;&lt;ImageTileIntegrator Method Definitions&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">void <span class="anchor" id="ImageTileIntegrator::Render"></span><a href="#ImageTileIntegrator" class="code">ImageTileIntegrator</a>::Render() {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Declarecommonvariablesforrenderingimageintiles-0">Declare common variables for rendering image in tiles</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-19" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-19"><i></i></a><div id="fragbit-19" class="collapse show"><div class="fragmentcode">       <a href="../Utilities/Parallelism.html#ThreadLocal" class="code">ThreadLocal</a>&lt;<a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer" class="code">ScratchBuffer</a>&gt; scratchBuffers(
           []() { return <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer" class="code">ScratchBuffer</a>(); } );
       <a href="../Utilities/Parallelism.html#ThreadLocal" class="code">ThreadLocal</a>&lt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a>&gt; samplers(
           [this]() { return <a href="#ImageTileIntegrator::samplerPrototype" class="code">samplerPrototype</a>.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Clone" class="code">Clone</a>(); });
       <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2i" class="code">Bounds2i</a> pixelBounds = <a href="#ImageTileIntegrator::camera" class="code">camera</a>.<a href="../Cameras_and_Film/Camera_Interface.html#Camera::GetFilm" class="code">GetFilm</a>().<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::PixelBounds" class="code">PixelBounds</a>();
       int spp = <a href="#ImageTileIntegrator::samplerPrototype" class="code">samplerPrototype</a>.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::SamplesPerPixel" class="code">SamplesPerPixel</a>();
       <a href="../Utilities/User_Interaction.html#ProgressReporter" class="code">ProgressReporter</a> progress(int64_t(spp) * pixelBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::Area" class="code">Area</a>(), "Rendering",
                                 <a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#Options" class="code">Options</a>-&gt;<a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#BasicPBRTOptions::quiet" class="code">quiet</a>);
       int waveStart = 0, waveEnd = 1, nextWaveSize = 1;</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Renderimageinwaves-0">Render image in waves</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-20" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-20"><i></i></a><div id="fragbit-20" class="collapse show"><div class="fragmentcode">       while (waveStart &lt; spp) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Rendercurrentwavesimagetilesinparallel-0">Render current wave&rsquo;s image tiles in parallel</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-21" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-21"><i></i></a><div id="fragbit-21" class="collapse show"><div class="fragmentcode">              <a href="../Utilities/Parallelism.html#ParallelFor2D" class="code">ParallelFor2D</a>(pixelBounds, [&amp;](<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2i" class="code">Bounds2i</a> tileBounds) {
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-RenderimagetilegivenbymonotileBounds-0">Render image tile given by <tt>tileBounds</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-22" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-22"><i></i></a><div id="fragbit-22" class="collapse show"><div class="fragmentcode">                     <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer" class="code">ScratchBuffer</a> &amp;scratchBuffer = scratchBuffers.<a href="../Utilities/Parallelism.html#ThreadLocal::Get" class="code">Get</a>();
                     <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> &amp;sampler = samplers.<a href="../Utilities/Parallelism.html#ThreadLocal::Get" class="code">Get</a>();
                     for (<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> pPixel : tileBounds) {
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-RendersamplesinpixelmonopPixel-0">Render samples in pixel <tt>pPixel</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-23" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-23"><i></i></a><div id="fragbit-23" class="collapse show"><div class="fragmentcode">                            for (int sampleIndex = waveStart; sampleIndex &lt; waveEnd; ++sampleIndex) {
                                sampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::StartPixelSample" class="code">StartPixelSample</a>(pPixel, sampleIndex);
                                <a href="#ImageTileIntegrator::EvaluatePixelSample" class="code">EvaluatePixelSample</a>(pPixel, sampleIndex, sampler, scratchBuffer);
                                scratchBuffer.<a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer::Reset" class="code">Reset</a>();
                            }</div></div>
                     }
                     progress.<a href="../Utilities/User_Interaction.html#ProgressReporter::Update" class="code">Update</a>((waveEnd - waveStart) * tileBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::Area" class="code">Area</a>());</div></div>
              });</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatestartandendwave-0">Update start and end wave</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-24" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-24"><i></i></a><div id="fragbit-24" class="collapse show"><div class="fragmentcode">              waveStart = waveEnd;
              waveEnd = std::min(spp, waveEnd + nextWaveSize);
              nextWaveSize = std::min(2 * nextWaveSize, 64);
              </div></div>
           &lt;&lt;<span class="fragmentname">Optionally write current image to disk</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-25" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-25"><i></i></a><div id="fragbit-25" class="collapse show"><div class="fragmentcode">              if (waveStart == spp || Options-&gt;writePartialImages || referenceImage) {
              ImageMetadata metadata;
              metadata.renderTimeSeconds = progress.ElapsedSeconds();
              metadata.samplesPerPixel = waveStart;
              if (waveStart == spp || Options-&gt;writePartialImages) {
                  camera.InitMetadata(&amp;metadata);
                  camera.GetFilm().WriteImage(metadata, 1.0f / waveStart);
              }
              }</div></div> 
       }</div></div>
}</div><p>


</p>
<p>Before rendering begins, a few additional variables are required.  First,
the integrator implementations will need to allocate small
amounts of temporary memory to store surface scattering properties in the
course of computing each ray&rsquo;s contribution. The large number of resulting
allocations could easily overwhelm the system&rsquo;s regular memory allocation
routines (e.g., <tt>new</tt>), which must coordinate multi-threaded
maintenance of elaborate data structures
to track free memory. A naive implementation could potentially
spend a fairly large fraction of its computation time in the memory
allocator.

</p>
<p>To address this issue, <tt>pbrt</tt> provides a <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer"><tt>ScratchBuffer</tt></a> class that
manages a small preallocated buffer of memory.  <tt>ScratchBuffer</tt>
allocations are very efficient, just requiring the increment of an offset.
The <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer"><tt>ScratchBuffer</tt></a> does not allow independently freeing allocations;
instead, all must be freed at once, but doing so only requires resetting
that offset.

</p>
<p>Because <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer"><tt>ScratchBuffer</tt></a>s are not safe for use by multiple threads at
the same time, an individual one is created for each thread using the
<a href="../Utilities/Parallelism.html#ThreadLocal"><tt>ThreadLocal</tt></a> template class.  Its constructor takes a lambda function
that returns a fresh instance of the object of the type it manages; here,
calling the default <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer"><tt>ScratchBuffer</tt></a> constructor is sufficient.
<a href="../Utilities/Parallelism.html#ThreadLocal"><tt>ThreadLocal</tt></a> then handles the details of maintaining distinct copies
of the object for each thread, allocating them on demand.

</p>
<p></p>
<span class="anchor" id="fragment-Declarecommonvariablesforrenderingimageintiles-0"></span><div class="fragmentname">&lt;&lt;Declare common variables for rendering image in tiles&gt;&gt;=&nbsp;<a href="#fragment-Declarecommonvariablesforrenderingimageintiles-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Utilities/Parallelism.html#ThreadLocal" class="code">ThreadLocal</a>&lt;<a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer" class="code">ScratchBuffer</a>&gt; scratchBuffers(
    []() { return <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer" class="code">ScratchBuffer</a>(); } );</div><p>


</p>
<p>Most <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> implementations find it useful to maintain some state,
such as the coordinates of the current pixel.  This means that multiple
threads cannot use a single <tt>Sampler</tt> concurrently and
<a href="../Utilities/Parallelism.html#ThreadLocal"><tt>ThreadLocal</tt></a> is also used for <tt>Sampler</tt>
management. <tt>Sampler</tt>s provide a <tt>Clone()</tt> method that creates a
new instance of their sampler type.  The <tt>Sampler</tt> first provided to
the <a href="#ImageTileIntegrator"><tt>ImageTileIntegrator</tt></a> constructor, <tt>samplerPrototype</tt>,
provides those copies here.

</p>
<p></p>
<span class="anchor" id="fragment-Declarecommonvariablesforrenderingimageintiles-1"></span><div class="fragmentname">&lt;&lt;Declare common variables for rendering image in tiles&gt;&gt;+=&nbsp;<a href="#fragment-Declarecommonvariablesforrenderingimageintiles-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-Declarecommonvariablesforrenderingimageintiles-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Utilities/Parallelism.html#ThreadLocal" class="code">ThreadLocal</a>&lt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a>&gt; samplers(
    [this]() { return <a href="#ImageTileIntegrator::samplerPrototype" class="code">samplerPrototype</a>.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Clone" class="code">Clone</a>(); });</div><p>


</p>
<p>It is helpful to provide the user with an indication of how much of the
rendering work is done and an estimate of how much longer it will take.
This task is handled by the <a href="../Utilities/User_Interaction.html#ProgressReporter"><tt>ProgressReporter</tt></a> class, which takes as
its first parameter the total number of items of work.  Here, the total
amount of work is the number of samples taken in each pixel times the total
number of pixels.  It is important to use 64-bit precision to compute this
value, since a 32-bit <tt>int</tt> may be insufficient for high-resolution
images with many samples per pixel.

</p>
<p></p>
<span class="anchor" id="fragment-Declarecommonvariablesforrenderingimageintiles-2"></span><div class="fragmentname">&lt;&lt;Declare common variables for rendering image in tiles&gt;&gt;+=&nbsp;<a href="#fragment-Declarecommonvariablesforrenderingimageintiles-1"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-Declarecommonvariablesforrenderingimageintiles-3"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2i" class="code">Bounds2i</a> pixelBounds = <a href="#ImageTileIntegrator::camera" class="code">camera</a>.<a href="../Cameras_and_Film/Camera_Interface.html#Camera::GetFilm" class="code">GetFilm</a>().<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::PixelBounds" class="code">PixelBounds</a>();
int spp = <a href="#ImageTileIntegrator::samplerPrototype" class="code">samplerPrototype</a>.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::SamplesPerPixel" class="code">SamplesPerPixel</a>();
<a href="../Utilities/User_Interaction.html#ProgressReporter" class="code">ProgressReporter</a> progress(int64_t(spp) * pixelBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::Area" class="code">Area</a>(), "Rendering",
                          <a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#Options" class="code">Options</a>-&gt;<a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#BasicPBRTOptions::quiet" class="code">quiet</a>);</div><p>


</p>
<p>

</p>
<p>

</p>
<p>In the following, the range of samples to be taken in the current wave is
given by <tt>waveStart</tt> and <tt>waveEnd</tt>; <tt>nextWaveSize</tt> gives the
number of samples to be taken in the next wave.

</p>
<p></p>
<span class="anchor" id="fragment-Declarecommonvariablesforrenderingimageintiles-3"></span><div class="fragmentname">&lt;&lt;Declare common variables for rendering image in tiles&gt;&gt;+=&nbsp;<a href="#fragment-Declarecommonvariablesforrenderingimageintiles-2"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">int waveStart = 0, waveEnd = 1, nextWaveSize = 1;</div><p>


</p>
<p>With these variables in hand, rendering proceeds until the required number
of samples have been taken in all pixels.

</p>
<p></p>
<span class="anchor" id="fragment-Renderimageinwaves-0"></span><div class="fragmentname">&lt;&lt;Render image in waves&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">while (waveStart &lt; spp) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Rendercurrentwavesimagetilesinparallel-0">Render current wave&rsquo;s image tiles in parallel</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-26" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-26"><i></i></a><div id="fragbit-26" class="collapse show"><div class="fragmentcode">       <a href="../Utilities/Parallelism.html#ParallelFor2D" class="code">ParallelFor2D</a>(pixelBounds, [&amp;](<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2i" class="code">Bounds2i</a> tileBounds) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-RenderimagetilegivenbymonotileBounds-0">Render image tile given by <tt>tileBounds</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-27" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-27"><i></i></a><div id="fragbit-27" class="collapse show"><div class="fragmentcode">              <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer" class="code">ScratchBuffer</a> &amp;scratchBuffer = scratchBuffers.<a href="../Utilities/Parallelism.html#ThreadLocal::Get" class="code">Get</a>();
              <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> &amp;sampler = samplers.<a href="../Utilities/Parallelism.html#ThreadLocal::Get" class="code">Get</a>();
              for (<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> pPixel : tileBounds) {
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-RendersamplesinpixelmonopPixel-0">Render samples in pixel <tt>pPixel</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-28" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-28"><i></i></a><div id="fragbit-28" class="collapse show"><div class="fragmentcode">                     for (int sampleIndex = waveStart; sampleIndex &lt; waveEnd; ++sampleIndex) {
                         sampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::StartPixelSample" class="code">StartPixelSample</a>(pPixel, sampleIndex);
                         <a href="#ImageTileIntegrator::EvaluatePixelSample" class="code">EvaluatePixelSample</a>(pPixel, sampleIndex, sampler, scratchBuffer);
                         scratchBuffer.<a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer::Reset" class="code">Reset</a>();
                     }</div></div>
              }
              progress.<a href="../Utilities/User_Interaction.html#ProgressReporter::Update" class="code">Update</a>((waveEnd - waveStart) * tileBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::Area" class="code">Area</a>());</div></div>
       });</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatestartandendwave-0">Update start and end wave</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-29" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-29"><i></i></a><div id="fragbit-29" class="collapse show"><div class="fragmentcode">       waveStart = waveEnd;
       waveEnd = std::min(spp, waveEnd + nextWaveSize);
       nextWaveSize = std::min(2 * nextWaveSize, 64);
       </div></div>
    &lt;&lt;<span class="fragmentname">Optionally write current image to disk</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-30" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-30"><i></i></a><div id="fragbit-30" class="collapse show"><div class="fragmentcode">       if (waveStart == spp || Options-&gt;writePartialImages || referenceImage) {
       ImageMetadata metadata;
       metadata.renderTimeSeconds = progress.ElapsedSeconds();
       metadata.samplesPerPixel = waveStart;
       if (waveStart == spp || Options-&gt;writePartialImages) {
           camera.InitMetadata(&amp;metadata);
           camera.GetFilm().WriteImage(metadata, 1.0f / waveStart);
       }
       }</div></div> 
}</div><p>


</p>
<p>The <tt>ParallelFor2D()</tt> function loops over image tiles, running multiple
loop iterations concurrently; it is part of the parallelism-related utility
functions that are introduced in Section B.6.
A C++ lambda expression provides
the loop body.  <a href="../Utilities/Parallelism.html#ParallelFor2D"><tt>ParallelFor2D()</tt></a> automatically chooses a tile size to
balance two concerns:
on one hand, we would like to have significantly more tiles than there are
processors in the system.  It is likely that some of the tiles will take
less processing time than others, so if there was for example a 1:1 mapping
between processors and tiles, then some processors will be idle after
finishing their work while others continue to work on their region of the
image.  (Figure&nbsp;<a href="#fig:task-time-distribution">1.17</a> graphs the distribution of
time taken to render tiles of an example image, illustrating this concern.)
On the other hand, having too many tiles also hurts efficiency.  There is a
small fixed overhead for a thread to acquire more work in the parallel
<tt>for</tt> loop and the more tiles there are, the more times this overhead
must be paid.  <tt>ParallelFor2D()</tt> therefore chooses a tile size that
accounts for both the extent of the region to be processed and the number
of processors in the system.

</p>
<p></p>
<span class="anchor" id="fragment-Rendercurrentwavesimagetilesinparallel-0"></span><div class="fragmentname">&lt;&lt;Render current wave&rsquo;s image tiles in parallel&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Utilities/Parallelism.html#ParallelFor2D" class="code">ParallelFor2D</a>(pixelBounds, [&amp;](<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2i" class="code">Bounds2i</a> tileBounds) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-RenderimagetilegivenbymonotileBounds-0">Render image tile given by <tt>tileBounds</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-31" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-31"><i></i></a><div id="fragbit-31" class="collapse show"><div class="fragmentcode">       <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer" class="code">ScratchBuffer</a> &amp;scratchBuffer = scratchBuffers.<a href="../Utilities/Parallelism.html#ThreadLocal::Get" class="code">Get</a>();
       <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> &amp;sampler = samplers.<a href="../Utilities/Parallelism.html#ThreadLocal::Get" class="code">Get</a>();
       for (<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> pPixel : tileBounds) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-RendersamplesinpixelmonopPixel-0">Render samples in pixel <tt>pPixel</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-32" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-32"><i></i></a><div id="fragbit-32" class="collapse show"><div class="fragmentcode">              for (int sampleIndex = waveStart; sampleIndex &lt; waveEnd; ++sampleIndex) {
                  sampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::StartPixelSample" class="code">StartPixelSample</a>(pPixel, sampleIndex);
                  <a href="#ImageTileIntegrator::EvaluatePixelSample" class="code">EvaluatePixelSample</a>(pPixel, sampleIndex, sampler, scratchBuffer);
                  scratchBuffer.<a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer::Reset" class="code">Reset</a>();
              }</div></div>
       }
       progress.<a href="../Utilities/User_Interaction.html#ProgressReporter::Update" class="code">Update</a>((waveEnd - waveStart) * tileBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::Area" class="code">Area</a>());</div></div>
});</div><p>


</p>
<p></p>
<span class="anchor" id="fig:task-time-distribution"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="pha01f17.svg" title=""><img src="pha01f17.svg" width=628 height=407 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 1.17: Histogram of Time Spent Rendering Each Tile for the
  Scene in Figure&nbsp;<a href="../Introduction/Photorealistic_Rendering_and_the_Ray-Tracing_Algorithm.html#fig:intro-raytracing-example">1.11</a>. <span class="legend">
The horizontal axis measures time in seconds.
Note the wide variation in execution time, illustrating
that different parts of the image required substantially different amounts of
computation.
</span>
</figcaption>
</div></div><p>


</p>
<p>Given a tile to render, the implementation starts by acquiring the
<a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer"><tt>ScratchBuffer</tt></a> and <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> for the currently executing
thread.  As described earlier, the <a href="../Utilities/Parallelism.html#ThreadLocal::Get"><tt>ThreadLocal::Get()</tt></a> method takes
care of the details of allocating and returning individual ones of them
for each thread. 

</p>
<p>With those in hand, the implementation loops over all the pixels in the
tile using a range-based <tt>for</tt> loop that uses iterators provided by
the <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2"><tt>Bounds2</tt></a> class before informing the <a href="../Utilities/User_Interaction.html#ProgressReporter"><tt>ProgressReporter</tt></a> about
how much work has been completed.

</p>
<p></p>
<span class="anchor" id="fragment-RenderimagetilegivenbymonotileBounds-0"></span><div class="fragmentname">&lt;&lt;Render image tile given by <tt>tileBounds</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer" class="code">ScratchBuffer</a> &amp;scratchBuffer = scratchBuffers.<a href="../Utilities/Parallelism.html#ThreadLocal::Get" class="code">Get</a>();
<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> &amp;sampler = samplers.<a href="../Utilities/Parallelism.html#ThreadLocal::Get" class="code">Get</a>();
for (<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> pPixel : tileBounds) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-RendersamplesinpixelmonopPixel-0">Render samples in pixel <tt>pPixel</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-33" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-33"><i></i></a><div id="fragbit-33" class="collapse show"><div class="fragmentcode">       for (int sampleIndex = waveStart; sampleIndex &lt; waveEnd; ++sampleIndex) {
           sampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::StartPixelSample" class="code">StartPixelSample</a>(pPixel, sampleIndex);
           <a href="#ImageTileIntegrator::EvaluatePixelSample" class="code">EvaluatePixelSample</a>(pPixel, sampleIndex, sampler, scratchBuffer);
           scratchBuffer.<a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer::Reset" class="code">Reset</a>();
       }</div></div>
}
progress.<a href="../Utilities/User_Interaction.html#ProgressReporter::Update" class="code">Update</a>((waveEnd - waveStart) * tileBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::Area" class="code">Area</a>());</div><p>


</p>
<p>Given a pixel to take one or more samples in, the thread&rsquo;s <tt>Sampler</tt>
is notified that it should start generating samples for the current pixel
via <tt>StartPixelSample()</tt>, which allows it to set up any internal state that
depends on which pixel is currently being processed.  The integrator&rsquo;s
<tt>EvaluatePixelSample()</tt> method is then responsible for determining the
specified sample&rsquo;s value, after which any temporary memory it may have
allocated in the <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer"><tt>ScratchBuffer</tt></a> is freed with a call to
<tt>ScratchBuffer::Reset()</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-RendersamplesinpixelmonopPixel-0"></span><div class="fragmentname">&lt;&lt;Render samples in pixel <tt>pPixel</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">for (int sampleIndex = waveStart; sampleIndex &lt; waveEnd; ++sampleIndex) {
    sampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::StartPixelSample" class="code">StartPixelSample</a>(pPixel, sampleIndex);
    <a href="#ImageTileIntegrator::EvaluatePixelSample" class="code">EvaluatePixelSample</a>(pPixel, sampleIndex, sampler, scratchBuffer);
    scratchBuffer.<a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer::Reset" class="code">Reset</a>();
}</div><p>


</p>
<p>Having provided an implementation of the pure virtual
<a href="#Integrator::Render"><tt>Integrator::Render()</tt></a> method, <a href="#ImageTileIntegrator"><tt>ImageTileIntegrator</tt></a> now imposes
the requirement on its subclasses that they implement the following
<tt>EvaluatePixelSample()</tt> method.

</p>
<p></p>
<span class="anchor" id="fragment-ImageTileIntegratorPublicMethods-1"></span><div class="fragmentname">&lt;&lt;ImageTileIntegrator Public Methods&gt;&gt;+=&nbsp;<a href="#fragment-ImageTileIntegratorPublicMethods-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">virtual void <span class="anchor" id="ImageTileIntegrator::EvaluatePixelSample"></span>EvaluatePixelSample(<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> pPixel, int sampleIndex,
    <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> sampler, <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer" class="code">ScratchBuffer</a> &amp;scratchBuffer) = 0;</div><p>


</p>
<p>After the parallel <tt>for</tt> loop for the current wave completes, the range of
sample indices to be processed in the next wave is computed.

</p>
<p></p>
<span class="anchor" id="fragment-Updatestartandendwave-0"></span><div class="fragmentname">&lt;&lt;Update start and end wave&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">waveStart = waveEnd;
waveEnd = std::min(spp, waveEnd + nextWaveSize);
nextWaveSize = std::min(2 * nextWaveSize, 64);
</div><p>


</p>
<p>If the user has provided the <tt>&ndash;write-partial-images</tt> command-line
option, the in-progress image is written to disk before the next wave of
samples is processed.  We will not include here the fragment that takes care of
this, &lt;&lt;<span class="fragmentname">Optionally write current image to disk</span>&gt;&gt;.

</p>
<p>

</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#RayIntegratorImplementation"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="RayIntegratorImplementation"></span><h3>1.3.5  RayIntegrator Implementation</h3><p>


</p>
<p>Just as the <a href="#ImageTileIntegrator"><tt>ImageTileIntegrator</tt></a> centralizes functionality related to
integrators that decompose the image into tiles, <a href="#RayIntegrator"><tt>RayIntegrator</tt></a>
provides commonly used functionality to integrators that trace ray paths
starting from the camera. All of the integrators implemented in
Chapters&nbsp;<a href="../Light_Transport_I_Surface_Reflection.html#chap:light-transport">13</a>


and&nbsp;<a href="../Light_Transport_II_Volume_Rendering.html#chap:volume-integration">14</a>

inherit from <a href="#RayIntegrator"><tt>RayIntegrator</tt></a>.

</p>
<p></p>
<span class="anchor" id="fragment-RayIntegratorDefinition-0"></span><div class="fragmentname">&lt;&lt;RayIntegrator Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="RayIntegrator"></span>RayIntegrator : public <a href="#ImageTileIntegrator" class="code">ImageTileIntegrator</a> {
  public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-RayIntegratorPublicMethods-0">RayIntegrator Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-34" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-34"><i></i></a><div id="fragbit-34" class="collapse show"><div class="fragmentcode">       RayIntegrator(<a href="../Cameras_and_Film/Camera_Interface.html#Camera" class="code">Camera</a> camera, <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> sampler, <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a> aggregate,
                     std::vector&lt;<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a>&gt; lights)
           : <a href="#ImageTileIntegrator" class="code">ImageTileIntegrator</a>(camera, sampler, aggregate, lights) {}
       void EvaluatePixelSample(<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> pPixel, int sampleIndex,
                                <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> sampler, <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer" class="code">ScratchBuffer</a> &amp;scratchBuffer) final;
       virtual <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> Li(
           <a href="../Geometry_and_Transformations/Rays.html#RayDifferential" class="code">RayDifferential</a> ray, <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda, <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> sampler,
           <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer" class="code">ScratchBuffer</a> &amp;scratchBuffer, <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface" class="code">VisibleSurface</a> *visibleSurface) const = 0;</div></div>
};</div><p>


</p>
<p>Its constructor does nothing more than pass along the provided objects to
the <a href="#ImageTileIntegrator"><tt>ImageTileIntegrator</tt></a> constructor.

</p>
<p></p>
<span class="anchor" id="fragment-RayIntegratorPublicMethods-0"></span><div class="fragmentname">&lt;&lt;RayIntegrator Public Methods&gt;&gt;=&nbsp;<a href="#fragment-RayIntegratorPublicMethods-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">RayIntegrator(<a href="../Cameras_and_Film/Camera_Interface.html#Camera" class="code">Camera</a> camera, <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> sampler, <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a> aggregate,
              std::vector&lt;<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a>&gt; lights)
    : <a href="#ImageTileIntegrator" class="code">ImageTileIntegrator</a>(camera, sampler, aggregate, lights) {}</div><p>


</p>
<p><tt>RayIntegrator</tt> implements the pure virtual
<tt>EvaluatePixelSample()</tt> method from <a href="#ImageTileIntegrator"><tt>ImageTileIntegrator</tt></a>.  At the
given pixel, it uses its <a href="../Cameras_and_Film/Camera_Interface.html#Camera"><tt>Camera</tt></a> and <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> to generate a ray
into the scene and then calls the <tt>Li()</tt> method, which is provided by
the subclass, to determine the amount of light arriving at the image plane
along that ray.  As we will see in following chapters, the units of the
value returned by this method are related to the incident spectral radiance
at the ray origin, which is generally denoted by the symbol <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.272ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 978.4 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper L Subscript normal i</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D43F" d="M643 247c0 0 0 -3 -4 -14l-79 -216c-6 -17 -7 -17 -31 -17h-463c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 12 20 19 20l133 -3l148 3c5 0 16 0 16 -12 c0 -19 -8 -19 -38 -19c-94 0 -97 -11 -106 -47l-135 -540c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h94c173 0 217 114 251 206c7 16 8 21 17 21s12 -7 12 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D43F" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="963" y="-213"></use>
</g>
</svg>
in equations&mdash;thus, the method name.  This value is passed to the
<a href="../Cameras_and_Film/Film_and_Imaging.html#Film"><tt>Film</tt></a>, which records the ray&rsquo;s contribution to the image.

</p>
<p>Figure&nbsp;<a href="#fig:main-render-loop-classes">1.18</a> summarizes the main classes used
in this method and the flow of data among them.

</p>
<p></p>
<span class="anchor" id="fig:main-render-loop-classes"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="pha01f18.svg" title=""><img src="pha01f18.svg" width=782 height=232 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 1.18: Class Relationships for
<tt>RayIntegrator::EvaluatePixelSample()</tt>&rsquo;s
computation. <span class="legend"> The <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> provides sample values for each image sample to be taken.  The <a href="../Cameras_and_Film/Camera_Interface.html#Camera"><tt>Camera</tt></a> turns a sample
into a corresponding ray from the film plane, and the <tt>Li()</tt> method
computes the radiance along that ray arriving at the film.  The sample and
its radiance are passed to the <a href="../Cameras_and_Film/Film_and_Imaging.html#Film"><tt>Film</tt></a>, which stores their contribution
in an image.</span>
</figcaption>
</div></div><p>


</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-RayIntegratorMethodDefinitions-0"></span><div class="fragmentname">&lt;&lt;RayIntegrator Method Definitions&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">void <span class="anchor" id="RayIntegrator::EvaluatePixelSample"></span>RayIntegrator::EvaluatePixelSample(<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> pPixel, int sampleIndex,
        <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> sampler, <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer" class="code">ScratchBuffer</a> &amp;scratchBuffer) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Samplewavelengthsfortheray-0">Sample wavelengths for the ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-35" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-35"><i></i></a><div id="fragbit-35" class="collapse show"><div class="fragmentcode">       Float lu = sampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Get1D" class="code">Get1D</a>();
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> lambda = <a href="#ImageTileIntegrator::camera" class="code">camera</a>.<a href="../Cameras_and_Film/Camera_Interface.html#Camera::GetFilm" class="code">GetFilm</a>().<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::SampleWavelengths" class="code">SampleWavelengths</a>(lu);</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonoCameraSampleforcurrentsample-0">Initialize <tt>CameraSample</tt> for current sample</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-36" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-36"><i></i></a><div id="fragbit-36" class="collapse show"><div class="fragmentcode">       <a href="../Sampling_and_Reconstruction/Image_Reconstruction.html#Filter" class="code">Filter</a> filter = <a href="#ImageTileIntegrator::camera" class="code">camera</a>.<a href="../Cameras_and_Film/Camera_Interface.html#Camera::GetFilm" class="code">GetFilm</a>().<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::GetFilter" class="code">GetFilter</a>();
       <a href="../Cameras_and_Film/Camera_Interface.html#CameraSample" class="code">CameraSample</a> cameraSample = <a href="../Sampling_and_Reconstruction/Image_Reconstruction.html#GetCameraSample" class="code">GetCameraSample</a>(sampler, pPixel, filter);</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Generatecamerarayforcurrentsample-0">Generate camera ray for current sample</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-37" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-37"><i></i></a><div id="fragbit-37" class="collapse show"><div class="fragmentcode">       pstd::optional&lt;<a href="../Cameras_and_Film/Camera_Interface.html#CameraRayDifferential" class="code">CameraRayDifferential</a>&gt; cameraRay =
           <a href="#ImageTileIntegrator::camera" class="code">camera</a>.<a href="../Cameras_and_Film/Camera_Interface.html#Camera::GenerateRayDifferential" class="code">GenerateRayDifferential</a>(cameraSample, lambda);</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-TracemonocameraRayifvalid-0">Trace <tt>cameraRay</tt> if valid</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-38" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-38"><i></i></a><div id="fragbit-38" class="collapse show"><div class="fragmentcode">       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> L(0.);
       <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface" class="code">VisibleSurface</a> visibleSurface;
       if (cameraRay) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Scalecameraraydifferentialsbasedonimagesamplingrate-0">Scale camera ray differentials based on image sampling rate</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-39" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-39"><i></i></a><div id="fragbit-39" class="collapse show"><div class="fragmentcode">              Float rayDiffScale =
                  std::max&lt;Float&gt;(.125f, 1 / std::sqrt((Float)sampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::SamplesPerPixel" class="code">SamplesPerPixel</a>()));
              cameraRay-&gt;ray.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::ScaleDifferentials" class="code">ScaleDifferentials</a>(rayDiffScale);</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Evaluateradiancealongcameraray-0">Evaluate radiance along camera ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-40" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-40"><i></i></a><div id="fragbit-40" class="collapse show"><div class="fragmentcode">              bool initializeVisibleSurface = <a href="#ImageTileIntegrator::camera" class="code">camera</a>.<a href="../Cameras_and_Film/Camera_Interface.html#Camera::GetFilm" class="code">GetFilm</a>().<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::UsesVisibleSurface" class="code">UsesVisibleSurface</a>();
              L = cameraRay-&gt;<a href="../Cameras_and_Film/Camera_Interface.html#CameraRayDifferential::weight" class="code">weight</a> *
                  <a href="#RayIntegrator::Li" class="code">Li</a>(cameraRay-&gt;<a href="../Cameras_and_Film/Camera_Interface.html#CameraRayDifferential::ray" class="code">ray</a>, lambda, sampler, scratchBuffer,
                     initializeVisibleSurface ? &amp;visibleSurface : nullptr);</div></div>
           &lt;&lt;<span class="fragmentname">Issue warning if unexpected radiance value is returned</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-41" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-41"><i></i></a><div id="fragbit-41" class="collapse show"><div class="fragmentcode">              if (L.HasNaNs()) {
                  LOG_ERROR("Not-a-number radiance value returned for pixel (%d, "
                            "%d), sample %d. Setting to black.",
                            pPixel.x, pPixel.y, sampleIndex);
                  L = <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
              } else if (IsInf(L.y(lambda))) {
                  LOG_ERROR("Infinite radiance value returned for pixel (%d, %d), "
                            "sample %d. Setting to black.",
                            pPixel.x, pPixel.y, sampleIndex);
                  L = <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
              }</div></div>
       }</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Addcamerarayscontributiontoimage-0">Add camera ray&rsquo;s contribution to image</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-42" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-42"><i></i></a><div id="fragbit-42" class="collapse show"><div class="fragmentcode">       <a href="#ImageTileIntegrator::camera" class="code">camera</a>.<a href="../Cameras_and_Film/Camera_Interface.html#Camera::GetFilm" class="code">GetFilm</a>().<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::AddSample" class="code">AddSample</a>(pPixel, L, lambda, &amp;visibleSurface,
                                  cameraSample.<a href="../Cameras_and_Film/Camera_Interface.html#CameraSample::filterWeight" class="code">filterWeight</a>);</div></div>
}</div><p>


</p>
<p>Each ray carries radiance at a number of discrete wavelengths <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.355ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 583.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">lamda</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D706" d="M548 -1c0 -3 -1 -9 -11 -10h-22c-27 0 -37 0 -53 22c-16 23 -64 176 -105 281l-241 -284c-8 -10 -17 -21 -33 -21s-30 12 -30 29c0 13 6 19 18 31l276 274l-97 272c-25 68 -32 74 -65 80c0 0 -9 2 -9 10c0 11 13 11 18 11c47 0 101 -13 122 -71l204 -569 c7 -20 13 -35 23 -46c3 -4 5 -6 5 -9Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D706" x="0" y="0"></use>
</g>
</svg> (four, by
default).  When computing the color at each pixel, <tt>pbrt</tt> chooses
different wavelengths at different pixel samples so that the final result
better reflects the correct result over all wavelengths.
To choose these wavelengths, a sample value <tt>lu</tt> is first provided by
the <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a>.  This value will be uniformly distributed and in the range <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.91ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2114.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-bracket 0 comma 1 right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-5B" d="M256 -230c0 -11 -9 -20 -20 -20h-122v1000h122c11 0 20 -9 20 -20s-9 -20 -20 -20h-82v-920h82c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-5B" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-30" x="278" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="779" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="1224" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="1724" y="0"></use>
</g>
</svg>.  The
<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::SampleWavelengths"><tt>Film::SampleWavelengths()</tt></a> method then maps this sample to a set
of specific wavelengths, taking into account its model of film sensor
response as a function of wavelength.  Most <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> implementations
ensure that if multiple samples are taken in a pixel, those samples
are in the aggregate well distributed over <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.91ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2114.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-bracket 0 comma 1 right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-5B" d="M256 -230c0 -11 -9 -20 -20 -20h-122v1000h122c11 0 20 -9 20 -20s-9 -20 -20 -20h-82v-920h82c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-5B" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-30" x="278" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="779" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="1224" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="1724" y="0"></use>
</g>
</svg>.  In turn, they ensure
that  the sampled wavelengths  are also well distributed across the range
of valid wavelengths, improving image quality.

</p>
<p></p>
<span class="anchor" id="fragment-Samplewavelengthsfortheray-0"></span><div class="fragmentname">&lt;&lt;Sample wavelengths for the ray&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">Float lu = sampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Get1D" class="code">Get1D</a>();
<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> lambda = <a href="#ImageTileIntegrator::camera" class="code">camera</a>.<a href="../Cameras_and_Film/Camera_Interface.html#Camera::GetFilm" class="code">GetFilm</a>().<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::SampleWavelengths" class="code">SampleWavelengths</a>(lu);</div><p>


</p>
<p>The <a href="../Cameras_and_Film/Camera_Interface.html#CameraSample"><tt>CameraSample</tt></a> structure records the position on the film for which
the camera should generate a ray.  This position is affected by both a
sample position provided by the sampler and the
reconstruction filter that is used to filter multiple sample values into a
single value for the pixel.  <a href="../Sampling_and_Reconstruction/Image_Reconstruction.html#GetCameraSample"><tt>GetCameraSample()</tt></a> handles those calculations.
<a href="../Cameras_and_Film/Camera_Interface.html#CameraSample"><tt>CameraSample</tt></a> also stores a time that is associated with the ray as
well as a lens position sample, which are used when rendering scenes
with moving objects and for camera models that simulate non-pinhole
apertures, respectively.

</p>
<p></p>
<span class="anchor" id="fragment-InitializemonoCameraSampleforcurrentsample-0"></span><div class="fragmentname">&lt;&lt;Initialize <tt>CameraSample</tt> for current sample&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Sampling_and_Reconstruction/Image_Reconstruction.html#Filter" class="code">Filter</a> filter = <a href="#ImageTileIntegrator::camera" class="code">camera</a>.<a href="../Cameras_and_Film/Camera_Interface.html#Camera::GetFilm" class="code">GetFilm</a>().<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::GetFilter" class="code">GetFilter</a>();
<a href="../Cameras_and_Film/Camera_Interface.html#CameraSample" class="code">CameraSample</a> cameraSample = <a href="../Sampling_and_Reconstruction/Image_Reconstruction.html#GetCameraSample" class="code">GetCameraSample</a>(sampler, pPixel, filter);</div><p>


</p>
<p>The <a href="../Cameras_and_Film/Camera_Interface.html#Camera"><tt>Camera</tt></a> interface provides two methods to generate rays:
<tt>GenerateRay()</tt>, which returns the ray for a given image sample
position, and <tt>GenerateRayDifferential()</tt>, which returns a <em>ray
differential</em>, which incorporates information about the rays that the
camera would generate for samples that are one pixel away on the image
plane in both the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg> directions.  Ray differentials are used to
get better results from some of the texture functions defined in
Chapter&nbsp;<a href="../Textures_and_Materials.html#chap:texture">10</a>, by making it possible to compute how quickly a
texture varies with respect to the pixel spacing, which is a key component
of texture antialiasing.

</p>
<p>Some <a href="../Cameras_and_Film/Camera_Interface.html#CameraSample"><tt>CameraSample</tt></a> values may not correspond to valid rays for a given
camera.

Therefore,
<tt>pstd::optional</tt> is used for the <a href="../Cameras_and_Film/Camera_Interface.html#CameraRayDifferential"><tt>CameraRayDifferential</tt></a> returned
by the camera.

</p>
<p></p>
<span class="anchor" id="fragment-Generatecamerarayforcurrentsample-0"></span><div class="fragmentname">&lt;&lt;Generate camera ray for current sample&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">pstd::optional&lt;<a href="../Cameras_and_Film/Camera_Interface.html#CameraRayDifferential" class="code">CameraRayDifferential</a>&gt; cameraRay =
    <a href="#ImageTileIntegrator::camera" class="code">camera</a>.<a href="../Cameras_and_Film/Camera_Interface.html#Camera::GenerateRayDifferential" class="code">GenerateRayDifferential</a>(cameraSample, lambda);</div><p>


</p>
<p>If the camera ray is valid, it is passed along to the <a href="#RayIntegrator"><tt>RayIntegrator</tt></a>
subclass&rsquo;s <tt>Li()</tt> method implementation after some additional
preparation.  In addition to returning the radiance along the ray <tt>L</tt>,
the subclass is also responsible for initializing an instance of the
<a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface"><tt>VisibleSurface</tt></a> class, which records geometric information about the
surface the ray intersects (if any) at each pixel for the use
of <tt>Film</tt> implementations like the <a href="../Cameras_and_Film/Film_and_Imaging.html#GBufferFilm"><tt>GBufferFilm</tt></a> that store
more information than just color at each pixel.

</p>
<p></p>
<span class="anchor" id="fragment-TracemonocameraRayifvalid-0"></span><div class="fragmentname">&lt;&lt;Trace <tt>cameraRay</tt> if valid&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> L(0.);
<a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface" class="code">VisibleSurface</a> visibleSurface;
if (cameraRay) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Scalecameraraydifferentialsbasedonimagesamplingrate-0">Scale camera ray differentials based on image sampling rate</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-43" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-43"><i></i></a><div id="fragbit-43" class="collapse show"><div class="fragmentcode">       Float rayDiffScale =
           std::max&lt;Float&gt;(.125f, 1 / std::sqrt((Float)sampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::SamplesPerPixel" class="code">SamplesPerPixel</a>()));
       cameraRay-&gt;ray.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::ScaleDifferentials" class="code">ScaleDifferentials</a>(rayDiffScale);</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Evaluateradiancealongcameraray-0">Evaluate radiance along camera ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-44" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-44"><i></i></a><div id="fragbit-44" class="collapse show"><div class="fragmentcode">       bool initializeVisibleSurface = <a href="#ImageTileIntegrator::camera" class="code">camera</a>.<a href="../Cameras_and_Film/Camera_Interface.html#Camera::GetFilm" class="code">GetFilm</a>().<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::UsesVisibleSurface" class="code">UsesVisibleSurface</a>();
       L = cameraRay-&gt;<a href="../Cameras_and_Film/Camera_Interface.html#CameraRayDifferential::weight" class="code">weight</a> *
           <a href="#RayIntegrator::Li" class="code">Li</a>(cameraRay-&gt;<a href="../Cameras_and_Film/Camera_Interface.html#CameraRayDifferential::ray" class="code">ray</a>, lambda, sampler, scratchBuffer,
              initializeVisibleSurface ? &amp;visibleSurface : nullptr);</div></div>
    &lt;&lt;<span class="fragmentname">Issue warning if unexpected radiance value is returned</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-45" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-45"><i></i></a><div id="fragbit-45" class="collapse show"><div class="fragmentcode">       if (L.HasNaNs()) {
           LOG_ERROR("Not-a-number radiance value returned for pixel (%d, "
                     "%d), sample %d. Setting to black.",
                     pPixel.x, pPixel.y, sampleIndex);
           L = <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
       } else if (IsInf(L.y(lambda))) {
           LOG_ERROR("Infinite radiance value returned for pixel (%d, %d), "
                     "sample %d. Setting to black.",
                     pPixel.x, pPixel.y, sampleIndex);
           L = <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
       }</div></div>
}</div><p>


</p>
<p>Before the ray is passed to the <tt>Li()</tt> method, the
<tt>ScaleDifferentials()</tt> method scales the differential rays to account
for the actual spacing between samples on the film plane when multiple
samples are taken per pixel.

</p>
<p></p>
<span class="anchor" id="fragment-Scalecameraraydifferentialsbasedonimagesamplingrate-0"></span><div class="fragmentname">&lt;&lt;Scale camera ray differentials based on image sampling rate&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">Float rayDiffScale =
    std::max&lt;Float&gt;(.125f, 1 / std::sqrt((Float)sampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::SamplesPerPixel" class="code">SamplesPerPixel</a>()));
cameraRay-&gt;ray.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::ScaleDifferentials" class="code">ScaleDifferentials</a>(rayDiffScale);</div><p>


</p>
<p>For <tt>Film</tt> implementations that do not store geometric information at
each pixel, it is worth saving the work of populating the
<a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface"><tt>VisibleSurface</tt></a> class.  Therefore, a pointer to this class is only
passed in the call to the <tt>Li()</tt> method if it is necessary, and a null
pointer is passed otherwise.  Integrator implementations then should only
initialize the <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface"><tt>VisibleSurface</tt></a> if it is non-null.

</p>
<p><a href="../Cameras_and_Film/Camera_Interface.html#CameraRayDifferential"><tt>CameraRayDifferential</tt></a> also carries a weight associated with the ray
that is used to scale the returned radiance value.  For simple camera
models, each ray is weighted equally, but camera models that more
accurately simulate the process of image formation by lens systems may
generate some rays that contribute more than others.  Such a camera model
might simulate the effect of less light arriving at the edges of the film
plane than at the center, an effect called <em>vignetting</em>.

</p>
<p></p>
<span class="anchor" id="fragment-Evaluateradiancealongcameraray-0"></span><div class="fragmentname">&lt;&lt;Evaluate radiance along camera ray&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">bool initializeVisibleSurface = <a href="#ImageTileIntegrator::camera" class="code">camera</a>.<a href="../Cameras_and_Film/Camera_Interface.html#Camera::GetFilm" class="code">GetFilm</a>().<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::UsesVisibleSurface" class="code">UsesVisibleSurface</a>();
L = cameraRay-&gt;<a href="../Cameras_and_Film/Camera_Interface.html#CameraRayDifferential::weight" class="code">weight</a> *
    <a href="#RayIntegrator::Li" class="code">Li</a>(cameraRay-&gt;<a href="../Cameras_and_Film/Camera_Interface.html#CameraRayDifferential::ray" class="code">ray</a>, lambda, sampler, scratchBuffer,
       initializeVisibleSurface ? &amp;visibleSurface : nullptr);</div><p>


</p>
<p><tt>Li()</tt> is a pure virtual method that <a href="#RayIntegrator"><tt>RayIntegrator</tt></a> subclasses
must implement.  It returns the incident radiance at the origin of a given
ray, sampled at the specified wavelengths.

</p>
<p></p>
<span class="anchor" id="fragment-RayIntegratorPublicMethods-1"></span><div class="fragmentname">&lt;&lt;RayIntegrator Public Methods&gt;&gt;+=&nbsp;<a href="#fragment-RayIntegratorPublicMethods-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">virtual <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="RayIntegrator::Li"></span>Li(
    <a href="../Geometry_and_Transformations/Rays.html#RayDifferential" class="code">RayDifferential</a> ray, <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda, <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> sampler,
    <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer" class="code">ScratchBuffer</a> &amp;scratchBuffer, <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface" class="code">VisibleSurface</a> *visibleSurface) const = 0;</div><p>


</p>
<p>A common side effect of bugs in the rendering process is that impossible
radiance values are computed.  For example, division by zero results in
radiance values equal to either the IEEE floating-point infinity or a &ldquo;not a
number&rdquo; value.  The renderer looks for these possibilities and prints an
error message when it encounters them.  Here we will not include the fragment
that does this, &lt;&lt;<span class="fragmentname">Issue warning if unexpected radiance value is
returned</span>&gt;&gt;.  See the implementation in <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/cpu/integrator.cpp"><tt>cpu/integrator.cpp</tt></a> if
you are interested in its details.

</p>
<p>

</p>
<p>After the radiance arriving at the ray&rsquo;s origin is known, a call to
<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::AddSample"><tt>Film::AddSample()</tt></a> updates the corresponding pixel in the image,
given the weighted radiance for the sample.  The details of how sample
values are recorded in the film are explained in
Sections&nbsp;<a href="../Cameras_and_Film/Film_and_Imaging.html#sec:image-pipeline">5.4</a> and&nbsp;<a href="../Sampling_and_Reconstruction/Image_Reconstruction.html#sec:image-reconstruction">8.8</a>.

</p>
<p></p>
<span class="anchor" id="fragment-Addcamerarayscontributiontoimage-0"></span><div class="fragmentname">&lt;&lt;Add camera ray&rsquo;s contribution to image&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="#ImageTileIntegrator::camera" class="code">camera</a>.<a href="../Cameras_and_Film/Camera_Interface.html#Camera::GetFilm" class="code">GetFilm</a>().<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::AddSample" class="code">AddSample</a>(pPixel, L, lambda, &amp;visibleSurface,
                           cameraSample.<a href="../Cameras_and_Film/Camera_Interface.html#CameraSample::filterWeight" class="code">filterWeight</a>);</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#RandomWalkIntegrator"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:random-walk-integrator"></span><span id="RandomWalkIntegrator"></span><h3>1.3.6  Random Walk Integrator</h3><p>



</p>
<p>Although it has taken a few pages to go through the implementation of the
integrator infrastructure that culminated in <a href="#RayIntegrator"><tt>RayIntegrator</tt></a>, we can
now turn to implementing light transport integration algorithms in a
simpler context than having to start implementing a complete
<a href="#Integrator::Render"><tt>Integrator::Render()</tt></a> method.  The <tt>RandomWalkIntegrator</tt> that we
will describe in this section inherits from 
<a href="#RayIntegrator"><tt>RayIntegrator</tt></a> and thus all the details of multi-threading, generating the
initial ray from the camera and then adding the radiance along that ray
to the image, are all taken care of.  The integrator operates in a
simpler context: a ray has been provided and its task is to
compute the radiance arriving at its origin.

</p>
<p>Recall that in Section&nbsp;<a href="../Introduction/Photorealistic_Rendering_and_the_Ray-Tracing_Algorithm.html#sec:intro-ray-propagation">1.2.7</a> we mentioned that in
the absence of participating media, the light carried by a ray is unchanged
as it passes through free space.  We will ignore the possibility of
participating media in the implementation of this integrator, which allows
us to take a first step: given the first intersection of a ray with
the geometry in the scene, the radiance arriving at the ray&rsquo;s origin
is equal to the radiance leaving the intersection point toward the ray&rsquo;s
origin.
That outgoing radiance is given by the light transport equation
(<a href="../Introduction/Photorealistic_Rendering_and_the_Ray-Tracing_Algorithm.html#eq:rendering-equation">1.1</a>), though it is hopeless to evaluate it in
closed form.  Numerical approaches are required, and the ones used
in <tt>pbrt</tt> are based on Monte Carlo integration, which makes it possible to
estimate the values of integrals based on pointwise evaluation of their
integrands.  Chapter&nbsp;<a href="../Monte_Carlo_Integration.html#chap:mc">2</a> provides an introduction to Monte Carlo
integration, and additional Monte Carlo techniques will be introduced
as they are used throughout the book.

</p>
<p>In order to compute the outgoing radiance,
the <tt>RandomWalkIntegrator</tt> implements a simple Monte Carlo
approach that is based on incrementally constructing a <em>random walk</em>,
where a series of points on scene surfaces are randomly chosen in
succession to construct light-carrying paths starting from the camera.
This approach effectively models
image formation in the real world in reverse, starting from the camera
rather than from the light sources.  Going backward in this respect is
still physically valid because the physical models of light that <tt>pbrt</tt> is
based on are time-reversible.

</p>
<p></p>
<span class="anchor" id="fig:random-walk-integrator-image"></span><div class="card outerfigure"><div class="card-body figure"><p>


</p>

<div class="card-img-top" style="display:block; width: 100%; padding-top: 133.262%; position:relative;">
<div id="random-walk-insanity.exr1" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0;"></div></div>
<script>
// MGH: Fixed
Jeri.renderViewer(document.getElementById('random-walk-insanity.exr1'), { image: 'random-walk-insanity.exr' });
</script>
<figcaption class="caption">Figure 1.19: A View of the <em>Watercolor</em> Scene, Rendered with the
<a href="#RandomWalkIntegrator"><tt>RandomWalkIntegrator</tt></a>. <span class="legend">
Because the <tt>RandomWalkIntegrator</tt> does not handle perfectly specular
surfaces, the two glasses on the table are black.  Furthermore, even with
the 8,192 samples per pixel used to render this image, the result is still
peppered with high-frequency noise. (Note, for example, the far wall and the
base of the chair.)
<em>(Scene courtesy of Angelo Ferretti.)</em>
</span>
</figcaption>
</div></div><p>


</p>
<p>Although the implementation
of the random walk sampling algorithm is in total just over twenty lines of
code, it is capable of simulating complex lighting and shading effects;
Figure&nbsp;<a href="#fig:random-walk-integrator-image">1.19</a> shows an image
rendered using it.  (That image required many hours of computation to
achieve that level of quality, however.)
For the remainder of this section, we will gloss over a
few of the mathematical details of
the integrator&rsquo;s implementation and focus on an intuitive understanding of the
approach, though subsequent chapters will fill in the gaps and explain this
and more sophisticated techniques more rigorously.

</p>
<p></p>
<span class="anchor" id="fragment-RandomWalkIntegratorDefinition-0"></span><div class="fragmentname">&lt;&lt;RandomWalkIntegrator Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="RandomWalkIntegrator"></span>RandomWalkIntegrator : public <a href="#RayIntegrator" class="code">RayIntegrator</a> {
  public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-RandomWalkIntegratorPublicMethods-0">RandomWalkIntegrator Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-46" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-46"><i></i></a><div id="fragbit-46" class="collapse show"><div class="fragmentcode">       RandomWalkIntegrator(int maxDepth, <a href="../Cameras_and_Film/Camera_Interface.html#Camera" class="code">Camera</a> camera, <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> sampler,
                        <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a> aggregate, std::vector&lt;<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a>&gt; lights)
           : RayIntegrator(camera, sampler, aggregate, lights), maxDepth(maxDepth) {}
       
       static std::unique_ptr&lt;RandomWalkIntegrator&gt; Create(
           const ParameterDictionary &amp;parameters, <a href="../Cameras_and_Film/Camera_Interface.html#Camera" class="code">Camera</a> camera, <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> sampler,
           <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a> aggregate, std::vector&lt;<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a>&gt; lights, const FileLoc *loc);
       
       std::string ToString() const;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> Li(<a href="../Geometry_and_Transformations/Rays.html#RayDifferential" class="code">RayDifferential</a> ray, <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda,
               <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> sampler, <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer" class="code">ScratchBuffer</a> &amp;scratchBuffer,
               <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface" class="code">VisibleSurface</a> *visibleSurface) const {
           return <a href="#RandomWalkIntegrator::LiRandomWalk" class="code">LiRandomWalk</a>(ray, lambda, sampler, scratchBuffer, 0);
       }</div></div>
  private:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-RandomWalkIntegratorPrivateMethods-0">RandomWalkIntegrator Private Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-47" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-47"><i></i></a><div id="fragbit-47" class="collapse show"><div class="fragmentcode">       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> LiRandomWalk(<a href="../Geometry_and_Transformations/Rays.html#RayDifferential" class="code">RayDifferential</a> ray,
               <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda, <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> sampler,
               <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer" class="code">ScratchBuffer</a> &amp;scratchBuffer, int depth) const {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Intersectraywithsceneandreturnifnointersection-0">Intersect ray with scene and return if no intersection</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-48" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-48"><i></i></a><div id="fragbit-48" class="collapse show"><div class="fragmentcode">              pstd::optional&lt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection" class="code">ShapeIntersection</a>&gt; si = <a href="#Integrator::Intersect" class="code">Intersect</a>(ray);
              if (!si) {
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Returnemittedlightfrominfinitelightsources-0">Return emitted light from infinite light sources</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-49" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-49"><i></i></a><div id="fragbit-49" class="collapse show"><div class="fragmentcode">                     <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a>(0.f);
                     for (<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a> light : <a href="#Integrator::infiniteLights" class="code">infiniteLights</a>)
                         <a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a> += light.<a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a>(ray, lambda);
                     return <a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a>;</div></div>
              }
              <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> &amp;isect = si-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection::intr" class="code">intr</a>;</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Getemittedradianceatsurfaceintersection-0">Get emitted radiance at surface intersection</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-50" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-50"><i></i></a><div id="fragbit-50" class="collapse show"><div class="fragmentcode">              <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wo = -ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>;
              <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="../Light_Sources/Area_Lights.html#SurfaceInteraction::Le" class="code">Le</a> = isect.<a href="../Light_Sources/Area_Lights.html#SurfaceInteraction::Le" class="code">Le</a>(wo, lambda);</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Terminaterandomwalkifmaximumdepthhasbeenreached-0">Terminate random walk if maximum depth has been reached</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-51" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-51"><i></i></a><div id="fragbit-51" class="collapse show"><div class="fragmentcode">              if (depth == <a href="#RandomWalkIntegrator::maxDepth" class="code">maxDepth</a>)
                  return Le;</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputeBSDFatrandomwalkintersectionpoint-0">Compute BSDF at random walk intersection point</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-52" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-52"><i></i></a><div id="fragbit-52" class="collapse show"><div class="fragmentcode">              <a href="../Reflection_Models/BSDF_Representation.html#BSDF" class="code">BSDF</a> bsdf = isect.<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#SurfaceInteraction::GetBSDF" class="code">GetBSDF</a>(ray, lambda, camera, scratchBuffer, sampler);
              </div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Randomlysampledirectionleavingsurfaceforrandomwalk-0">Randomly sample direction leaving surface for random walk</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-53" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-53"><i></i></a><div id="fragbit-53" class="collapse show"><div class="fragmentcode">              <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> u = sampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Get2D" class="code">Get2D</a>();
              <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wp = <a href="../Sampling_Algorithms/Sampling_Multidimensional_Functions.html#SampleUniformSphere" class="code">SampleUniformSphere</a>(u);</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-EvaluateBSDFatsurfaceforsampleddirection-0">Evaluate BSDF at surface for sampled direction</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-54" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-54"><i></i></a><div id="fragbit-54" class="collapse show"><div class="fragmentcode">              <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> fcos = bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::f" class="code">f</a>(wo, wp) * <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(wp, isect.shading.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading::n" class="code">n</a>);
              if (!fcos)
                  return Le;</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Recursivelytraceraytoestimateincidentradianceatsurface-0">Recursively trace ray to estimate incident radiance at surface</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-55" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-55"><i></i></a><div id="fragbit-55" class="collapse show"><div class="fragmentcode">              ray = isect.<a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#SurfaceInteraction::SpawnRay" class="code">SpawnRay</a>(wp);
              return Le  + fcos * <a href="#RandomWalkIntegrator::LiRandomWalk" class="code">LiRandomWalk</a>(ray, lambda, sampler, scratchBuffer,
                                               depth + 1) / (1 / (4 * <a href="../Utilities/Mathematical_Infrastructure.html#Pi" class="code">Pi</a>));</div></div>
       }</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-RandomWalkIntegratorPrivateMembers-0">RandomWalkIntegrator Private Members</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-56" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-56"><i></i></a><div id="fragbit-56" class="collapse show"><div class="fragmentcode">       int maxDepth;</div></div>
};</div><p>


</p>
<p>

</p>
<p>This integrator recursively evaluates the random walk.
Therefore, its <tt>Li()</tt> method implementation does little more than start the recursion, via a
call to the <tt>LiRandomWalk()</tt> method.  Most of the parameters to
<tt>Li()</tt> are just passed along, though the
<a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface"><tt>VisibleSurface</tt></a> is ignored for this simple integrator and an
additional parameter is added to track the depth of recursion.

</p>
<p></p>
<span class="anchor" id="fragment-RandomWalkIntegratorPublicMethods-0"></span><div class="fragmentname">&lt;&lt;RandomWalkIntegrator Public Methods&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="RandomWalkIntegrator::Li"></span>Li(<a href="../Geometry_and_Transformations/Rays.html#RayDifferential" class="code">RayDifferential</a> ray, <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda,
        <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> sampler, <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer" class="code">ScratchBuffer</a> &amp;scratchBuffer,
        <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface" class="code">VisibleSurface</a> *visibleSurface) const {
    return <a href="#RandomWalkIntegrator::LiRandomWalk" class="code">LiRandomWalk</a>(ray, lambda, sampler, scratchBuffer, 0);
}</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-RandomWalkIntegratorPrivateMethods-0"></span><div class="fragmentname">&lt;&lt;RandomWalkIntegrator Private Methods&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="RandomWalkIntegrator::LiRandomWalk"></span>LiRandomWalk(<a href="../Geometry_and_Transformations/Rays.html#RayDifferential" class="code">RayDifferential</a> ray,
        <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda, <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> sampler,
        <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer" class="code">ScratchBuffer</a> &amp;scratchBuffer, int depth) const {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Intersectraywithsceneandreturnifnointersection-0">Intersect ray with scene and return if no intersection</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-57" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-57"><i></i></a><div id="fragbit-57" class="collapse show"><div class="fragmentcode">       pstd::optional&lt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection" class="code">ShapeIntersection</a>&gt; si = <a href="#Integrator::Intersect" class="code">Intersect</a>(ray);
       if (!si) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Returnemittedlightfrominfinitelightsources-0">Return emitted light from infinite light sources</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-58" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-58"><i></i></a><div id="fragbit-58" class="collapse show"><div class="fragmentcode">              <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a>(0.f);
              for (<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a> light : <a href="#Integrator::infiniteLights" class="code">infiniteLights</a>)
                  <a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a> += light.<a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a>(ray, lambda);
              return <a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a>;</div></div>
       }
       <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> &amp;isect = si-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection::intr" class="code">intr</a>;</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Getemittedradianceatsurfaceintersection-0">Get emitted radiance at surface intersection</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-59" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-59"><i></i></a><div id="fragbit-59" class="collapse show"><div class="fragmentcode">       <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wo = -ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="../Light_Sources/Area_Lights.html#SurfaceInteraction::Le" class="code">Le</a> = isect.<a href="../Light_Sources/Area_Lights.html#SurfaceInteraction::Le" class="code">Le</a>(wo, lambda);</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Terminaterandomwalkifmaximumdepthhasbeenreached-0">Terminate random walk if maximum depth has been reached</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-60" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-60"><i></i></a><div id="fragbit-60" class="collapse show"><div class="fragmentcode">       if (depth == <a href="#RandomWalkIntegrator::maxDepth" class="code">maxDepth</a>)
           return Le;</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputeBSDFatrandomwalkintersectionpoint-0">Compute BSDF at random walk intersection point</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-61" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-61"><i></i></a><div id="fragbit-61" class="collapse show"><div class="fragmentcode">       <a href="../Reflection_Models/BSDF_Representation.html#BSDF" class="code">BSDF</a> bsdf = isect.<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#SurfaceInteraction::GetBSDF" class="code">GetBSDF</a>(ray, lambda, camera, scratchBuffer, sampler);
       </div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Randomlysampledirectionleavingsurfaceforrandomwalk-0">Randomly sample direction leaving surface for random walk</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-62" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-62"><i></i></a><div id="fragbit-62" class="collapse show"><div class="fragmentcode">       <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> u = sampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Get2D" class="code">Get2D</a>();
       <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wp = <a href="../Sampling_Algorithms/Sampling_Multidimensional_Functions.html#SampleUniformSphere" class="code">SampleUniformSphere</a>(u);</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-EvaluateBSDFatsurfaceforsampleddirection-0">Evaluate BSDF at surface for sampled direction</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-63" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-63"><i></i></a><div id="fragbit-63" class="collapse show"><div class="fragmentcode">       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> fcos = bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::f" class="code">f</a>(wo, wp) * <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(wp, isect.shading.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading::n" class="code">n</a>);
       if (!fcos)
           return Le;</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Recursivelytraceraytoestimateincidentradianceatsurface-0">Recursively trace ray to estimate incident radiance at surface</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-64" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-64"><i></i></a><div id="fragbit-64" class="collapse show"><div class="fragmentcode">       ray = isect.<a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#SurfaceInteraction::SpawnRay" class="code">SpawnRay</a>(wp);
       return Le  + fcos * <a href="#RandomWalkIntegrator::LiRandomWalk" class="code">LiRandomWalk</a>(ray, lambda, sampler, scratchBuffer,
                                        depth + 1) / (1 / (4 * <a href="../Utilities/Mathematical_Infrastructure.html#Pi" class="code">Pi</a>));</div></div>
}</div><p>


</p>
<p>The first step is to find the closest intersection of the ray with the shapes
in the scene. If no intersection is found, the ray has left the scene.
Otherwise, a <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction"><tt>SurfaceInteraction</tt></a> that is returned as part of the
<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection"><tt>ShapeIntersection</tt></a> structure provides information about the local
geometric properties of the intersection point.

</p>
<p></p>
<span class="anchor" id="fragment-Intersectraywithsceneandreturnifnointersection-0"></span><div class="fragmentname">&lt;&lt;Intersect ray with scene and return if no intersection&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">pstd::optional&lt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection" class="code">ShapeIntersection</a>&gt; si = <a href="#Integrator::Intersect" class="code">Intersect</a>(ray);
if (!si) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Returnemittedlightfrominfinitelightsources-0">Return emitted light from infinite light sources</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-65" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-65"><i></i></a><div id="fragbit-65" class="collapse show"><div class="fragmentcode">       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a>(0.f);
       for (<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a> light : <a href="#Integrator::infiniteLights" class="code">infiniteLights</a>)
           <a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a> += light.<a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a>(ray, lambda);
       return <a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a>;</div></div>
}
<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> &amp;isect = si-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection::intr" class="code">intr</a>;</div><p>


</p>
<p>If no intersection was found, radiance still may be carried along the ray
due to light sources such as the <a href="../Light_Sources/Infinite_Area_Lights.html#ImageInfiniteLight"><tt>ImageInfiniteLight</tt></a> that do not
have geometry associated with them.  The <a href="../Light_Sources/Light_Interface.html#Light::Le"><tt>Light::Le()</tt></a> method
allows such lights to return their radiance for a given ray.

</p>
<p></p>
<span class="anchor" id="fragment-Returnemittedlightfrominfinitelightsources-0"></span><div class="fragmentname">&lt;&lt;Return emitted light from infinite light sources&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a>(0.f);
for (<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a> light : <a href="#Integrator::infiniteLights" class="code">infiniteLights</a>)
    <a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a> += light.<a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a>(ray, lambda);
return <a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a>;</div><p>


</p>
<p>If a valid intersection has been found, we must evaluate the light
transport equation at the intersection point.  The first term,
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.181ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 3952.9 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper L Subscript normal e Superscript Baseline left-parenthesis normal p Subscript Baseline comma omega Subscript normal o Baseline right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D43F" d="M643 247c0 0 0 -3 -4 -14l-79 -216c-6 -17 -7 -17 -31 -17h-463c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 12 20 19 20l133 -3l148 3c5 0 16 0 16 -12 c0 -19 -8 -19 -38 -19c-94 0 -97 -11 -106 -47l-135 -540c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h94c173 0 217 114 251 206c7 16 8 21 17 21s12 -7 12 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-65" d="M415 119c0 -19 -45 -130 -167 -130c-115 0 -220 97 -220 231c0 125 92 228 208 228c125 0 179 -97 179 -196c0 -21 -3 -21 -25 -21h-279c0 -36 0 -102 30 -150c23 -37 63 -67 113 -67c10 0 100 0 135 103c2 8 4 14 13 14c5 0 13 -2 13 -12zM349 252 c0 39 -10 174 -113 174c-34 0 -118 -25 -124 -174h237Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-70" d="M521 216c0 -129 -104 -227 -223 -227c-76 0 -118 54 -123 70v-9v-168c0 -45 11 -45 78 -45v-31l-113 3l-112 -3v31c67 0 78 0 78 45v468c0 44 -7 50 -78 50v31l144 11v-66c20 22 62 66 140 66c112 0 209 -99 209 -226zM438 216c0 113 -61 201 -134 201 c-51 0 -100 -29 -129 -80v-223c0 -20 0 -21 14 -42c27 -41 65 -61 105 -61c74 0 144 84 144 205Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D714" d="M604 372c0 -40 -12 -90 -23 -133c-30 -121 -93 -250 -197 -250c-67 0 -102 44 -113 106c-38 -62 -90 -106 -153 -106c-76 0 -105 62 -105 143c0 35 5 74 15 112c16 63 41 127 82 184c5 6 12 9 18 9c3 0 6 0 9 -2c5 -3 9 -8 9 -14c0 -4 -2 -9 -5 -13 c-38 -53 -74 -109 -89 -169c-5 -22 -8 -45 -8 -65c0 -63 26 -113 87 -113c55 0 103 39 136 93c1 29 5 59 13 90c5 22 15 47 34 47c14 0 19 -11 19 -26c0 -8 -2 -17 -4 -26c-7 -30 -17 -60 -30 -88c9 -52 42 -90 98 -90c79 0 137 92 160 183c3 12 4 25 4 37 c0 35 -13 66 -38 88c-7 7 -11 15 -11 25c0 11 5 22 14 32c10 10 23 16 35 16c9 0 17 -3 23 -9c15 -13 20 -35 20 -61Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6F" d="M471 214c0 -127 -101 -225 -222 -225c-117 0 -221 96 -221 225c0 125 97 234 222 234c121 0 221 -106 221 -234zM388 222c0 38 0 96 -26 139s-69 65 -113 65c-40 0 -87 -21 -114 -67c-24 -44 -24 -98 -24 -137c0 -36 0 -97 25 -141c27 -46 71 -67 114 -67 c50 0 94 29 116 74c22 44 22 98 22 134Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D43F" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-65" x="963" y="-213"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="1095" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-70" x="1485" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="2041" y="0"></use>
<g transform="translate(2486,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6F" x="880" y="-213"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="3563" y="0"></use>
</g>
</svg>, which is the emitted radiance, is easy: emission is
part of the scene specification and the emitted radiance is available by
calling the <a href="../Light_Sources/Area_Lights.html#SurfaceInteraction::Le"><tt>SurfaceInteraction::Le()</tt></a> method, which takes the outgoing
direction of interest.  Here, we are interested in radiance emitted back
along the ray&rsquo;s direction.  If the object is not emissive, that method returns
a zero-valued spectral distribution.

</p>
<p></p>
<span class="anchor" id="fragment-Getemittedradianceatsurfaceintersection-0"></span><div class="fragmentname">&lt;&lt;Get emitted radiance at surface intersection&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wo = -ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>;
<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="../Light_Sources/Area_Lights.html#SurfaceInteraction::Le" class="code">Le</a> = isect.<a href="../Light_Sources/Area_Lights.html#SurfaceInteraction::Le" class="code">Le</a>(wo, lambda);</div><p>


</p>
<p>Evaluating the second term of the light
transport equation requires computing an integral over the sphere of
directions around the intersection point <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.293ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 556.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal p Subscript</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-70" d="M521 216c0 -129 -104 -227 -223 -227c-76 0 -118 54 -123 70v-9v-168c0 -45 11 -45 78 -45v-31l-113 3l-112 -3v31c67 0 78 0 78 45v468c0 44 -7 50 -78 50v31l144 11v-66c20 22 62 66 140 66c112 0 209 -99 209 -226zM438 216c0 113 -61 201 -134 201 c-51 0 -100 -29 -129 -80v-223c0 -20 0 -21 14 -42c27 -41 65 -61 105 -61c74 0 144 84 144 205Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-70" x="0" y="0"></use>
</g>
</svg>.  Application of the
principles of Monte Carlo integration can be used to show that if
directions <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.347ex" height="2.343ex" style="vertical-align: -0.338ex;" viewBox="0 -863.1 1010.6 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">omega prime Subscript</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D714" d="M604 372c0 -40 -12 -90 -23 -133c-30 -121 -93 -250 -197 -250c-67 0 -102 44 -113 106c-38 -62 -90 -106 -153 -106c-76 0 -105 62 -105 143c0 35 5 74 15 112c16 63 41 127 82 184c5 6 12 9 18 9c3 0 6 0 9 -2c5 -3 9 -8 9 -14c0 -4 -2 -9 -5 -13 c-38 -53 -74 -109 -89 -169c-5 -22 -8 -45 -8 -65c0 -63 26 -113 87 -113c55 0 103 39 136 93c1 29 5 59 13 90c5 22 15 47 34 47c14 0 19 -11 19 -26c0 -8 -2 -17 -4 -26c-7 -30 -17 -60 -30 -88c9 -52 42 -90 98 -90c79 0 137 92 160 183c3 12 4 25 4 37 c0 35 -13 66 -38 88c-7 7 -11 15 -11 25c0 11 5 22 14 32c10 10 23 16 35 16c9 0 17 -3 23 -9c15 -13 20 -35 20 -61Z"></path>
<path stroke-width="1" id="E1-LATINMODERNVARIANTS-2032" d="M340 496c0 -10 -3 -20 -8 -28l-227 -372h-38l171 424c6 15 26 29 48 29c30 0 54 -24 54 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNVARIANTS-2032" x="880" y="513"></use>
</g>
</svg> are chosen with equal probability over all possible
directions, then an estimate of the integral can be computed as a
weighted product of the BSDF <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.283ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 552.5 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">f</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D453" d="M552 636c0 -38 -29 -60 -55 -60c-19 0 -37 12 -37 35c0 15 10 50 54 54c-19 18 -45 18 -49 18c-21 0 -38 -15 -47 -34c-6 -12 -20 -83 -24 -104c-11 -58 -10 -56 -21 -114h83c17 0 27 0 27 -11c0 -20 -10 -20 -30 -20h-86l-60 -317c-1 -7 -24 -128 -56 -191 c-18 -38 -58 -97 -113 -97c-41 0 -85 24 -85 69c0 38 29 60 55 60c19 0 37 -12 37 -35c0 -15 -9 -51 -55 -54c19 -18 44 -18 48 -18c52 0 69 91 87 188l75 395h-66c-19 0 -28 0 -28 12c0 19 11 19 30 19h69c24 126 27 136 33 157c30 99 93 117 127 117c41 0 87 -23 87 -69Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D453" x="0" y="0"></use>
</g>
</svg>, which describes the light scattering
properties of the material at <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.293ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 556.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal p Subscript</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-70" d="M521 216c0 -129 -104 -227 -223 -227c-76 0 -118 54 -123 70v-9v-168c0 -45 11 -45 78 -45v-31l-113 3l-112 -3v31c67 0 78 0 78 45v468c0 44 -7 50 -78 50v31l144 11v-66c20 22 62 66 140 66c112 0 209 -99 209 -226zM438 216c0 113 -61 201 -134 201 c-51 0 -100 -29 -129 -80v-223c0 -20 0 -21 14 -42c27 -41 65 -61 105 -61c74 0 144 84 144 205Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-70" x="0" y="0"></use>
</g>
</svg>, the incident lighting,
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.272ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 978.4 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper L Subscript normal i</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D43F" d="M643 247c0 0 0 -3 -4 -14l-79 -216c-6 -17 -7 -17 -31 -17h-463c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 12 20 19 20l133 -3l148 3c5 0 16 0 16 -12 c0 -19 -8 -19 -38 -19c-94 0 -97 -11 -106 -47l-135 -540c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h94c173 0 217 114 251 206c7 16 8 21 17 21s12 -7 12 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D43F" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="963" y="-213"></use>
</g>
</svg>, and a cosine factor:
</p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="eq:simple-mc-estimator-random-walk"></span><div class="displaymath"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="67.627ex" height="6.509ex" style="vertical-align: -2.671ex;" viewBox="0 -1652.5 29117.1 2802.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">integral Underscript script upper S squared Endscripts f Subscript Baseline left-parenthesis normal p Subscript Baseline comma omega Subscript normal o Baseline comma omega Subscript normal i Baseline right-parenthesis upper L Subscript normal i Baseline left-parenthesis normal p Subscript Baseline comma omega Subscript normal i Baseline right-parenthesis StartAbsoluteValue cosine theta Subscript normal i Baseline EndAbsoluteValue normal d omega Subscript normal i Baseline almost-equals StartFraction f Subscript Baseline left-parenthesis normal p Subscript Baseline comma omega Subscript normal o Baseline comma omega prime Subscript Baseline right-parenthesis upper L Subscript normal i Baseline left-parenthesis normal p Subscript Baseline comma omega prime Subscript Baseline right-parenthesis StartAbsoluteValue cosine theta Superscript prime Baseline EndAbsoluteValue Over 1 slash 4 pi EndFraction period</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNSIZE1-222B" d="M943 1268c0 -35 -25 -50 -49 -50c-23 0 -48 16 -48 49c0 25 17 47 50 49c-4 4 -29 23 -60 23c-39 0 -73 -129 -85 -178c-34 -129 -71 -329 -108 -542c-54 -321 -119 -640 -196 -956c-71 -290 -128 -524 -280 -524c-61 0 -111 42 -111 93c0 35 25 50 49 50 c23 0 48 -16 48 -49c0 -25 -17 -47 -49 -49c0 0 25 -23 61 -23c81 0 127 188 145 261c33 139 62 306 88 459c110 654 246 1156 249 1167c55 204 111 313 187 313c55 0 109 -39 109 -93Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-53" d="M499 186c0 -110 -80 -208 -197 -208c-89 0 -153 36 -184 70c-33 -53 -36 -57 -36 -57c-7 -11 -8 -13 -15 -13c-11 0 -11 7 -11 24v200c0 18 0 25 13 25c3 0 11 0 12 -10c1 -36 4 -100 62 -154c53 -49 129 -54 158 -54c84 0 134 72 134 143c0 33 -10 66 -31 92 c-28 37 -58 44 -85 51c-70 17 -121 29 -132 33c-78 27 -131 100 -131 183c0 106 84 194 195 194c89 0 130 -41 160 -70l35 57c7 12 8 13 15 13c11 0 11 -7 11 -24v-201c0 -19 0 -24 -13 -24c-11 0 -11 6 -12 12c-6 45 -28 209 -195 209c-78 0 -132 -61 -132 -131 c0 -58 39 -112 101 -127l128 -31c84 -20 150 -102 150 -202Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D453" d="M552 636c0 -38 -29 -60 -55 -60c-19 0 -37 12 -37 35c0 15 10 50 54 54c-19 18 -45 18 -49 18c-21 0 -38 -15 -47 -34c-6 -12 -20 -83 -24 -104c-11 -58 -10 -56 -21 -114h83c17 0 27 0 27 -11c0 -20 -10 -20 -30 -20h-86l-60 -317c-1 -7 -24 -128 -56 -191 c-18 -38 -58 -97 -113 -97c-41 0 -85 24 -85 69c0 38 29 60 55 60c19 0 37 -12 37 -35c0 -15 -9 -51 -55 -54c19 -18 44 -18 48 -18c52 0 69 91 87 188l75 395h-66c-19 0 -28 0 -28 12c0 19 11 19 30 19h69c24 126 27 136 33 157c30 99 93 117 127 117c41 0 87 -23 87 -69Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-70" d="M521 216c0 -129 -104 -227 -223 -227c-76 0 -118 54 -123 70v-9v-168c0 -45 11 -45 78 -45v-31l-113 3l-112 -3v31c67 0 78 0 78 45v468c0 44 -7 50 -78 50v31l144 11v-66c20 22 62 66 140 66c112 0 209 -99 209 -226zM438 216c0 113 -61 201 -134 201 c-51 0 -100 -29 -129 -80v-223c0 -20 0 -21 14 -42c27 -41 65 -61 105 -61c74 0 144 84 144 205Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D714" d="M604 372c0 -40 -12 -90 -23 -133c-30 -121 -93 -250 -197 -250c-67 0 -102 44 -113 106c-38 -62 -90 -106 -153 -106c-76 0 -105 62 -105 143c0 35 5 74 15 112c16 63 41 127 82 184c5 6 12 9 18 9c3 0 6 0 9 -2c5 -3 9 -8 9 -14c0 -4 -2 -9 -5 -13 c-38 -53 -74 -109 -89 -169c-5 -22 -8 -45 -8 -65c0 -63 26 -113 87 -113c55 0 103 39 136 93c1 29 5 59 13 90c5 22 15 47 34 47c14 0 19 -11 19 -26c0 -8 -2 -17 -4 -26c-7 -30 -17 -60 -30 -88c9 -52 42 -90 98 -90c79 0 137 92 160 183c3 12 4 25 4 37 c0 35 -13 66 -38 88c-7 7 -11 15 -11 25c0 11 5 22 14 32c10 10 23 16 35 16c9 0 17 -3 23 -9c15 -13 20 -35 20 -61Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6F" d="M471 214c0 -127 -101 -225 -222 -225c-117 0 -221 96 -221 225c0 125 97 234 222 234c121 0 221 -106 221 -234zM388 222c0 38 0 96 -26 139s-69 65 -113 65c-40 0 -87 -21 -114 -67c-24 -44 -24 -98 -24 -137c0 -36 0 -97 25 -141c27 -46 71 -67 114 -67 c50 0 94 29 116 74c22 44 22 98 22 134Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D43F" d="M643 247c0 0 0 -3 -4 -14l-79 -216c-6 -17 -7 -17 -31 -17h-463c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 12 20 19 20l133 -3l148 3c5 0 16 0 16 -12 c0 -19 -8 -19 -38 -19c-94 0 -97 -11 -106 -47l-135 -540c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h94c173 0 217 114 251 206c7 16 8 21 17 21s12 -7 12 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-7C" d="M159 -230c0 -11 -9 -20 -20 -20s-20 9 -20 20v960c0 11 9 20 20 20s20 -9 20 -20v-960Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-63" d="M415 119c0 -10 -32 -130 -166 -130c-116 0 -215 99 -215 227c0 124 92 232 217 232c77 0 153 -39 153 -107c0 -30 -20 -47 -46 -47c-28 0 -46 20 -46 46c0 13 6 43 47 46c-35 36 -98 37 -107 37c-53 0 -135 -42 -135 -205c0 -161 88 -204 141 -204c37 0 102 12 131 105 c2 6 4 10 13 10c3 0 13 0 13 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-73" d="M360 128c0 -72 -46 -139 -161 -139c-21 0 -66 1 -110 43c-18 -19 -18 -21 -20 -23c-19 -19 -20 -20 -25 -20c-11 0 -11 7 -11 24v132c0 18 0 25 13 25c10 0 11 -4 14 -17c19 -85 55 -142 139 -142c78 0 113 40 113 91c0 72 -82 88 -104 92c-72 14 -100 20 -132 46 c-27 22 -43 50 -43 85c0 56 38 123 160 123c15 0 56 0 94 -28c4 3 14 12 17 16c13 12 15 12 20 12c11 0 11 -7 11 -24v-101c0 -19 0 -24 -13 -24c0 0 -11 0 -12 9c-2 31 -7 121 -117 121c-86 0 -112 -41 -112 -76c0 -58 67 -71 123 -82c42 -8 81 -16 114 -48 c12 -12 42 -42 42 -95Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D703" d="M455 500c0 -224 -152 -511 -293 -511c-91 0 -120 111 -120 205c0 229 154 511 293 511c102 0 120 -139 120 -205zM389 562c0 57 -6 121 -55 121c-45 0 -82 -56 -109 -105c-40 -71 -60 -151 -77 -215h209c24 99 32 150 32 199zM348 331h-208c-26 -98 -32 -156 -32 -198 c0 -93 21 -122 54 -122c43 0 81 49 116 117c38 72 59 157 70 203Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-64" d="M527 0l-147 -11v66c-25 -32 -70 -66 -134 -66c-114 0 -212 99 -212 226c0 129 105 227 223 227c54 0 97 -26 126 -62v216c0 49 -8 56 -78 56v31l144 11v-607c0 -49 8 -56 78 -56v-31zM380 118v205c0 18 0 20 -11 37c-31 45 -73 60 -108 60c-54 0 -92 -33 -113 -64 c-29 -45 -31 -105 -31 -142c0 -41 3 -98 29 -139c24 -38 60 -64 105 -64c43 0 88 22 118 70c11 17 11 19 11 37Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2248" d="M717 438v-2c-20 -93 -56 -149 -139 -169c-11 -3 -23 -4 -35 -4c-62 0 -120 37 -172 76c-43 32 -89 67 -138 67c-9 0 -17 -1 -26 -3c-67 -17 -111 -49 -127 -124c-1 -5 -6 -9 -12 -9c-7 0 -12 5 -12 12v2c20 93 56 149 139 169c12 3 24 4 35 4c62 0 120 -37 172 -76 c43 -32 89 -67 139 -67c8 0 16 1 25 3c67 17 111 49 127 124c2 5 6 9 12 9c7 0 12 -5 12 -12zM717 218v-2c-20 -93 -56 -149 -139 -169c-11 -3 -23 -4 -35 -4c-62 0 -120 37 -172 76c-43 32 -89 67 -138 67c-9 0 -17 -1 -26 -3c-67 -17 -111 -49 -127 -124 c-1 -5 -6 -9 -12 -9c-7 0 -12 5 -12 12v2c20 93 56 149 139 169c12 3 24 4 35 4c62 0 120 -37 172 -76c43 -32 89 -67 139 -67c8 0 16 1 25 3c67 17 111 49 127 124c2 5 6 9 12 9c7 0 12 -5 12 -12Z"></path>
<path stroke-width="1" id="E1-LATINMODERNVARIANTS-2032" d="M340 496c0 -10 -3 -20 -8 -28l-227 -372h-38l171 424c6 15 26 29 48 29c30 0 54 -24 54 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2F" d="M445 730c0 -2 0 -5 -1 -7l-349 -960c-3 -8 -10 -13 -19 -13c-11 0 -20 9 -20 20c0 2 0 5 1 7l349 960c3 8 10 13 19 13c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-34" d="M471 165h-100v-87c0 -36 2 -47 76 -47h21v-31c-41 3 -94 3 -136 3s-94 0 -135 -3v31h21c74 0 76 11 76 47v87h-266v31l307 469c8 12 11 12 20 12c16 0 16 -6 16 -26v-455h100v-31zM300 196v373l-244 -373h244Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D70B" d="M567 407c0 -34 -36 -34 -49 -34h-114c-11 -52 -18 -106 -18 -159c0 -28 0 -93 29 -165c6 -14 6 -16 6 -22c0 -20 -21 -38 -41 -38c-15 0 -26 6 -36 50c-8 34 -8 61 -8 76c0 67 9 110 42 258h-113l-56 -221c-13 -50 -13 -52 -27 -98c-12 -37 -20 -65 -50 -65 c-13 0 -29 8 -29 27c0 7 0 9 8 24c42 91 96 212 128 333h-57c-20 0 -78 0 -127 -77c-6 -8 -8 -12 -16 -12c-12 0 -12 10 -12 10c0 5 26 51 61 90c44 47 82 47 104 47h335c19 0 40 0 40 -24Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2E" d="M192 53c0 -29 -24 -53 -53 -53s-53 24 -53 53s24 53 53 53s53 -24 53 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNSIZE1-222B" x="0" y="0"></use>
<g transform="translate(574,-898)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-53" x="0" y="0"></use>
 <use transform="scale(0.574)" xlink:href="#E1-LATINMODERNMAIN-32" x="685" y="483"></use>
</g>
<g transform="translate(1592,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D453" x="0" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="2349" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-70" x="2739" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="3295" y="0"></use>
<g transform="translate(3741,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6F" x="880" y="-213"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="4817" y="0"></use>
<g transform="translate(5262,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="880" y="-213"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="6182" y="0"></use>
<g transform="translate(6738,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D43F" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="963" y="-213"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="978" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-70" x="1367" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="1924" y="0"></use>
<g transform="translate(2369,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="880" y="-213"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="3289" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-7C" x="10583" y="0"></use>
<g transform="translate(10861,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-63"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-6F" x="444" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-73" x="945" y="0"></use>
</g>
<g transform="translate(12368,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D703" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="663" y="-213"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-7C" x="13134" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-64" x="13579" y="0"></use>
<g transform="translate(14136,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="880" y="-213"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2248" x="15333" y="0"></use>
<g transform="translate(16106,0)">
<g transform="translate(397,0)">
<rect stroke="none" width="12213" height="60" x="0" y="220"></rect>
<g transform="translate(60,770)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D453" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="757" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-70" x="1146" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="1703" y="0"></use>
<g transform="translate(2148,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6F" x="880" y="-213"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="3224" y="0"></use>
<g transform="translate(3669,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNVARIANTS-2032" x="880" y="513"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="4680" y="0"></use>
<g transform="translate(5236,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D43F" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="963" y="-213"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="978" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-70" x="1367" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="1924" y="0"></use>
<g transform="translate(2369,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNVARIANTS-2032" x="880" y="513"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="3380" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-7C" x="9173" y="0"></use>
<g transform="translate(9451,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-63"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-6F" x="444" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-73" x="945" y="0"></use>
</g>
<g transform="translate(10957,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D703" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNVARIANTS-2032" x="663" y="513"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-7C" x="11815" y="0"></use>
</g>
<g transform="translate(5070,-771)">
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2F" x="500" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-34" x="1001" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D70B" x="1501" y="0"></use>
</g>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2E" x="28838" y="0"></use>
</g>
</svg>
</div>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">
<div class="eqno">(<a href="#eq:simple-mc-estimator-random-walk">1.2</a>)</div>
</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">
<p>


</p>
<p>In other words, given a random direction <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.347ex" height="2.343ex" style="vertical-align: -0.338ex;" viewBox="0 -863.1 1010.6 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">omega prime Subscript</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D714" d="M604 372c0 -40 -12 -90 -23 -133c-30 -121 -93 -250 -197 -250c-67 0 -102 44 -113 106c-38 -62 -90 -106 -153 -106c-76 0 -105 62 -105 143c0 35 5 74 15 112c16 63 41 127 82 184c5 6 12 9 18 9c3 0 6 0 9 -2c5 -3 9 -8 9 -14c0 -4 -2 -9 -5 -13 c-38 -53 -74 -109 -89 -169c-5 -22 -8 -45 -8 -65c0 -63 26 -113 87 -113c55 0 103 39 136 93c1 29 5 59 13 90c5 22 15 47 34 47c14 0 19 -11 19 -26c0 -8 -2 -17 -4 -26c-7 -30 -17 -60 -30 -88c9 -52 42 -90 98 -90c79 0 137 92 160 183c3 12 4 25 4 37 c0 35 -13 66 -38 88c-7 7 -11 15 -11 25c0 11 5 22 14 32c10 10 23 16 35 16c9 0 17 -3 23 -9c15 -13 20 -35 20 -61Z"></path>
<path stroke-width="1" id="E1-LATINMODERNVARIANTS-2032" d="M340 496c0 -10 -3 -20 -8 -28l-227 -372h-38l171 424c6 15 26 29 48 29c30 0 54 -24 54 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNVARIANTS-2032" x="880" y="513"></use>
</g>
</svg>, estimating the value
of the integral requires evaluating the terms in the integrand for 
that direction and then scaling by a factor of <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.487ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 1071 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">4 pi</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-34" d="M471 165h-100v-87c0 -36 2 -47 76 -47h21v-31c-41 3 -94 3 -136 3s-94 0 -135 -3v31h21c74 0 76 11 76 47v87h-266v31l307 469c8 12 11 12 20 12c16 0 16 -6 16 -26v-455h100v-31zM300 196v373l-244 -373h244Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D70B" d="M567 407c0 -34 -36 -34 -49 -34h-114c-11 -52 -18 -106 -18 -159c0 -28 0 -93 29 -165c6 -14 6 -16 6 -22c0 -20 -21 -38 -41 -38c-15 0 -26 6 -36 50c-8 34 -8 61 -8 76c0 67 9 110 42 258h-113l-56 -221c-13 -50 -13 -52 -27 -98c-12 -37 -20 -65 -50 -65 c-13 0 -29 8 -29 27c0 7 0 9 8 24c42 91 96 212 128 333h-57c-20 0 -78 0 -127 -77c-6 -8 -8 -12 -16 -12c-12 0 -12 10 -12 10c0 5 26 51 61 90c44 47 82 47 104 47h335c19 0 40 0 40 -24Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-34" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D70B" x="500" y="0"></use>
</g>
</svg>.  (This factor, which
is derived in Section&nbsp;<a href="../Sampling_Algorithms/Sampling_Multidimensional_Functions.html#sec:unisample-hemi">A.5.2</a>, relates
to the surface area of a unit sphere.)  Since only a single direction is considered, there
is almost always error in the Monte Carlo estimate compared to the true
value of the integral.  However, it can be
shown that estimates like this one are correct <em>in expectation</em>:
informally, that they give the correct result on average.
Averaging multiple independent estimates generally reduces
this error&mdash;hence, the practice of taking multiple samples per pixel.

</p>
<p>The BSDF and the cosine factor of the estimate are easily evaluated,
leaving us with <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.272ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 978.4 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper L Subscript normal i</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D43F" d="M643 247c0 0 0 -3 -4 -14l-79 -216c-6 -17 -7 -17 -31 -17h-463c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 12 20 19 20l133 -3l148 3c5 0 16 0 16 -12 c0 -19 -8 -19 -38 -19c-94 0 -97 -11 -106 -47l-135 -540c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h94c173 0 217 114 251 206c7 16 8 21 17 21s12 -7 12 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D43F" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="963" y="-213"></use>
</g>
</svg>, the incident radiance, unknown.  However, note that
we have found ourselves right back where we started with the initial call to
<tt>LiRandomWalk()</tt>: we have a ray for which we would like to find the
incident radiance at the origin&mdash;that, a recursive call to
<tt>LiRandomWalk()</tt> will provide.

</p>
<p>Before computing the estimate of the integral, we must consider terminating
the recursion.
The <tt>RandomWalkIntegrator</tt> stops at a
predetermined maximum depth, <tt>maxDepth</tt>.  Without this termination
criterion, the algorithm might never terminate (imagine, e.g., a
hall-of-mirrors scene). This member variable is initialized in the
constructor based on a parameter that can be set in the scene description
file.

</p>
<p></p>
<span class="anchor" id="fragment-RandomWalkIntegratorPrivateMembers-0"></span><div class="fragmentname">&lt;&lt;RandomWalkIntegrator Private Members&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int <span class="anchor" id="RandomWalkIntegrator::maxDepth"></span>maxDepth;</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-Terminaterandomwalkifmaximumdepthhasbeenreached-0"></span><div class="fragmentname">&lt;&lt;Terminate random walk if maximum depth has been reached&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (depth == <a href="#RandomWalkIntegrator::maxDepth" class="code">maxDepth</a>)
    return Le;</div><p>


</p>
<p>If the random walk is not terminated, the
<tt>SurfaceInteraction::GetBSDF()</tt> method is called to find
the BSDF at the intersection point.  It evaluates texture functions to
determine surface properties and then initializes a representation of the
BSDF.  It generally needs to allocate memory for the objects that
constitute the BSDF&rsquo;s representation; because this memory only needs to be
active when processing the current ray, the <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer"><tt>ScratchBuffer</tt></a> is provided to it to
use for its allocations.

</p>
<p></p>
<span class="anchor" id="fragment-ComputeBSDFatrandomwalkintersectionpoint-0"></span><div class="fragmentname">&lt;&lt;Compute BSDF at random walk intersection point&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Reflection_Models/BSDF_Representation.html#BSDF" class="code">BSDF</a> bsdf = isect.<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#SurfaceInteraction::GetBSDF" class="code">GetBSDF</a>(ray, lambda, camera, scratchBuffer, sampler);
</div><p>


</p>
<p>Next, we need to sample a random direction <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.347ex" height="2.343ex" style="vertical-align: -0.338ex;" viewBox="0 -863.1 1010.6 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">omega prime Subscript</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D714" d="M604 372c0 -40 -12 -90 -23 -133c-30 -121 -93 -250 -197 -250c-67 0 -102 44 -113 106c-38 -62 -90 -106 -153 -106c-76 0 -105 62 -105 143c0 35 5 74 15 112c16 63 41 127 82 184c5 6 12 9 18 9c3 0 6 0 9 -2c5 -3 9 -8 9 -14c0 -4 -2 -9 -5 -13 c-38 -53 -74 -109 -89 -169c-5 -22 -8 -45 -8 -65c0 -63 26 -113 87 -113c55 0 103 39 136 93c1 29 5 59 13 90c5 22 15 47 34 47c14 0 19 -11 19 -26c0 -8 -2 -17 -4 -26c-7 -30 -17 -60 -30 -88c9 -52 42 -90 98 -90c79 0 137 92 160 183c3 12 4 25 4 37 c0 35 -13 66 -38 88c-7 7 -11 15 -11 25c0 11 5 22 14 32c10 10 23 16 35 16c9 0 17 -3 23 -9c15 -13 20 -35 20 -61Z"></path>
<path stroke-width="1" id="E1-LATINMODERNVARIANTS-2032" d="M340 496c0 -10 -3 -20 -8 -28l-227 -372h-38l171 424c6 15 26 29 48 29c30 0 54 -24 54 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNVARIANTS-2032" x="880" y="513"></use>
</g>
</svg> to compute the estimate
in Equation&nbsp;(<a href="#eq:simple-mc-estimator-random-walk">1.2</a>).  The
<a href="../Sampling_Algorithms/Sampling_Multidimensional_Functions.html#SampleUniformSphere"><tt>SampleUniformSphere()</tt></a> function returns a uniformly distributed
direction on the unit sphere, given two uniform values in <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.91ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2114.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-bracket 0 comma 1 right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-5B" d="M256 -230c0 -11 -9 -20 -20 -20h-122v1000h122c11 0 20 -9 20 -20s-9 -20 -20 -20h-82v-920h82c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-5B" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-30" x="278" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="779" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="1224" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="1724" y="0"></use>
</g>
</svg> 
that are provided here by the sampler.

</p>
<p></p>
<span class="anchor" id="fragment-Randomlysampledirectionleavingsurfaceforrandomwalk-0"></span><div class="fragmentname">&lt;&lt;Randomly sample direction leaving surface for random walk&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> u = sampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Get2D" class="code">Get2D</a>();
<a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wp = <a href="../Sampling_Algorithms/Sampling_Multidimensional_Functions.html#SampleUniformSphere" class="code">SampleUniformSphere</a>(u);</div><p>


</p>
<p>All the factors of the Monte Carlo estimate other than the incident
radiance can now be readily evaluated.  The <a href="../Reflection_Models/BSDF_Representation.html#BSDF"><tt>BSDF</tt></a> class provides an
<tt>f()</tt> method that evaluates the BSDF for a pair of specified
directions, and the cosine of the angle with the surface normal
can be computed using the <a href="../Geometry_and_Transformations/Vectors.html#AbsDot"><tt>AbsDot()</tt></a> function, which
returns the absolute value of the dot product between two vectors.  If the
vectors are normalized, as both are here, this value is equal to the absolute
value of the cosine of the angle between them
(Section&nbsp;<a href="../Geometry_and_Transformations/Vectors.html#sec:dot-cross-product">3.3.2</a>).

</p>
<p>It is possible that the BSDF will be zero-valued for the provided
directions and thus that <tt>fcos</tt> will be as well&mdash;for example, the
BSDF is zero if the surface is not transmissive but the two directions are
on opposite sides of it.<button style="button" data-toggle="tooltip" data-placement="right" data-html="true" class="btn footnote-button" title="It would be easy enough to check if the
BSDF was only reflective and to only sample directions on the same side of
the surface as the ray, but for this simple integrator we will not bother.">
      <sup>&dagger;</sup>
    </button>
		
In that case, there is no reason to continue the random walk, since
subsequent points will make no contribution to the result.

</p>
<p></p>
<span class="anchor" id="fragment-EvaluateBSDFatsurfaceforsampleddirection-0"></span><div class="fragmentname">&lt;&lt;Evaluate BSDF at surface for sampled direction&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> fcos = bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::f" class="code">f</a>(wo, wp) * <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(wp, isect.shading.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading::n" class="code">n</a>);
if (!fcos)
    return Le;</div><p>


</p>
<p>The remaining task is to compute the new ray leaving the surface in the
sampled direction <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.347ex" height="2.343ex" style="vertical-align: -0.338ex;" viewBox="0 -863.1 1010.6 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">omega prime Subscript</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D714" d="M604 372c0 -40 -12 -90 -23 -133c-30 -121 -93 -250 -197 -250c-67 0 -102 44 -113 106c-38 -62 -90 -106 -153 -106c-76 0 -105 62 -105 143c0 35 5 74 15 112c16 63 41 127 82 184c5 6 12 9 18 9c3 0 6 0 9 -2c5 -3 9 -8 9 -14c0 -4 -2 -9 -5 -13 c-38 -53 -74 -109 -89 -169c-5 -22 -8 -45 -8 -65c0 -63 26 -113 87 -113c55 0 103 39 136 93c1 29 5 59 13 90c5 22 15 47 34 47c14 0 19 -11 19 -26c0 -8 -2 -17 -4 -26c-7 -30 -17 -60 -30 -88c9 -52 42 -90 98 -90c79 0 137 92 160 183c3 12 4 25 4 37 c0 35 -13 66 -38 88c-7 7 -11 15 -11 25c0 11 5 22 14 32c10 10 23 16 35 16c9 0 17 -3 23 -9c15 -13 20 -35 20 -61Z"></path>
<path stroke-width="1" id="E1-LATINMODERNVARIANTS-2032" d="M340 496c0 -10 -3 -20 -8 -28l-227 -372h-38l171 424c6 15 26 29 48 29c30 0 54 -24 54 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNVARIANTS-2032" x="880" y="513"></use>
</g>
</svg>.  This task is handled by the <tt>SpawnRay()</tt> method, which
returns a ray leaving an intersection in the provided direction,
ensuring that the ray is sufficiently offset from the surface that it does
not incorrectly reintersect it due to round-off error.  Given the ray, the
recursive call to <tt>LiRandomWalk()</tt> can be made to estimate the
incident radiance, which completes the estimate of
Equation&nbsp;(<a href="#eq:simple-mc-estimator-random-walk">1.2</a>).

</p>
<p></p>
<span class="anchor" id="fragment-Recursivelytraceraytoestimateincidentradianceatsurface-0"></span><div class="fragmentname">&lt;&lt;Recursively trace ray to estimate incident radiance at surface&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">ray = isect.<a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#SurfaceInteraction::SpawnRay" class="code">SpawnRay</a>(wp);
return Le  + fcos * <a href="#RandomWalkIntegrator::LiRandomWalk" class="code">LiRandomWalk</a>(ray, lambda, sampler, scratchBuffer,
                                 depth + 1) / (1 / (4 * <a href="../Utilities/Mathematical_Infrastructure.html#Pi" class="code">Pi</a>));</div><p>


</p>
<p>This simple approach has many shortcomings. For example, if the
emissive surfaces are small, most ray paths will not find any light
and many rays will need to be traced to form an accurate
image.  In the limit case of a point light source, the image will be black,
since there is zero probability of intersecting such a light source.
Similar issues apply with BSDF models that scatter light in a concentrated
set of directions.  In the limiting case of a perfect mirror that scatters
incident light along a single direction, the <a href="#RandomWalkIntegrator"><tt>RandomWalkIntegrator</tt></a>
will never be able to randomly sample that direction.

</p>
<p>Those issues and more can be addressed through more sophisticated
application of Monte Carlo integration techniques.  In subsequent chapters,
we will introduce a succession of improvements that lead to much more
accurate results.  The integrators
that are defined in Chapters&nbsp;<a href="../Light_Transport_I_Surface_Reflection.html#chap:light-transport">13</a>
through&nbsp;<a href="../Wavefront_Rendering_on_GPUs.html#chap:gpu">15</a> are the culmination of those developments.
All still build on the same basic ideas used in the
<tt>RandomWalkIntegrator</tt>, but are much more efficient and robust than it
is.  Figure&nbsp;<a href="#fig:randomwalk-vs-path-integrator">1.20</a> compares the
<a href="#RandomWalkIntegrator"><tt>RandomWalkIntegrator</tt></a> to one of the
improved integrators and gives a sense of how much improvement is possible.

</p>
<p> </p>
<span class="anchor" id="fig:randomwalk-vs-path-integrator"></span><div class="card outerfigure"><div class="card-body figure"><p>


</p>

<div class="card-img-top" style="display:block; width: 100%; padding-top: 135.532%;  position:relative;"><div id="xa_RandomWalkIntegrator2" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0;"></div></div>
<div class="card-img-top" style="display:block; width: 100%; padding-top: 135.532%;  position:relative;"><div id="xa_RandomWalkIntegrator2_1" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0;"></div></div>
<script>
// MGH: Fixed
Jeri.renderViewer(document.getElementById('xa_RandomWalkIntegrator2'), {children: [{ title: '(a) RandomWalkIntegrator', image: 'watercolor-randomwalk.exr' }]});
Jeri.renderViewer(document.getElementById('xa_RandomWalkIntegrator2_1'), {children: [{ title: '(b) PathIntegrator', image: 'watercolor-path.exr' }]});
</script>
<figcaption class="caption">Figure 1.20: <em>Watercolor</em> Scene Rendered Using 32 Samples per Pixel. <span class="legend"> 
(a)&nbsp;Rendered using the <a href="#RandomWalkIntegrator"><tt>RandomWalkIntegrator</tt></a>. (b)&nbsp;Rendered using the
<a href="../Light_Transport_I_Surface_Reflection/A_Better_Path_Tracer.html#PathIntegrator"><tt>PathIntegrator</tt></a>, which follows the same general approach but uses
more sophisticated Monte Carlo techniques.  The <a href="../Light_Transport_I_Surface_Reflection/A_Better_Path_Tracer.html#PathIntegrator"><tt>PathIntegrator</tt></a> gives
a substantially better image for roughly the same amount of work, with 
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.942ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 2558.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">54.5 times</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-35" d="M449 201c0 -127 -102 -223 -218 -223c-112 0 -181 97 -181 183c0 46 35 53 49 53c33 0 50 -25 50 -49s-17 -49 -50 -49c-11 0 -14 1 -17 2c17 -59 74 -112 147 -112c46 0 83 26 107 65c24 42 24 102 24 137c0 50 -2 89 -18 126c-8 18 -33 64 -85 64 c-81 0 -118 -54 -129 -70c-4 -6 -6 -9 -13 -9c-14 0 -14 8 -14 26v296c0 16 0 24 10 24c0 0 4 0 12 -3c47 -21 93 -28 133 -28c67 0 116 20 136 29c5 3 8 3 8 3c7 0 10 -5 10 -11c0 -13 -70 -104 -193 -104c-32 0 -65 7 -85 13v-195c36 35 79 51 127 51 c108 0 190 -100 190 -219Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-34" d="M471 165h-100v-87c0 -36 2 -47 76 -47h21v-31c-41 3 -94 3 -136 3s-94 0 -135 -3v31h21c74 0 76 11 76 47v87h-266v31l307 469c8 12 11 12 20 12c16 0 16 -6 16 -26v-455h100v-31zM300 196v373l-244 -373h244Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2E" d="M192 53c0 -29 -24 -53 -53 -53s-53 24 -53 53s24 53 53 53s53 -24 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-D7" d="M624 15c-7 -8 -20 -8 -28 0l-207 207l-207 -207c-8 -8 -21 -8 -28 0c-8 7 -8 20 0 28l207 207l-207 207c-8 8 -8 21 0 28c7 8 20 8 28 0l207 -207l207 207c8 8 21 8 28 0c8 -7 8 -20 0 -28l-207 -207l207 -207c8 -8 8 -21 0 -28Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-35"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-34" x="500" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2E" x="1001" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-35" x="1279" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-D7" x="1780" y="0"></use>
</g>
</svg> reduction in mean squared error.</span>
</figcaption>
</div></div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

</div>  <!-- container-fluid -->
</div>  <!-- maincontainer -->

<nav class="navbar navbar-expand-md bg-light navbar-light">
<div class="container-fluid">
  <span class="navbar-text"><i>Physically Based Rendering: From Theory To Implementation</i>,<br>
<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">&copy; 2004-2023</a> Matt Pharr, Wenzel Jakob, and Greg Humphreys.
<a href="https://github.com/mmp/pbr-book-website/"><span class="fab fa-github"></span></a><br>
Purchase a printed copy: <a href="https://www.amazon.com/Physically-Based-Rendering-fourth-Implementation/dp/0262048027?keywords=physically+based+rendering+4th+edition&qid=1671730412&sprefix=physically+based%!C(MISSING)aps%!C(MISSING)145&sr=8-1&linkCode=ll1&tag=pharr-20&linkId=81a816d90f0c7e872617f1f930a51fd6&language=en_US&ref_=as_li_ss_tl"><span class="fab fa-amazon"></span></a>
<a href="https://mitpress.mit.edu/9780262048026/physically-based-rendering/"><img src="/mitpress.png" width=10 height=16></a>
</span>
</div>
  <div class="container">
    <ul class="nav navbar-nav ml-auto">
      <li class="nav-item">Next: <a href="../Introduction/How_to_Proceed_through_This_Book.html">Introduction / How to Proceed through This Book</a></li>
    </ul>
  </div>

</nav>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script>
  $(function () {
    $('[data-toggle="popover"]').popover()
    $('[data-toggle="tooltip"]').tooltip()
   })
</script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

<script>
// https://stackoverflow.com/a/17535094
// The function actually applying the offset
function offsetAnchor() {
  if (location.hash.length !== 0) {
    window.scrollTo(window.scrollX, window.scrollY - window.innerHeight / 8);
  }
}

// Captures click events of all <a> elements with href starting with #
$(document).on('click', 'a[href^="#"]', function(event) {
  // Click events are captured before hashchanges. Timeout
  // causes offsetAnchor to be called after the page jump.
  window.setTimeout(function() {
    offsetAnchor();
  }, 500);
});

// Set the offset when entering page with hash present in the url
window.setTimeout(offsetAnchor, 1500);
</script>

</body>
</html>
