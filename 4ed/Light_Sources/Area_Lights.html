
<!doctype html>
<html lang="en">
<head>

<!-- all praise to https://realfavicongenerator.net -->
<link rel="icon" href="/favicon.ico?v=2" /> <!-- force refresh -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="/fonts.css">
  <link rel="stylesheet" href="../pbrstyle.css">
  <link rel="stylesheet" href="/fontawesome-free-5.15.3-web/css/all.css">

<script async src="https://cse.google.com/cse.js?cx=22a43cef261a245ea"></script>  <script src="/react.min.js"></script>
  <script src="/react-dom.min.js"></script>
  <script src="/jeri.min.js"></script>
  <link rel="preload" href="/exr.worker.js" as="script" crossorigin="anonymous">
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/bootstrap.min.css">

  <title>Area Lights</title>
</head>
        
<body>

<nav class="fixed-top-lg-navbar navbar navbar-expand bg-light navbar-light">
  <ul class="nav navbar-nav">
    <a class="navbar-brand" href="../contents.html"><img src="../pbr.jpg" width=25 height=25></a>
    <li class="nav-item"><a class="nav-link" href="../Light_Sources.html">Light Sources</a></li>
    <span class="navbar-text">/</span>
    <li class="nav-item"><a class="nav-link" href="#">Area Lights</a></li>
    <span class="navbar-text">&nbsp;&nbsp;</span>
    <li class="nav-item"><a class="nav-link" href="../Light_Sources/Distant_Lights.html">(Previous: Distant Lights)</a></li>
  </ul>

  <ul class="nav navbar-nav ml-auto d-none d-md-block">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
  <ul class="nav navbar-nav d-block d-md-none">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
</nav>

<div class="maincontainer">
<div class="container-fluid">

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#"><i class="fas fa-link "></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:area-lights"></span><h2>12.4 Area Lights</h2><p>



</p>
<p>Area lights are defined by the combination of a <a href="../Shapes/Basic_Shape_Interface.html#Shape"><tt>Shape</tt></a> and a
directional distribution of radiance at each point on its surface.  In
general, computing radiometric quantities related to area lights requires
computing integrals over the surface of the light that often cannot be
computed in closed form, though they are well suited to Monte Carlo
integration.  The reward for this complexity (and computational expense) is
soft shadows and more realistic lighting effects, rather than the hard
shadows and stark lighting that come from point lights. (See
Figure&nbsp;<a href="#fig:light-arealight-scene">12.15</a>, which shows the effect of varying
the size of an area light source used to illuminate the dragon; compare its
soft look to illumination from a point light in
Figure&nbsp;<a href="../Light_Sources/Point_Lights.html#fig:light-pointlight">12.3</a>.)

</p>
<p></p>
<span class="anchor" id="fig:light-arealight-scene"></span><div class="card outerfigure"><div class="card-body figure"><p>


</p>

<div class="card-img-top" style="display:block; width: 100%; padding-top: 60%;  position:relative;"><div id="xa_Small_disk46" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0;"></div></div>
<div class="card-img-top" style="display:block; width: 100%; padding-top: 60%;  position:relative;"><div id="xa_Small_disk46_1" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0;"></div></div>
<script>
// MGH: Fixed
Jeri.renderViewer(document.getElementById('xa_Small_disk46'), {children: [{ title: '(a) Small disk', image: 'dragon-area-small.png' }]});
Jeri.renderViewer(document.getElementById('xa_Small_disk46_1'), {children: [{ title: '(b) Large disk', image: 'dragon-area-large.png' }]});
</script>
<figcaption class="caption">Figure 12.15: Dragon Model Illuminated by Disk
Area Lights. <span class="legend"> (a)&nbsp;The disk&rsquo;s radius is relatively small; the
shadow has soft penumbrae, but otherwise the image looks similar to the one
with a point light. (b)&nbsp;The effect of using a much
larger disk: not only have the penumbrae become much larger, to the point
of nearly eliminating the shadow of the tail, for example, but note also how
the shading on the body is smoother, with the specular highlights less
visible due to illumination coming from a wider range of directions.
<em>(Dragon model courtesy of the Stanford Computer Graphics Laboratory.)</em>
</span>
</figcaption>
</div></div><p>


</p>
<p>The <tt>DiffuseAreaLight</tt> class defines an area light where emission at
each point on the surface has a uniform directional distribution.

</p>
<p></p>
<span class="anchor" id="fragment-DiffuseAreaLightDefinition-0"></span><div class="fragmentname">&lt;&lt;DiffuseAreaLight Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="DiffuseAreaLight"></span>DiffuseAreaLight : public <a href="../Light_Sources/Light_Interface.html#LightBase" class="code">LightBase</a> {
  public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-DiffuseAreaLightPublicMethods-0">DiffuseAreaLight Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1662" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1662"><i></i></a><div id="fragbit-1662" class="collapse show"><div class="fragmentcode">       DiffuseAreaLight(const <a href="../Geometry_and_Transformations/Transformations.html#Transform" class="code">Transform</a> &amp;renderFromLight,
                        const <a href="../Volume_Scattering/Media.html#MediumInterface" class="code">MediumInterface</a> &amp;mediumInterface, <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#Spectrum" class="code">Spectrum</a> Le,
                        Float <a href="#DiffuseAreaLight::scale" class="code">scale</a>, const <a href="../Shapes/Basic_Shape_Interface.html#Shape" class="code">Shape</a> shape, <a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture" class="code">FloatTexture</a> alpha, <a href="../Utilities/Images.html#Image" class="code">Image</a> <a href="#DiffuseAreaLight::image" class="code">image</a>,
                        const <a href="../Radiometry,_Spectra,_and_Color/Color.html#RGBColorSpace" class="code">RGBColorSpace</a> *imageColorSpace, bool twoSided);
       
       static DiffuseAreaLight *Create(const <a href="../Geometry_and_Transformations/Transformations.html#Transform" class="code">Transform</a> &amp;renderFromLight,
                                       <a href="../Volume_Scattering/Media.html#Medium" class="code">Medium</a> medium,
                                       const ParameterDictionary &amp;parameters,
                                       const <a href="../Radiometry,_Spectra,_and_Color/Color.html#RGBColorSpace" class="code">RGBColorSpace</a> *colorSpace, const FileLoc *loc,
                                       Allocator alloc, const <a href="../Shapes/Basic_Shape_Interface.html#Shape" class="code">Shape</a> shape,
                                       <a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture" class="code">FloatTexture</a> alpha);
       
       void Preprocess(const <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> &amp;sceneBounds) {}
       
       
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> Phi(<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> lambda) const;
       
       PBRT_CPU_GPU
       pstd::optional&lt;LightLeSample&gt; SampleLe(<a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> u1, <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> u2,
                              <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda,
                              Float time) const;
       PBRT_CPU_GPU
       void PDF_Le(const <a href="../Geometry_and_Transformations/Interactions.html#Interaction" class="code">Interaction</a> &amp;, <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> w, Float *pdfPos, Float *pdfDir) const;
       
       pstd::optional&lt;<a href="../Light_Sources/Light_Sampling.html#LightBounds" class="code">LightBounds</a>&gt; Bounds() const;
       
       PBRT_CPU_GPU
       void PDF_Le(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;, Float *pdfPos, Float *pdfDir) const {
           LOG_FATAL("Shouldn't be called for area lights");
       }
       
       std::string ToString() const;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> L(<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> p, <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> n, <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> uv, <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> w,
                         const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda) const {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Checkforzeroemittedradiancefrompointonarealight-0">Check for zero emitted radiance from point on area light</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1663" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1663"><i></i></a><div id="fragbit-1663" class="collapse show"><div class="fragmentcode">              if (!<a href="#DiffuseAreaLight::twoSided" class="code">twoSided</a> &amp;&amp; <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(n, w) &lt; 0)
                  return <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
              if (<a href="#DiffuseAreaLight::AlphaMasked" class="code">AlphaMasked</a>(<a href="../Geometry_and_Transformations/Interactions.html#Interaction" class="code">Interaction</a>(p, uv)))
                  return <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);</div></div>
           if (<a href="#DiffuseAreaLight::image" class="code">image</a>) {
               &lt;&lt;<span class="fragmentname"><a href="#fragment-ReturnmonoDiffuseAreaLightemissionusingimage-0">Return <tt>DiffuseAreaLight</tt> emission using image</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1664" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1664"><i></i></a><div id="fragbit-1664" class="collapse show"><div class="fragmentcode">                  <a href="../Radiometry,_Spectra,_and_Color/Color.html#RGB" class="code">RGB</a> rgb;
                  uv[1] = 1 - uv[1];
                  for (int c = 0; c &lt; 3; ++c)
                      rgb[c] = <a href="#DiffuseAreaLight::image" class="code">image</a>.<a href="../Utilities/Images.html#Image::BilerpChannel" class="code">BilerpChannel</a>(uv, c);
                  <a href="../Radiometry,_Spectra,_and_Color/Color.html#RGBIlluminantSpectrum" class="code">RGBIlluminantSpectrum</a> spec(*<a href="#DiffuseAreaLight::imageColorSpace" class="code">imageColorSpace</a>, ClampZero(rgb));
                  return <a href="#DiffuseAreaLight::scale" class="code">scale</a> * spec.<a href="../Radiometry,_Spectra,_and_Color/Color.html#RGBIlluminantSpectrum::Sample" class="code">Sample</a>(lambda);</div></div>
           } else
               return <a href="#DiffuseAreaLight::scale" class="code">scale</a> * <a href="#DiffuseAreaLight::Lemit" class="code">Lemit</a>-&gt;<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#DenselySampledSpectrum::Sample" class="code">Sample</a>(lambda);
       }
       pstd::optional&lt;<a href="../Light_Sources/Light_Interface.html#LightLiSample" class="code">LightLiSample</a>&gt; SampleLi(<a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx, <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> u,
                <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> lambda, bool allowIncompletePDF) const;
       Float PDF_Li(<a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx, <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wi, bool allowIncompletePDF) const;</div></div>
  private:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-DiffuseAreaLightPrivateMembers-0">DiffuseAreaLight Private Members</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1665" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1665"><i></i></a><div id="fragbit-1665" class="collapse show"><div class="fragmentcode">       <a href="../Shapes/Basic_Shape_Interface.html#Shape" class="code">Shape</a> shape;
       <a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture" class="code">FloatTexture</a> alpha;
       Float area;
       bool twoSided;
       const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#DenselySampledSpectrum" class="code">DenselySampledSpectrum</a> *Lemit;
       Float scale;
       <a href="../Utilities/Images.html#Image" class="code">Image</a> image;
       const <a href="../Radiometry,_Spectra,_and_Color/Color.html#RGBColorSpace" class="code">RGBColorSpace</a> *imageColorSpace;</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-DiffuseAreaLightPrivateMethods-0">DiffuseAreaLight Private Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1666" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1666"><i></i></a><div id="fragbit-1666" class="collapse show"><div class="fragmentcode">       bool AlphaMasked(const <a href="../Geometry_and_Transformations/Interactions.html#Interaction" class="code">Interaction</a> &amp;intr) const {
           if (!<a href="#DiffuseAreaLight::alpha" class="code">alpha</a>) return false;
           Float a = UniversalTextureEvaluator()(<a href="#DiffuseAreaLight::alpha" class="code">alpha</a>, intr);
           if (a &gt;= 1) return false;
           if (a &lt;= 0) return true;
           return <a href="../Utilities/Mathematical_Infrastructure.html#HashFloat" class="code">HashFloat</a>(intr.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::p" class="code">p</a>()) &gt; a;
       }</div></div>
};</div><p>


</p>
<p>

</p>
<p>

</p>
<p>Its constructor, not included here, sets the following member variables
from the parameters provided to it.  If an <tt>alpha</tt> texture has been
associated with the shape to cut away parts of its surface, it is used here
so that there is no illumination from those parts of the
shape.<button style="button" data-toggle="tooltip" data-placement="right" data-html="true" class="btn footnote-button" title="As a special case, <tt>pbrt</tt> also (reluctantly) supports the trick of creating an
invisible light source by specifying a light with a zero-valued alpha
texture.  Though non-physical, such lights can be useful for artistic
purposes.  In code not included in the text here, the
<tt>DiffuseAreaLight</tt> constructor characterizes them as being of
<tt>LightType::DeltaPosition</tt>, which leads to their being handled
correctly in the lighting integration routines even though rays can never
intersect them.">
      <sup>&dagger;</sup>
    </button>
		
(Recall that alpha masking was introduced in Section&nbsp;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#sec:gprim">7.1.1</a>.)
The area of the emissive <a href="../Shapes/Basic_Shape_Interface.html#Shape"><tt>Shape</tt></a> is
needed in a number of the following methods and so is cached in a member
variable.

</p>
<p></p>
<span class="anchor" id="fragment-DiffuseAreaLightPrivateMembers-0"></span><div class="fragmentname">&lt;&lt;DiffuseAreaLight Private Members&gt;&gt;=&nbsp;<a href="#fragment-DiffuseAreaLightPrivateMembers-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Shapes/Basic_Shape_Interface.html#Shape" class="code">Shape</a> <span class="anchor" id="DiffuseAreaLight::shape"></span>shape;
<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture" class="code">FloatTexture</a> <span class="anchor" id="DiffuseAreaLight::alpha"></span>alpha;
Float <span class="anchor" id="DiffuseAreaLight::area"></span>area;</div><p>


</p>
<p>A number of parameters specify emission from <tt>DiffuseAreaLight</tt>s.  By
default, emission is only on one side of the surface, where the surface
normal is outward-facing.  A scaling transform that flips the normal or the
<tt>ReverseOrientation</tt> directive in the scene description file can be
used to cause emission to be on the other side of the surface. If
<tt>twoSided</tt> is true, then the light emits on both sides.

</p>
<p>Emission that varies over the surface can be defined using an <a href="../Utilities/Images.html#Image"><tt>Image</tt></a>;
if one is provided to the constructor, the surface will have
spatially varying emission defined by its color values.  Otherwise,
spatially uniform emitted spectral radiance is given by a provided
<tt>Lemit</tt> spectrum.  For both methods of specifying emission, an
additional scale factor in <tt>scale</tt> is applied to the returned
radiance.

</p>
<p></p>
<span class="anchor" id="fragment-DiffuseAreaLightPrivateMembers-1"></span><div class="fragmentname">&lt;&lt;DiffuseAreaLight Private Members&gt;&gt;+=&nbsp;<a href="#fragment-DiffuseAreaLightPrivateMembers-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">bool <span class="anchor" id="DiffuseAreaLight::twoSided"></span>twoSided;
const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#DenselySampledSpectrum" class="code">DenselySampledSpectrum</a> *<span class="anchor" id="DiffuseAreaLight::Lemit"></span>Lemit;
Float <span class="anchor" id="DiffuseAreaLight::scale"></span>scale;
<a href="../Utilities/Images.html#Image" class="code">Image</a> <span class="anchor" id="DiffuseAreaLight::image"></span>image;
const <a href="../Radiometry,_Spectra,_and_Color/Color.html#RGBColorSpace" class="code">RGBColorSpace</a> *<span class="anchor" id="DiffuseAreaLight::imageColorSpace"></span>imageColorSpace;</div><p>


</p>
<p>Recall from Section&nbsp;<a href="../Light_Sources/Light_Interface.html#sec:light">12.1</a> that the <a href="../Light_Sources/Light_Interface.html#Light"><tt>Light</tt></a> interface includes
an <tt>L()</tt> method that area lights must implement to provide the emitted
radiance at a specified point on their surface.  This method is called if a
ray happens to intersect an emissive surface, for example.
<tt>DiffuseAreaLight</tt>&rsquo;s implementation starts by checking a few cases in
which there is no emitted radiance before calculating emission using the
<a href="../Utilities/Images.html#Image"><tt>Image</tt></a>, if provided, and otherwise the specified constant radiance.

</p>
<p></p>
<span class="anchor" id="fragment-DiffuseAreaLightPublicMethods-0"></span><div class="fragmentname">&lt;&lt;DiffuseAreaLight Public Methods&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="DiffuseAreaLight::L"></span>L(<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> p, <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> n, <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> uv, <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> w,
                  const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda) const {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Checkforzeroemittedradiancefrompointonarealight-0">Check for zero emitted radiance from point on area light</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1667" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1667"><i></i></a><div id="fragbit-1667" class="collapse show"><div class="fragmentcode">       if (!<a href="#DiffuseAreaLight::twoSided" class="code">twoSided</a> &amp;&amp; <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(n, w) &lt; 0)
           return <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
       if (<a href="#DiffuseAreaLight::AlphaMasked" class="code">AlphaMasked</a>(<a href="../Geometry_and_Transformations/Interactions.html#Interaction" class="code">Interaction</a>(p, uv)))
           return <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);</div></div>
    if (<a href="#DiffuseAreaLight::image" class="code">image</a>) {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-ReturnmonoDiffuseAreaLightemissionusingimage-0">Return <tt>DiffuseAreaLight</tt> emission using image</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1668" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1668"><i></i></a><div id="fragbit-1668" class="collapse show"><div class="fragmentcode">           <a href="../Radiometry,_Spectra,_and_Color/Color.html#RGB" class="code">RGB</a> rgb;
           uv[1] = 1 - uv[1];
           for (int c = 0; c &lt; 3; ++c)
               rgb[c] = <a href="#DiffuseAreaLight::image" class="code">image</a>.<a href="../Utilities/Images.html#Image::BilerpChannel" class="code">BilerpChannel</a>(uv, c);
           <a href="../Radiometry,_Spectra,_and_Color/Color.html#RGBIlluminantSpectrum" class="code">RGBIlluminantSpectrum</a> spec(*<a href="#DiffuseAreaLight::imageColorSpace" class="code">imageColorSpace</a>, ClampZero(rgb));
           return <a href="#DiffuseAreaLight::scale" class="code">scale</a> * spec.<a href="../Radiometry,_Spectra,_and_Color/Color.html#RGBIlluminantSpectrum::Sample" class="code">Sample</a>(lambda);</div></div>
    } else
        return <a href="#DiffuseAreaLight::scale" class="code">scale</a> * <a href="#DiffuseAreaLight::Lemit" class="code">Lemit</a>-&gt;<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#DenselySampledSpectrum::Sample" class="code">Sample</a>(lambda);
}</div><p>


</p>
<p>Two cases allow immediately returning no emitted radiance: the first is if
the light is one-sided and the outgoing direction <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.446ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 622.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">omega Subscript</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D714" d="M604 372c0 -40 -12 -90 -23 -133c-30 -121 -93 -250 -197 -250c-67 0 -102 44 -113 106c-38 -62 -90 -106 -153 -106c-76 0 -105 62 -105 143c0 35 5 74 15 112c16 63 41 127 82 184c5 6 12 9 18 9c3 0 6 0 9 -2c5 -3 9 -8 9 -14c0 -4 -2 -9 -5 -13 c-38 -53 -74 -109 -89 -169c-5 -22 -8 -45 -8 -65c0 -63 26 -113 87 -113c55 0 103 39 136 93c1 29 5 59 13 90c5 22 15 47 34 47c14 0 19 -11 19 -26c0 -8 -2 -17 -4 -26c-7 -30 -17 -60 -30 -88c9 -52 42 -90 98 -90c79 0 137 92 160 183c3 12 4 25 4 37 c0 35 -13 66 -38 88c-7 7 -11 15 -11 25c0 11 5 22 14 32c10 10 23 16 35 16c9 0 17 -3 23 -9c15 -13 20 -35 20 -61Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
</g>
</svg> faces away from
the surface normal and the second is if the point on the light&rsquo;s surface
has been cut away by an alpha texture.

</p>
<p></p>
<span class="anchor" id="fragment-Checkforzeroemittedradiancefrompointonarealight-0"></span><div class="fragmentname">&lt;&lt;Check for zero emitted radiance from point on area light&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (!<a href="#DiffuseAreaLight::twoSided" class="code">twoSided</a> &amp;&amp; <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(n, w) &lt; 0)
    return <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
if (<a href="#DiffuseAreaLight::AlphaMasked" class="code">AlphaMasked</a>(<a href="../Geometry_and_Transformations/Interactions.html#Interaction" class="code">Interaction</a>(p, uv)))
    return <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);</div><p>


</p>
<p>The <tt>AlphaMasked()</tt> method performs a stochastic alpha test for a
point on the light.

</p>
<p></p>
<span class="anchor" id="fragment-DiffuseAreaLightPrivateMethods-0"></span><div class="fragmentname">&lt;&lt;DiffuseAreaLight Private Methods&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">bool <span class="anchor" id="DiffuseAreaLight::AlphaMasked"></span>AlphaMasked(const <a href="../Geometry_and_Transformations/Interactions.html#Interaction" class="code">Interaction</a> &amp;intr) const {
    if (!<a href="#DiffuseAreaLight::alpha" class="code">alpha</a>) return false;
    Float a = UniversalTextureEvaluator()(<a href="#DiffuseAreaLight::alpha" class="code">alpha</a>, intr);
    if (a &gt;= 1) return false;
    if (a &lt;= 0) return true;
    return <a href="../Utilities/Mathematical_Infrastructure.html#HashFloat" class="code">HashFloat</a>(intr.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::p" class="code">p</a>()) &gt; a;
}</div><p>


</p>
<p>If an <a href="../Utilities/Images.html#Image"><tt>Image</tt></a> has been provided to specify emission, then the emitted radiance is found by
looking up an RGB value and converting it to the requested spectral
samples.  Note that the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.128ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 485.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">v</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="0" y="0"></use>
</g>
</svg> coordinate is inverted before being passed to
<tt>BilerpChannel()</tt>; in this way, the parameterization matches the image
texture coordinate conventions that were described in
Section&nbsp;<a href="../Textures_and_Materials/Image_Texture.html#sec:image-texture-eval">10.4.2</a>.
(See Figure&nbsp;<a href="../Shapes/Bilinear_Patches.html#fig:area-sampling-image-emission">6.26</a> for a scene
with an area light source with emission defined using an image.)

</p>
<p></p>
<span class="anchor" id="fragment-ReturnmonoDiffuseAreaLightemissionusingimage-0"></span><div class="fragmentname">&lt;&lt;Return <tt>DiffuseAreaLight</tt> emission using image&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Color.html#RGB" class="code">RGB</a> rgb;
uv[1] = 1 - uv[1];
for (int c = 0; c &lt; 3; ++c)
    rgb[c] = <a href="#DiffuseAreaLight::image" class="code">image</a>.<a href="../Utilities/Images.html#Image::BilerpChannel" class="code">BilerpChannel</a>(uv, c);
<a href="../Radiometry,_Spectra,_and_Color/Color.html#RGBIlluminantSpectrum" class="code">RGBIlluminantSpectrum</a> spec(*<a href="#DiffuseAreaLight::imageColorSpace" class="code">imageColorSpace</a>, ClampZero(rgb));
return <a href="#DiffuseAreaLight::scale" class="code">scale</a> * spec.<a href="../Radiometry,_Spectra,_and_Color/Color.html#RGBIlluminantSpectrum::Sample" class="code">Sample</a>(lambda);</div><p>


</p>
<p>For convenience, we will add a method to the <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction"><tt>SurfaceInteraction</tt></a> class
that makes it easy to compute the emitted radiance at a surface point
intersected by a ray.

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-SurfaceInteractionMethodDefinitions-4"></span><div class="fragmentname">&lt;&lt;SurfaceInteraction Method Definitions&gt;&gt;+=&nbsp;<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#fragment-SurfaceInteractionMethodDefinitions-3"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="SurfaceInteraction::Le"></span><a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a>::Le(<a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> w,
        const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda) const {
    return <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#SurfaceInteraction::areaLight" class="code">areaLight</a> ? <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#SurfaceInteraction::areaLight" class="code">areaLight</a>.<a href="../Light_Sources/Light_Interface.html#Light::L" class="code">L</a>(<a href="../Geometry_and_Transformations/Interactions.html#Interaction::p" class="code">p</a>(), <a href="../Geometry_and_Transformations/Interactions.html#Interaction::n" class="code">n</a>, <a href="../Geometry_and_Transformations/Interactions.html#Interaction::uv" class="code">uv</a>, w, lambda)
                     : <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
}</div><p>


</p>
<p>All the <tt>SampleLi()</tt> methods so far have been deterministic:
because all the preceding light models have been defined in terms of
Dirac delta distributions of either position or direction, there has only
been a single incident direction along which illumination arrives at any
point.  This is no longer the case with area lights and we will finally
make use of the uniform 2D sample <tt>u</tt>.

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-DiffuseAreaLightMethodDefinitions-0"></span><div class="fragmentname">&lt;&lt;DiffuseAreaLight Method Definitions&gt;&gt;=&nbsp;<a href="#fragment-DiffuseAreaLightMethodDefinitions-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">pstd::optional&lt;<a href="../Light_Sources/Light_Interface.html#LightLiSample" class="code">LightLiSample</a>&gt;
<span class="anchor" id="DiffuseAreaLight::SampleLi"></span>DiffuseAreaLight::SampleLi(<a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx, <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> u,
         <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> lambda, bool allowIncompletePDF) const {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-SamplepointonshapeformonoDiffuseAreaLight-0">Sample point on shape for <tt>DiffuseAreaLight</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1669" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1669"><i></i></a><div id="fragbit-1669" class="collapse show"><div class="fragmentcode">       <a href="../Shapes/Basic_Shape_Interface.html#ShapeSampleContext" class="code">ShapeSampleContext</a> shapeCtx(ctx.<a href="../Light_Sources/Light_Interface.html#LightSampleContext::pi" class="code">pi</a>, ctx.<a href="../Light_Sources/Light_Interface.html#LightSampleContext::n" class="code">n</a>, ctx.<a href="../Light_Sources/Light_Interface.html#LightSampleContext::ns" class="code">ns</a>, 0 /* time */);
       pstd::optional&lt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample" class="code">ShapeSample</a>&gt; ss = <a href="#DiffuseAreaLight::shape" class="code">shape</a>.<a href="../Shapes/Basic_Shape_Interface.html#Shape::Sample" class="code">Sample</a>(shapeCtx, u);
       if (!ss || ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::pdf" class="code">pdf</a> == 0 || LengthSquared(ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::intr" class="code">intr</a>.<a href="../Light_Sources/Light_Interface.html#LightSampleContext::p" class="code">p</a>() - ctx.<a href="../Light_Sources/Light_Interface.html#LightSampleContext::p" class="code">p</a>()) == 0)
           return {};
       ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::intr" class="code">intr</a>.<a href="../Light_Sources/Light_Interface.html#LightBase::mediumInterface" class="code">mediumInterface</a> = &amp;<a href="../Light_Sources/Light_Interface.html#LightBase::mediumInterface" class="code">mediumInterface</a>;</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Checksampledpointonshapeagainstalphatextureifpresent-0">Check sampled point on shape against alpha texture, if present</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1670" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1670"><i></i></a><div id="fragbit-1670" class="collapse show"><div class="fragmentcode">       if (<a href="#DiffuseAreaLight::AlphaMasked" class="code">AlphaMasked</a>(ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::intr" class="code">intr</a>))
           return {};</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-ReturnmonoLightLiSampleforsampledpointonshape-0">Return <tt>LightLiSample</tt> for sampled point on shape</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1671" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1671"><i></i></a><div id="fragbit-1671" class="collapse show"><div class="fragmentcode">       <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wi = <a href="../Geometry_and_Transformations/Vectors.html#Normalize" class="code">Normalize</a>(ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::intr" class="code">intr</a>.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::p" class="code">p</a>() - ctx.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::p" class="code">p</a>());
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> Le = <a href="#DiffuseAreaLight::L" class="code">L</a>(ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::intr" class="code">intr</a>.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::p" class="code">p</a>(), ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::intr" class="code">intr</a>.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::n" class="code">n</a>, ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::intr" class="code">intr</a>.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::uv" class="code">uv</a>, -wi, lambda);
       if (!Le) return {};
       return <a href="../Light_Sources/Light_Interface.html#LightLiSample" class="code">LightLiSample</a>(Le, wi, ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::pdf" class="code">pdf</a>, ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::intr" class="code">intr</a>);</div></div>
}</div><p>


</p>
<p>The second variant of <a href="../Shapes/Basic_Shape_Interface.html#Shape::Sample"><tt>Shape::Sample()</tt></a>, which takes a receiving point
and returns a point on the shape and PDF expressed with respect to solid
angle at the receiving point, is an exact match for the <tt>Light</tt>
<tt>SampleLi()</tt> interface.  Therefore, the implementation starts by
calling that method.

</p>
<p>The astute reader will note that if an image is being used to define the
light&rsquo;s emission, leaving the sampling task to the shape alone may not
be ideal. Yet, extending the <a href="../Shapes/Basic_Shape_Interface.html#Shape"><tt>Shape</tt></a>&rsquo;s sampling interface to optionally
take a reference to an <a href="../Utilities/Images.html#Image"><tt>Image</tt></a> or some other representation of
spatially varying emission would be a clunky addition.  <tt>pbrt</tt>&rsquo;s solution to
this problem is that <a href="../Shapes/Bilinear_Patches.html#BilinearPatch"><tt>BilinearPatch</tt></a> shapes (but no others) allow
specifying an image to use for sampling.  
To have to specify this information twice in the
scene description is admittedly not ideal, but it suffices to make the common case of a
quadrilateral emitter with an image work out.

</p>
<p></p>
<span class="anchor" id="fragment-SamplepointonshapeformonoDiffuseAreaLight-0"></span><div class="fragmentname">&lt;&lt;Sample point on shape for <tt>DiffuseAreaLight</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Shapes/Basic_Shape_Interface.html#ShapeSampleContext" class="code">ShapeSampleContext</a> shapeCtx(ctx.<a href="../Light_Sources/Light_Interface.html#LightSampleContext::pi" class="code">pi</a>, ctx.<a href="../Light_Sources/Light_Interface.html#LightSampleContext::n" class="code">n</a>, ctx.<a href="../Light_Sources/Light_Interface.html#LightSampleContext::ns" class="code">ns</a>, 0 /* time */);
pstd::optional&lt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample" class="code">ShapeSample</a>&gt; ss = <a href="#DiffuseAreaLight::shape" class="code">shape</a>.<a href="../Shapes/Basic_Shape_Interface.html#Shape::Sample" class="code">Sample</a>(shapeCtx, u);
if (!ss || ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::pdf" class="code">pdf</a> == 0 || LengthSquared(ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::intr" class="code">intr</a>.<a href="../Light_Sources/Light_Interface.html#LightSampleContext::p" class="code">p</a>() - ctx.<a href="../Light_Sources/Light_Interface.html#LightSampleContext::p" class="code">p</a>()) == 0)
    return {};
ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::intr" class="code">intr</a>.<a href="../Light_Sources/Light_Interface.html#LightBase::mediumInterface" class="code">mediumInterface</a> = &amp;<a href="../Light_Sources/Light_Interface.html#LightBase::mediumInterface" class="code">mediumInterface</a>;</div><p>


</p>
<p>If the sampled point has been masked by the alpha texture, an invalid
sample is returned.

</p>
<p></p>
<span class="anchor" id="fragment-Checksampledpointonshapeagainstalphatextureifpresent-0"></span><div class="fragmentname">&lt;&lt;Check sampled point on shape against alpha texture, if present&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (<a href="#DiffuseAreaLight::AlphaMasked" class="code">AlphaMasked</a>(ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::intr" class="code">intr</a>))
    return {};</div><p>


</p>
<p>If the shape has generated a valid sample, the next step is to compute the
emitted radiance at the sample point.  If that is a zero-valued spectrum,
then an unset sample value is returned; calling code can then avoid the
expense of tracing an unnecessary shadow ray.

</p>
<p></p>
<span class="anchor" id="fragment-ReturnmonoLightLiSampleforsampledpointonshape-0"></span><div class="fragmentname">&lt;&lt;Return <tt>LightLiSample</tt> for sampled point on shape&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wi = <a href="../Geometry_and_Transformations/Vectors.html#Normalize" class="code">Normalize</a>(ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::intr" class="code">intr</a>.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::p" class="code">p</a>() - ctx.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::p" class="code">p</a>());
<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> Le = <a href="#DiffuseAreaLight::L" class="code">L</a>(ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::intr" class="code">intr</a>.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::p" class="code">p</a>(), ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::intr" class="code">intr</a>.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::n" class="code">n</a>, ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::intr" class="code">intr</a>.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::uv" class="code">uv</a>, -wi, lambda);
if (!Le) return {};
return <a href="../Light_Sources/Light_Interface.html#LightLiSample" class="code">LightLiSample</a>(Le, wi, ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::pdf" class="code">pdf</a>, ss-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeSample::intr" class="code">intr</a>);</div><p>


</p>
<p>The PDF for sampling a given direction from a receiving point is also
easily handled, again thanks to <a href="../Shapes/Basic_Shape_Interface.html#Shape"><tt>Shape</tt></a> providing a corresponding method.

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-DiffuseAreaLightMethodDefinitions-1"></span><div class="fragmentname">&lt;&lt;DiffuseAreaLight Method Definitions&gt;&gt;+=&nbsp;<a href="#fragment-DiffuseAreaLightMethodDefinitions-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-DiffuseAreaLightMethodDefinitions-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">Float <span class="anchor" id="DiffuseAreaLight::PDF_Li"></span>DiffuseAreaLight::PDF_Li(<a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx, <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wi,
                               bool allowIncompletePDF) const {
    <a href="../Shapes/Basic_Shape_Interface.html#ShapeSampleContext" class="code">ShapeSampleContext</a> shapeCtx(ctx.<a href="../Light_Sources/Light_Interface.html#LightSampleContext::pi" class="code">pi</a>, ctx.<a href="../Light_Sources/Light_Interface.html#LightSampleContext::n" class="code">n</a>, ctx.<a href="../Light_Sources/Light_Interface.html#LightSampleContext::ns" class="code">ns</a>, 0 /* time */);
    return <a href="#DiffuseAreaLight::shape" class="code">shape</a>.<a href="../Shapes/Basic_Shape_Interface.html#Shape::PDF" class="code">PDF</a>(shapeCtx, wi);
}</div><p>


</p>
<p>Emitted power from an area light with uniform emitted radiance over the
surface can be computed in closed form: from
Equation&nbsp;(<a href="../Radiometry,_Spectra,_and_Color/Radiometry.html#eq:irradiance-to-power">4.1</a>) it follows that it is <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.325ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 570.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">pi</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D70B" d="M567 407c0 -34 -36 -34 -49 -34h-114c-11 -52 -18 -106 -18 -159c0 -28 0 -93 29 -165c6 -14 6 -16 6 -22c0 -20 -21 -38 -41 -38c-15 0 -26 6 -36 50c-8 34 -8 61 -8 76c0 67 9 110 42 258h-113l-56 -221c-13 -50 -13 -52 -27 -98c-12 -37 -20 -65 -50 -65 c-13 0 -29 8 -29 27c0 7 0 9 8 24c42 91 96 212 128 333h-57c-20 0 -78 0 -127 -77c-6 -8 -8 -12 -16 -12c-12 0 -12 10 -12 10c0 5 26 51 61 90c44 47 82 47 104 47h335c19 0 40 0 40 -24Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D70B" x="0" y="0"></use>
</g>
</svg> times
the surface area times the emitted radiance.  If an image has been
specified for the emission, its average value is computed in a fragment
that is not included here.  That computation neglects the effect of any
alpha texture and effectively assumes that there is no
distortion in the surface&rsquo;s <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.301ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2282.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis u comma v right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D462" d="M543 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-43 0 -78 26 -89 67c-17 -22 -53 -67 -119 -67c-54 0 -123 25 -123 120c0 49 21 111 58 210c6 15 17 44 17 68c0 32 -16 33 -25 33c-38 0 -76 -37 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -17 -63c-26 -69 -54 -148 -54 -204c0 -37 10 -82 62 -82c73 0 113 80 114 84l75 301c8 34 34 35 39 35c15 0 29 -9 29 -27c0 -6 -10 -44 -15 -67c-4 -15 -14 -53 -17 -68l-28 -108c-8 -35 -20 -82 -20 -104 c0 -33 10 -46 31 -46c42 0 61 68 75 124c3 14 4 18 14 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D462" x="389" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="962" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="1407" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="1892" y="0"></use>
</g>
</svg> parameterization.  If these are not the
case, there will be error in the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.678ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 722.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal upper Phi</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-3A6" d="M665 341c0 -101 -111 -194 -266 -206v-56c0 -35 0 -48 95 -48h33v-31c-36 3 -129 3 -170 3s-133 0 -169 -3v31h33c95 0 95 14 95 48v56c-149 15 -260 104 -260 207c0 99 107 191 260 206v56c0 35 0 48 -95 48h-33v31c36 -3 129 -3 170 -3s133 0 169 3v-31h-33 c-95 0 -95 -14 -95 -48v-56c152 -12 266 -103 266 -207zM316 158v367c-150 -20 -160 -132 -160 -184c0 -62 18 -164 160 -183zM565 342c0 76 -28 168 -166 184v-369c151 18 166 125 166 185Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-3A6" x="0" y="0"></use>
</g>
</svg> value.

</p>
<p></p>
<span class="anchor" id="fragment-DiffuseAreaLightMethodDefinitions-2"></span><div class="fragmentname">&lt;&lt;DiffuseAreaLight Method Definitions&gt;&gt;+=&nbsp;<a href="#fragment-DiffuseAreaLightMethodDefinitions-1"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="Light_Sampling.html#fragment-DiffuseAreaLightMethodDefinitions-3"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="DiffuseAreaLight::Phi"></span>DiffuseAreaLight::Phi(<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> lambda) const {
    <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> L(0.f);
    if (<a href="#DiffuseAreaLight::image" class="code">image</a>) {
        &lt;&lt;<span class="fragmentname">Compute average light image emission</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1672" role="button" class="fa codecarat" aria-expanded="true" aria-controls="fragbit-1672"><i></i></a><div id="fragbit-1672" class="collapse show"><div class="fragmentcode">           for (int y = 0; y &lt; image.Resolution().y; ++y)
               for (int x = 0; x &lt; image.Resolution().x; ++x) {
                   <a href="../Radiometry,_Spectra,_and_Color/Color.html#RGB" class="code">RGB</a> rgb;
                   for (int c = 0; c &lt; 3; ++c)
                       rgb[c] = image.GetChannel({x, y}, c);
                   L += RGBIlluminantSpectrum(*imageColorSpace, ClampZero(rgb)).Sample(lambda);
               }
           L *= <a href="#DiffuseAreaLight::scale" class="code">scale</a> / (image.Resolution().x * image.Resolution().y);</div></div>
    } else
        L = <a href="#DiffuseAreaLight::Lemit" class="code">Lemit</a>-&gt;<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#DenselySampledSpectrum::Sample" class="code">Sample</a>(lambda) * <a href="#DiffuseAreaLight::scale" class="code">scale</a>;
    return <a href="../Utilities/Mathematical_Infrastructure.html#Pi" class="code">Pi</a> * (<a href="#DiffuseAreaLight::twoSided" class="code">twoSided</a> ? 2 : 1) * <a href="#DiffuseAreaLight::area" class="code">area</a> * L;
}</div><p>


</p>
<p>

</p>
<p>


</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

</div>  <!-- container-fluid -->
</div>  <!-- maincontainer -->

<nav class="navbar navbar-expand-md bg-light navbar-light">
<div class="container-fluid">
  <span class="navbar-text"><i>Physically Based Rendering: From Theory To Implementation</i>,<br>
<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">&copy; 2004-2023</a> Matt Pharr, Wenzel Jakob, and Greg Humphreys.
<a href="https://github.com/mmp/pbr-book-website/"><span class="fab fa-github"></span></a><br>
Purchase a printed copy: <a href="https://www.amazon.com/Physically-Based-Rendering-fourth-Implementation/dp/0262048027?keywords=physically+based+rendering+4th+edition&qid=1671730412&sprefix=physically+based%!C(MISSING)aps%!C(MISSING)145&sr=8-1&linkCode=ll1&tag=pharr-20&linkId=81a816d90f0c7e872617f1f930a51fd6&language=en_US&ref_=as_li_ss_tl"><span class="fab fa-amazon"></span></a>
<a href="https://mitpress.mit.edu/9780262048026/physically-based-rendering/"><img src="/mitpress.png" width=10 height=16></a>
</span>
</div>
  <div class="container">
    <ul class="nav navbar-nav ml-auto">
      <li class="nav-item">Next: <a href="../Light_Sources/Infinite_Area_Lights.html">Light Sources / Infinite Area Lights</a></li>
    </ul>
  </div>

</nav>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script>
  $(function () {
    $('[data-toggle="popover"]').popover()
    $('[data-toggle="tooltip"]').tooltip()
   })
</script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

<script>
// https://stackoverflow.com/a/17535094
// The function actually applying the offset
function offsetAnchor() {
  if (location.hash.length !== 0) {
    window.scrollTo(window.scrollX, window.scrollY - window.innerHeight / 8);
  }
}

// Captures click events of all <a> elements with href starting with #
$(document).on('click', 'a[href^="#"]', function(event) {
  // Click events are captured before hashchanges. Timeout
  // causes offsetAnchor to be called after the page jump.
  window.setTimeout(function() {
    offsetAnchor();
  }, 500);
});

// Set the offset when entering page with hash present in the url
window.setTimeout(offsetAnchor, 1500);
</script>

</body>
</html>
